<pre class="metadata">
Title: App History API
Shortname: app-history
Repository: WICG/app-history
Inline Github Issues: true
Group: WICG
Status: CG-DRAFT
Level: 1
URL: https://wicg.github.io/app-history/
Boilerplate: omit conformance, omit feedback-header
Editor: Domenic Denicola, Google https://www.google.com/, d@domenic.me, https://domenic.me/
Abstract: The app history API provides a web application-focused way of managing same-origin same-frame history entries and navigations.
!Participate: <a href="https://github.com/WICG/app-history">GitHub WICG/app-history</a> (<a href="https://github.com/WICG/app-history/issues/new">new issue</a>, <a href="https://github.com/WICG/app-history/issues?state=open">open issues</a>)
!Commits: <a href="https://github.com/WICG/app-history/commits/main/spec.bs">GitHub spec.bs commits</a>
Complain About: accidental-2119 yes, missing-example-ids yes
Indent: 2
Default Biblio Status: current
Markup Shorthands: markdown yes
Assume Explicit For: yes
</pre>

<pre class="link-defaults">
spec: html; type: element; text: a
</pre>
<pre class="anchors">
spec: html; urlPrefix: https://html.spec.whatwg.org/multipage/
  type: dfn
    text: serialized state; url: history.html#serialized-state
    text: session history; url: history.html#session-history
    text: session history entry; url: history.html#session-history-entry
    for: URL and history update steps
      text: serializedData; url: history.html#uhus-serializeddata
      text: isPush; url: history.html#uhus-ispush
    for: session history
      text: current entry; url: history.html#current-entry
    for: session history entry
      text: document; url: history.html#she-document
      text: URL; url: history.html#she-url
    for: history handling behavior
      text: default; url: browsing-the-web.html#hh-default
      text: reload; url: browsing-the-web.html#hh-reload
      text: replace; url: browsing-the-web.html#hh-replace
      text: entry update; url: browsing-the-web.html#hh-entry-update
    for: navigate
      text: historyHandling; url: browsing-the-web.html#navigation-hh
      text: navigationType; url: browsing-the-web.html#navigation-navigationtype
      text: exceptionsEnabled; url: browsing-the-web.html#exceptions-enabled
    for: browsing context
      text: discard; url: window-object.html#a-browsing-context-is-discarded
  type: method
    for: Document; text: open(unused1, unused2); url: multipage/dynamic-markup-insertion.html#dom-document-open
spec: html; urlPrefix: https://whatpr.org/html/6315/
  type: dfn
    text: traversable navigable; for: navigable; url: history.html#nav-traversable
    text: current session history entry; for: navigable; url: history.html#nav-current-history-entry
    text: active session history entry; for: navigable; url: history.html#nav-active-history-entry
    text: get the session history entries; for: navigable; url: history.html#getting-session-history-entries
    text: session history traversal queue; for: traversable navigable; url: history.html#tn-session-history-traversal-queue
    text: current session history step; for: traversable navigable; url: history.html#tn-current-session-history-step
    text: get all history steps; for: traversable navigable; url: history.html#getting-all-history-steps
    text: step; for: session history entry; url: history.html#she-step
    text: apply the history step; url: history.html#apply-the-history-step
    text: containing navigable; for: browsing context; url: browsers.html#bc-navigable
    text: active document; for: navigable; url: history.html#nav-document
    text: navigable; url: history.html#navigable
spec: uuid; type: dfn; urlPrefix: https://wicg.github.io/uuid/
  text: generate a random UUID; url: #dfn-generate-a-random-uuid
</pre>

<style>
.selected-text-file-an-issue {
  position: fixed;
  bottom: 0;
  right: 0;
  background: rgba(255, 255, 255, 0.8);
  font-size: smaller;
  padding: 4px 10px;
  z-index: 4;
}

dfn var {
  font-style: italic;
}

table {
  margin: 1em 0;
}

/* WHATWG-style <hr>s, instead of WICG-style. Specific selector is necessary to override WICG styles. */
:not(.head) > :not(.head) + hr {
  display: block;
  background: none;
  border: none;
  padding: 0;
  margin: 3em 0;
  height: auto;
}
:not(.head) > :not(.head) + hr::before {
  content: none;
}

/* domintro from https://resources.whatwg.org/standard.css */
.domintro {
  position: relative;
  color: green;
  background: #DDFFDD;
  margin: 2.5em 0 2em 0;
  padding: 1.5em 1em 0.5em 2em;
}

.domintro dt, .domintro dt * {
  color: black;
  font-size: inherit;
}
.domintro dd {
  margin: 0.5em 0 1em 2em; padding: 0;
}
.domintro dd p {
  margin: 0.5em 0;
}
.domintro::before {
  content: 'For web developers (non-normative)';
  background: green;
  color: white;
  padding: 0.15em 0.25em;
  font-style: normal;
  position: absolute;
  top: -0.8em;
  left: -0.8em;
}
</style>

<script src="https://resources.whatwg.org/file-issue.js" async></script>

<h2 id="global">The {{AppHistory}} class</h2>

<xmp class="idl">
partial interface Window {
  readonly attribute AppHistory appHistory;
};
</xmp>

Each {{Window}} object has an associated <dfn for="Window">app history</dfn>, which is a new {{AppHistory}} instance created alongside the {{Window}}.

The <dfn attribute for="Window">appHistory</dfn> getter steps are to return [=this=]'s [=Window/app history=].

<xmp class="idl">
[Exposed=Window]
interface AppHistory : EventTarget {
  sequence<AppHistoryEntry> entries();
  readonly attribute AppHistoryEntry? current;
  undefined updateCurrent(AppHistoryUpdateCurrentOptions options);
  readonly attribute AppHistoryTransition? transition;

  readonly attribute boolean canGoBack;
  readonly attribute boolean canGoForward;

  AppHistoryResult navigate(USVString url, optional AppHistoryNavigateOptions options = {});
  AppHistoryResult reload(optional AppHistoryReloadOptions options = {});

  AppHistoryResult goTo(DOMString key, optional AppHistoryNavigationOptions options = {});
  AppHistoryResult back(optional AppHistoryNavigationOptions options = {});
  AppHistoryResult forward(optional AppHistoryNavigationOptions options = {});

  attribute EventHandler onnavigate;
  attribute EventHandler onnavigatesuccess;
  attribute EventHandler onnavigateerror;
  attribute EventHandler oncurrentchange;
};

dictionary AppHistoryUpdateCurrentOptions {
  required any state;
};

dictionary AppHistoryNavigationOptions {
  any info;
};

dictionary AppHistoryNavigateOptions : AppHistoryNavigationOptions {
  any state;
  boolean replace = false;
};

dictionary AppHistoryReloadOptions : AppHistoryNavigationOptions {
  any state;
};

dictionary AppHistoryResult {
  Promise<AppHistoryEntry> committed;
  Promise<AppHistoryEntry> finished;
};
</xmp>

Each {{AppHistory}} object has an associated <dfn for="AppHistory">entry list</dfn>, a [=list=] of {{AppHistoryEntry}} objects, initially empty.

Each {{AppHistory}} object has an associated <dfn for="AppHistory">current index</dfn>, an integer, initially &minus;1.

<div algorithm>
  An {{AppHistory}} |appHistory| <dfn for="AppHistory">has entries and events disabled</dfn> if the following steps return true:

  1. Let |browsingContext| be |appHistory|'s [=relevant global object=]'s [=Window/browsing context=].

  1. If |browsingContext| is null, then return true.

  1. If |browsingContext| is <a spec="HTML">still on its initial `about:blank` `Document`</a>, then return true.

  1. If |appHistory|'s [=relevant global object=]'s [=associated Document=]'s [=Document/origin=] is [=opaque origin|opaque=], then return true.

  1. Return false.
</div>

<div algorithm>
  To <dfn for="AppHistory">update the entries</dfn> for an {{AppHistory}} instance |appHistory|:

  1. If |appHistory| [=AppHistory/has entries and events disabled=], then:

    1. Assert: |appHistory|'s [=AppHistory/entry list=] [=list/is empty=].

    1. Return.

  1. Let |sessionHistory| be |appHistory|'s [=relevant global object=]'s [=Window/browsing context=]'s [=session history=].

  1. Let |appHistorySHEs| be a new empty list.

  1. Let |oldCurrentAHE| be the [=AppHistory/current entry=] of |appHistory|.

  1. Let |currentSHE| be |sessionHistory|'s [=session history/current entry=].

  1. Let |backwardIndex| be the index of |currentSHE| within |sessionHistory|, minus 1.

  1. While |backwardIndex| > 0:

    1. Let |she| be |sessionHistory|[|backwardIndex|].

    1. If |she|'s [=session history entry/origin=] is [=same origin=] with |currentSHE|'s [=session history entry/origin=], then [=list/prepend=] |she| to |appHistorySHEs|.

    1. Otherwise, [=iteration/break=].

    1. Set |backwardIndex| to |backwardIndex| &minus; 1.

  1. [=list/Append=] |currentSHE| to |appHistorySHEs|.

  1. Let |forwardIndex| be the index of |currentSHE| within |sessionHistory|, plus 1.

  1. While |forwardIndex| &lt; |sessionHistory|'s [=list/size=]:

    1. Let |she| be |sessionHistory|[|forwardIndex|].

    1. If |she|'s [=session history entry/origin=] is [=same origin=] with |currentSHE|'s [=session history entry/origin=], then [=list/append=] |she| to |appHistorySHEs|.

    1. Otherwise, [=iteration/break=].

    1. Set |forwardIndex| to |forwardIndex| + 1.

  1. Let |newCurrentIndex| be the index of |currentSHE| within |appHistorySHEs|.

  1. Let |newEntryList| be an empty list.

  1. [=list/For each=] |oldAHE| of |appHistory|'s [=AppHistory/entry list=]:

    1. Set |oldAHE|'s [=AppHistoryEntry/index=] to &minus;1.

  1. Let |index| be 0.

  1. Let |disposedAHEs| be a [=list/clone=] of |appHistory|'s [=AppHistory/entry list=].

  1. [=list/For each=] |she| of |appHistorySHEs|:

    1. If |appHistory|'s [=AppHistory/entry list=] [=list/contains=] an {{AppHistoryEntry}} |existingAHE| whose [=AppHistoryEntry/session history entry=] is |she|, then:

      1. [=list/Append=] |existingAHE| to |newEntryList|.

      1. [=list/Remove=] |existingAHE| from |disposedAHEs|.

    1. Otherwise:

      1. Let |newAHE| be a [=new=] {{AppHistoryEntry}} created in the [=relevant realm=] of |appHistory|.

      1. Set |newAHE|'s [=AppHistoryEntry/session history entry=] to |she|.

      1. [=list/Append=] |newAHE| to |newEntryList|.

    1. Set |newEntryList|[|index|]'s [=AppHistoryEntry/index=] to |index|.

    1. Set |index| to |index| + 1.

  1. Set |appHistory|'s [=AppHistory/entry list=] to |newEntryList|.

  1. Set |appHistory|'s [=AppHistory/current index=] to |newCurrentIndex|.

  1. If |oldCurrentAHE| is not null, then [=fire an event=] named {{AppHistory/currentchange}} at |appHistory| using {{AppHistoryCurrentChangeEvent}}, with its {{AppHistoryCurrentChangeEvent/navigationType}} attribute initialized to TODO and its {{AppHistoryCurrentChangeEvent/from}} initialized to |oldCurrentAHE|.

  1. If |appHistory|'s [=AppHistory/ongoing navigation=] is non-null, then [=app history API navigation/notify about the committed-to entry=] given |appHistory|'s [=AppHistory/ongoing navigation=] and the [=AppHistory/current entry=] of |appHistory|.

     <p class="note">It is important to do this before firing the {{AppHistoryEntry/dispose}} events, since event handlers for {{AppHistoryEntry/dispose}} could start another navigation, or otherwise change the value of |appHistory|'s [=AppHistory/ongoing navigation=].

  1. [=list/For each=] |disposedAHE| of |disposedAHEs|:

    1. [=Fire an event=] named {{AppHistoryEntry/dispose}} at |disposedAHE|.
</div>

<div algorithm>
  To <dfn>get the app history index</dfn> of a [=session history entry=] |she| within an {{AppHistory}} |appHistory|:

  1. Let |index| be 0.

  1. [=list/For each=] |ahe| of |appHistory|'s [=AppHistory/entry list=]:

    1. If |ahe|'s [=AppHistoryEntry/session history entry=] is equal to |she|, then return |index|.

    1. Increment |index| by 1.

  1. Assert: this step is never reached.
</div>

<h3 id="entries-api">Introspecting the app history entry list</h3>

<dl class="domintro non-normative">
  <dt><code><var ignore>entries</var> = {{Window/appHistory}}.{{AppHistory/entries()|entries}}()</code>
  <dd>
    <p>Returns an array of {{AppHistoryEntry}} instances representing the current app history list, i.e. all session history entries for this {{Window}} that are [=same origin=] and contiguous to the current session history entry.
  </dd>

  <dt><code>{{Window/appHistory}}.{{AppHistory/canGoBack}}</code>
  <dd>
    <p>Returns true if the current {{AppHistoryEntry}} is not the first one in the app history entries list.
  </dd>

  <dt><code>{{Window/appHistory}}.{{AppHistory/canGoForward}}</code>
  <dd>
    <p>Returns true if the current {{AppHistoryEntry}} is not the last one in the app history entries list.
  </dd>
</dl>

<div algorithm>
  The <dfn method for="AppHistory">entries()</dfn> method steps are:

  1. If [=this=] [=AppHistory/has entries and events disabled=], then return the empty list.

  1. Return [=this=]'s [=AppHistory/entries list=].
</div>

<div algorithm>
  The <dfn attribute for="AppHistory">canGoBack</dfn> getter steps are:

  1. If [=this=] [=AppHistory/has entries and events disabled=], then return false.

  1. Assert: [=this=]'s [=AppHistory/current index=] is not &minus;1.

  1. If [=this=]'s [=AppHistory/current index=] is 0, then return false.

  1. Return true.
</div>

<div algorithm>
  The <dfn attribute for="AppHistory">canGoForward</dfn> getter steps are:

  1. If [=this=] [=AppHistory/has entries and events disabled=], then return false.

  1. Assert: [=this=]'s [=AppHistory/current index=] is not &minus;1.

  1. If [=this=]'s [=AppHistory/current index=] is equal to [=this=]'s [=AppHistory/entry list=]'s [=list/size=] &minus; 1, then return false.

  1. Return true.
</div>

<h3 id="current-entry">The current entry</h3>

<xmp class="idl">
[Exposed=Window]
interface AppHistoryCurrentChangeEvent : Event {
  constructor(DOMString type, AppHistoryCurrentChangeEventInit eventInit);

  readonly attribute AppHistoryNavigationType? navigationType;
  readonly attribute AppHistoryEntry from;
};

dictionary AppHistoryCurrentChangeEventInit : EventInit {
  AppHistoryNavigationType? navigationType = null;
  required AppHistoryEntry destination;
};
</xmp>

<dl class="domintro non-normative">
  <dt><code>{{Window/appHistory}}.{{AppHistory/current}}</code>
  <dd>
    <p>The current {{AppHistoryEntry}}.
  </dd>

  <dt><code>{{Window/appHistory}}.{{AppHistory/updateCurrent()|updateCurrent}}({ {{AppHistoryUpdateCurrentOptions/state}} })</code>
  <dd>
    <p>Update the [=session history entry/app history state=] of the current {{AppHistoryEntry}}, without performing a navigation like {{AppHistory/reload()|appHistory.reload()}} would do.

    <p>This method is best used to capture updates to the page that have already happened, and need to be reflected into the app history state. For cases where the state update is meant to drive a page update, instead use {{AppHistory/navigate()|appHistory.navigate()}} or {{AppHistory/reload()|appHistory.reload()}}.
  </dd>
</dl>

<div algorithm>
  The <dfn for="AppHistory">current entry</dfn> for an {{AppHistory}} |appHistory| is the result running of the following algorithm:

  1. If [=this=] [=AppHistory/has entries and events disabled=], then return null.

  1. Assert: [=this=]'s [=AppHistory/current index=] is not &minus;1.

  1. Return |appHistory|'s [=AppHistory/entry list=][|appHistory|'s [=AppHistory/current index=]].
</div>

<p algorithm>
  The <dfn attribute for="AppHistory">current</dfn> getter steps are to return the [=AppHistory/current entry=] for [=this=].
</p>

<div algorithm>
  The <dfn method for="AppHistory">updateCurrent(|options|)</dfn> method steps are:

  1. Let |current| be the [=AppHistory/current entry=] for [=this=].

  1. If |current| is null, then throw an "{{InvalidStateError}}" {{DOMException}}.

  1. Let |serializedState| be [$StructuredSerializeForStorage$](|options|["{{AppHistoryUpdateCurrentOptions/state}}"]), rethrowing any exceptions.

  1. Set |current|'s [=AppHistoryEntry/session history entry=]'s [=session history entry/app history state=] to |serializedState|.

  1. [=Fire an event=] named {{AppHistory/currentchange}} at [=this=] using {{AppHistoryCurrentChangeEvent}}, with its {{AppHistoryCurrentChangeEvent/navigationType}} attribute initialized to null and its {{AppHistoryCurrentChangeEvent/from}} initialized to |current|.
</div>

<h3 id="ongoing-state">Ongoing navigation tracking</h3>

<xmp class="idl">
[Exposed=Window]
interface AppHistoryTransition {
  readonly attribute AppHistoryNavigationType navigationType;
  readonly attribute AppHistoryEntry from;
  readonly attribute Promise<undefined> finished;

  AppHistoryResult rollback(optional AppHistoryNavigationOptions options = {});
};
</xmp>

<dl class="domintro">
  <dt><code>{{Window/appHistory}}.{{AppHistory/transition}}</code>
  <dd>
    <p>An {{AppHistoryTransition}} object representing any ongoing navigation that hasn't yet reached the {{AppHistory/navigatesuccess}} or {{AppHistory/navigateerror}} stage, if one exists, or null if there is no such transition ongoing.

    <p>Since {{AppHistory/current|appHistory.current}} (and other properties like {{Location/href|location.href}}) are updated immediately upon navigation, this {{AppHistory/transition|appHistory.transition}} property is useful for determining when such navigations are not yet fully settled, according to any promises passed to {{AppHistoryNavigateEvent/transitionWhile()|event.transitionWhile()}}.
  </dd>

  <dt><code>{{Window/appHistory}}.{{AppHistory/transition}}.{{AppHistoryTransition/navigationType}}</code></dt>
  <dd>
    <p>One of "{{AppHistoryNavigationType/reload}}", "{{AppHistoryNavigationType/push}}", "{{AppHistoryNavigationType/replace}}", or "{{AppHistoryNavigationType/traverse}}", indicating what type of navigation this transition is for.
  </dd>

  <dt><code>{{Window/appHistory}}.{{AppHistory/transition}}.{{AppHistoryTransition/from}}</code></dt>
  <dd>
    <p>The {{AppHistoryEntry}} from which the transition is coming. This can be useful to compare against {{AppHistory/current|appHistory.current}}.
  </dd>

  <dt><code>{{Window/appHistory}}.{{AppHistory/transition}}.{{AppHistoryTransition/finished}}</code></dt>
  <dd>
    <p>A promise which fulfills at the same time the {{AppHistory/navigatesuccess}} event fires, or rejects at the same time the {{AppHistory/navigateerror}} fires.
  </dd>

  <dt><code>{ {{AppHistoryResult/committed}}, {{AppHistoryResult/finished}} } = {{Window/appHistory}}.{{AppHistory/transition}}.{{AppHistoryTransition/rollback(options)|rollback}}()</code></dt>
  <dt><code>{ {{AppHistoryResult/committed}}, {{AppHistoryResult/finished}} } = {{Window/appHistory}}.{{AppHistory/transition}}.{{AppHistoryTransition/rollback(options)|rollback}}({ {{AppHistoryNavigationOptions/info}} })</code></dt>
  <dd>
    <p>Aborts the ongoing navigation, and immediately performs another navigation which is the logical opposite of the one represented by this transition:

    * If {{AppHistoryTransition/navigationType}} is "{{AppHistoryNavigationType/reload}}", it will perform a replace navigation that resets the app history state to that found in the {{AppHistoryEntry}} stored in {{AppHistoryTransition/from}}.

    * If {{AppHistoryTransition/navigationType}} is "{{AppHistoryNavigationType/push}}", it will traverse to the {{AppHistoryEntry}} stored in {{AppHistoryTransition/from}}, and then delete the previously-current {{AppHistoryEntry}} from the app history list, so that it cannot be reached with {{AppHistory/forward()|appHistory.forward()}} or the forward button.

    * If {{AppHistoryTransition/navigationType}} is "{{AppHistoryNavigationType/replace}}", it will perform another replace navigation that resets the URL and app history state to those found in the {{AppHistoryEntry}} stored in {{AppHistoryTransition/from}}.

    * If {{AppHistoryTransition/navigationType}} is "{{AppHistoryNavigationType/traverse}}", it will traverse to the {{AppHistoryEntry}} stored in {{AppHistoryTransition/from}}. (This could involve going either forward or backward in the app history list.)

    <p>Aborting the ongoing navigation will cause {{AppHistory/navigateerror}} to fire, any {{AppHistoryNavigateEvent/signal|navigateEvent.signal}} instances to fire {{AbortSignal/abort}}, and any relevant promises to reject. This includes {{AppHistoryTransition/finished|appHistory.transition.finished}}.

    <p>Then, the rollback navigation described above starts. This will fire a {{AppHistory/navigate}} event, and reset {{AppHistory/transition|appHistory.transition}} to a new {{AppHistoryTransition}} instance. The {{AppHistoryNavigationOptions/info}} option, if provided, will populate the {{AppHistoryNavigateEvent/info}} property of the fired event.

    <p>This method can only be called while the transition is still ongoing, i.e. while {{AppHistory/transition|appHistory.transition}} equals this {{AppHistoryTransition}} object. Calling it afterward will cause both returned promises rejected with an "{{InvalidStateError}}" {{DOMException}}.
  </dd>
</dl>

An {{AppHistory}} has a <dfn for="AppHistory">transition</dfn>, which is an {{AppHistoryTransition}} or null.

The <dfn attribute for="AppHistory">transition</dfn> getter steps are to return [=this=]'s [=AppHistory/transition=].

<hr>

An {{AppHistoryTransition}} has an associated <dfn for="AppHistoryTransition">navigation type</dfn>, which is an {{AppHistoryNavigationType}}.

An {{AppHistoryTransition}} has an associated <dfn for="AppHistoryTransition">from entry</dfn>, which is an {{AppHistoryEntry}}.

An {{AppHistoryTransition}} has an associated <dfn for="AppHistoryTransition">finished promise</dfn>, which is an {{Promise}}.

The <dfn attribute for="AppHistoryTransition">navigationType</dfn> getter steps are to return [=this=]'s [=AppHistoryTransition/navigation type=].

The <dfn attribute for="AppHistoryTransition">from</dfn> getter steps are to return [=this=]'s [=AppHistoryTransition/from entry=].

The <dfn attribute for="AppHistoryTransition">finished</dfn> getter steps are to return [=this=]'s [=AppHistoryTransition/finished promise=].

<div algorithm>
  The <dfn method for="AppHistoryTransition">rollback(|options|)</dfn> method steps are:

  1. TODO use |options|.
</div>

<hr>

During any given navigation, the {{AppHistory}} object needs to keep track of the following:

<table class="data">
  <caption>For all navigations
  <thead>
    <tr>
      <th>State
      <th>Duration
      <th>Explanation
  <tbody>
    <tr>
      <td>The {{AppHistoryNavigateEvent}}
      <td>For the duration of event firing
      <td>So that if the navigation is canceled while the event is firing, we can [=Event/canceled flag|cancel=] the event.
    <tr>
      <td>The event's {{AppHistoryNavigateEvent/signal}}
      <td>Until all promises passed to {{AppHistoryNavigateEvent/transitionWhile()}} have settled
      <td>So that if the navigation is canceled, we can [=AbortSignal/signal abort=].
    <tr>
      <td>The {{AppHistoryEntry}} being navigated to
      <td>From when it is determined, until all promises passed to {{AppHistoryNavigateEvent/transitionWhile()}} have settled
      <td>So that we know what to [=resolve=] any {{AppHistoryResult/committed}} and {{AppHistoryResult/finished}} promises with.
    <tr>
      <td>Any {{AppHistoryResult/finished}} {{Promise}} that was returned
      <td>Until all promises passed to {{AppHistoryNavigateEvent/transitionWhile()}} have settled
      <td>So that we can [=resolve=] or [=reject=] it appropriately.
</table>

<table class="data">
  <caption>For non-"{{AppHistoryNavigationType/traverse}}" navigations
  <thead>
    <tr>
      <th>State
      <th>Duration
      <th>Explanation
  <tbody>
    <tr>
      <td>Any {{AppHistoryNavigateOptions/state}}
      <td>For the duration of event firing
      <td>So that we can update the current entry's state after the event successfully finishes firing without being canceled.
</table>

<table class="data">
  <caption>For "{{AppHistoryNavigationType/traverse}}" navigations
  <thead>
    <tr>
      <th>State
      <th>Duration
      <th>Explanation
  <tbody>
    <tr>
      <td>Any {{AppHistoryNavigationOptions/info}}
      <td>Until the task is queued to fire the {{AppHistory/navigate}} event
      <td>So that we can use it to fire the {{AppHistory/navigate}} event after the the trip through the [=traversable navigable/session history traversal queue=].
    <tr>
      <td>Any {{AppHistoryResult/committed}} {{Promise}} that was returned
      <td>Until the [=session history=] is updated (inside that same task)
      <td>So that we can [=resolve=] or [=reject=] it appropriately.
</table>

Furthermore, we need to account for the fact that there might be multiple traversals queued up, e.g. via

<xmp highlight="js">
const key1 = appHistory.entries()[appHistory.current.index - 1].key;
const key2 = appHistory.entries()[appHistory.current.index + 1].key;

appHistory.goTo(key1); // intentionally no await
appHistory.goTo(key2);
</xmp>

And, while non-traversal navigations cannot be queued in the same way since a new non-traversal navigation cancels an old one, we need to keep some state around so that we can properly cancel the old one. That is, given

<xmp highlight="js">
const p1 = appHistory.navigate(url1).finished;
const p2 = appHistory.navigate(url2).finished;
</xmp>

we need to ensure that when navigating to `url2`, we still have the {{Promise}} `p1` around so that we can reject it. We can't just get rid of any ongoing navigation promises the moment the second call to {{AppHistory/navigate()}} happens.

We also need to ensure that, if we start a new navigation, navigations which have gotten as far as firing {{AppHistory/navigate}} events, but not yet as far as firing {{AppHistory/navigatesuccess}} or {{AppHistory/navigateerror}}, get [=finalized with an aborted navigation error=].

We end up accomplishing all this using the following setup:

Each {{AppHistory}} object has an associated <dfn for="AppHistory">ongoing navigate event</dfn>, an {{AppHistoryNavigateEvent}} or null, initially null.

Each {{AppHistory}} object has an associated <dfn for="AppHistory">ongoing navigation signal</dfn>, which is an {{AbortSignal}} or null, initially null.

Each {{AppHistory}} object has an associated <dfn for="AppHistory">ongoing navigation</dfn>, which is an [=app history API navigation=] or null, initially null.

Each {{AppHistory}} object has an associated <dfn for="AppHistory">upcoming non-traverse navigation</dfn>, which is an [=app history API navigation=] or null, initially null.

Each {{AppHistory}} object has an associated <dfn for="AppHistory">upcoming traverse navigations</dfn>, which is a [=map=] from strings to [=app history API navigations=], initially empty.

An <dfn>app history API navigation</dfn> is a [=struct=] with the following [=struct/items=]:

* An <dfn for="app history API navigation">app history</dfn>, an {{AppHistory}}
* A <dfn for="app history API navigation">key</dfn>, a string or null
* An <dfn for="app history API navigation">info</dfn>, a JavaScript value
* An <dfn for="app history API navigation">serialized state</dfn>, a [=serialized state=] or null
* A <dfn for="app history API navigation">committed-to entry</dfn>, an {{AppHistoryEntry}} or null
* A <dfn for="app history API navigation">committed promise</dfn>, a {{Promise}}
* A <dfn for="app history API navigation">finished promise</dfn>, a {{Promise}}
* A <dfn for="app history API navigation">did finish before commit</dfn>, a boolean

<p class="note">We need to store the [=AppHistory/ongoing navigation signal=] separately from the [=app history API navigation=] struct, since it needs to be tracked even for navigations that are not via the app history APIs.

<div algorithm>
  To <dfn for="AppHistory">set the upcoming non-traverse navigation</dfn> given an {{AppHistory}} |appHistory|, a JavaScript value |info|, and a [=serialized state=]-or-null |serializedState|:

  1. Let |committedPromise| and |finishedPromise| be [=a new promise|new promises=] created in |appHistory|'s [=relevant Realm=].

  1. Let |ongoingNavigation| be an [=app history API navigation=] whose [=app history API navigation/app history=] is |appHistory|, [=app history API navigation/key=] is null, [=app history API navigation/info=] is |info|, [=app history API navigation/serialized state=] is |serializedState|, [=app history API navigation/committed-to entry=] is null, [=app history API navigation/committed promise=] is |committedPromise|, [=app history API navigation/finished promise=] is |finishedPromise|, and [=app history API navigation/did finish before commit=] is false.

  1. Assert: |appHistory|'s [=AppHistory/upcoming non-traverse navigation=] is null.

  1. Set |appHistory|'s [=AppHistory/upcoming non-traverse navigation=] to |ongoingNavigation|.

  1. Return |ongoingNavigation|.
</div>

<div algorithm>
  To <dfn for="AppHistory">set an upcoming traverse navigation</dfn> given an {{AppHistory}} |appHistory|, a string |key|, and a JavaScript value |info|:

  1. Let |committedPromise| and |finishedPromise| be [=a new promise|new promises=] created in |appHistory|'s [=relevant Realm=].

  1. Let |traversal| be an [=app history API navigation=] whose whose [=app history API navigation/app history=] is |appHistory|, [=app history API navigation/key=] is |key|, [=app history API navigation/info=] is |info|, [=app history API navigation/serialized state=] is null, [=app history API navigation/committed-to entry=] is null, [=app history API navigation/committed promise=] is |committedPromise|, [=app history API navigation/finished promise=] is |finishedPromise|, and [=app history API navigation/did finish before commit=] is false.

  1. Set |appHistory|'s [=AppHistory/upcoming traverse navigations=][|key|]  to |traversal|.

  1. Return |traversal|.
</div>

<div algorithm>
  To <dfn for="AppHistory">promote the upcoming navigation to ongoing</dfn> given an {{AppHistory}} |appHistory| and a string-or-null |destinationKey|:

  1. Assert: |appHistory|'s [=AppHistory/ongoing navigation=] is null.

  1. If |destinationKey| is not null, then:

    1. Assert: |appHistory|'s [=AppHistory/upcoming non-traverse navigation=] is null.

    1. If |appHistory|'s [=AppHistory/upcoming traverse navigations=][|destinationKey|] [=map/exists=], then:

      1. Set |appHistory|'s [=AppHistory/ongoing navigation=] to |appHistory|'s [=AppHistory/upcoming traverse navigations=][|destinationKey|].

      1. [=map/Remove=] |appHistory|'s [=AppHistory/upcoming traverse navigations=][|destinationKey|].

  1. Otherwise,

    1. Set |appHistory|'s [=AppHistory/ongoing navigation=] to |appHistory|'s [=AppHistory/upcoming non-traverse navigation=].

    1. Set |appHistory|'s [=AppHistory/upcoming non-traverse navigation=] to null.
</div>

<div algorithm>
  To <dfn for="app history API navigation">clean up</dfn> an [=app history API navigation=] |navigation|:

  1. Let |appHistory| be |navigation|'s [=app history API navigation/app history=].

  1. If |appHistory|'s [=AppHistory/ongoing navigation=] is |navigation|, then set |appHistory|'s [=AppHistory/ongoing navigation=] to null.

  1. Otherwise,

    1. Assert: |navigation|'s [=app history API navigation/key=] is not null.

    1. Assert: |appHistory|'s [=AppHistory/upcoming traverse navigations=][|navigation|'s [=app history API navigation/key=]] [=map/exists=].

    1. [=map/Remove=] |appHistory|'s [=AppHistory/upcoming traverse navigations=][|navigation|'s [=app history API navigation/key=]].
</div>

<div algorithm>
  To <dfn for="app history API navigation">notify about the committed-to entry</dfn> given an [=app history API navigation=] |navigation| and an {{AppHistoryEntry}} |entry|:

  1. Set |navigation|'s [=app history API navigation/committed-to entry=] to |entry|.

  1. [=Resolve=] |navigation|'s [=app history API navigation/committed promise=] with |entry|.

     <p class="note">After this point, |navigation|'s [=app history API navigation/committed promise=] is only needed in cases where it has not yet been returned to author code. Implementations might want to clear it out to avoid keeping it alive for the lifetime of the [=app history API navigation=].

  1. If |navigation|'s [=app history API navigation/did finish before commit=] is true, then [=app history API navigation/resolve the finished promise=] for |navigation|.
</div>

<div algorithm>
  To <dfn for="app history API navigation">resolve the finished promise</dfn> for an [=app history API navigation=] |navigation|:

  1. If |navigation|'s [=app history API navigation/finished promise=] is null, then return.

  1. If |navigation|'s [=app history API navigation/committed-to entry=] entry is null, then:

    1. Set |navigation|'s [=app history API navigation/did finish before commit=] to true.

    1. Return.

    <p class="note">In same-document traversal cases, [=app history API navigation/resolve the finished promise=] can be called before [=app history API navigation/notify about the committed-to entry=], since the latter requires a roundtrip through the relevant [=traversable navigable/session history traversal queue=] and the former just depends on the settlement of promises passed to {{AppHistoryNavigateEvent/transitionWhile()}}.

  1. [=Resolve=] |navigation|'s [=app history API navigation/finished promise=] with its [=app history API navigation/committed-to entry=].

  1. [=app history API navigation/Clean up=] |navigation|.
</div>

<div algorithm>
  To <dfn for="app history API navigation">reject the finished promise</dfn> for an [=app history API navigation=] |navigation| with a JavaScript value |exception|:

  1. If |navigation|'s [=app history API navigation/finished promise=] is null, then return.

  1. [=Reject=] |navigation|'s [=app history API navigation/finished promise=] with |exception|.

  1. If |navigation|'s [=app history API navigation/committed promise=] is not null, then [=reject=] |navigation|'s [=app history API navigation/committed promise=] with |exception|.

  1. [=app history API navigation/Clean up=] |navigation|.
</div>

<h3 id="global-navigate">Navigating</h3>

<dl class="domintro non-normative">
  <dt><code>{ {{AppHistoryResult/committed}}, {{AppHistoryResult/finished}} } = {{Window/appHistory}}.{{AppHistory/navigate(url, options)|navigate}}(<var ignore>url</var>)</code>
  <dt><code>{ {{AppHistoryResult/committed}}, {{AppHistoryResult/finished}} } = {{Window/appHistory}}.{{AppHistory/navigate(url, options)|navigate}}(<var ignore>url</var>, <var ignore>options</var>)</code>
  <dd>
    <p>Navigates the current page to the given <var ignore>url</var>. <var ignore>options</var> can contain the following values:

    * {{AppHistoryNavigateOptions/replace}} can be set to true to replace the current session history entry, instead of pushing a new one.
    * {{AppHistoryNavigationOptions/info}} can be set to any value; it will populate the {{AppHistoryNavigateEvent/info}} property of the corresponding {{AppHistory/navigate}} event.
    * {{AppHistoryNavigateOptions/state}} can be set to any [=serializable object|serializable=] value; it will populate the state retrieved by {{AppHistoryEntry/getState()|appHistory.current.getState()}} once the navigation completes, for same-document navigations. (It will be ignored for navigations that end up cross-document.)

    <p>By default this will perform a full navigation (i.e., a cross-document navigation, unless the given URL differs only in a fragment from the current one). The {{AppHistory/navigate}} event's {{AppHistoryNavigateEvent/transitionWhile()}} method can be used to convert it into a same-document navigation.

    <p>The returned promises will behave as follows:

    * For navigations that get aborted, both promises will reject with an "{{AbortError}}" {{DOMException}}.
    * For same-document navigations created by using the {{AppHistory/navigate}} event's {{AppHistoryNavigateEvent/transitionWhile()}} method, {{AppHistoryResult/committed}} will fulfill immediately, and {{AppHistoryResult/finished}} will fulfill or reject according to the promises passed to {{AppHistoryNavigateEvent/transitionWhile()}}.
    * For other same-document navigations (e.g., non-intercepted <a spec="HTML" lt="navigate to a fragment">fragment navigations</a>), both promises will fulfill immediately.
    * For cross-document navigations, both promises will never settle.

    <p>In all cases, when the returned promises fulfill, it will be with the {{AppHistoryEntry}} that was navigated to.
  </dd>

  <dt><code>{ {{AppHistoryResult/committed}}, {{AppHistoryResult/finished}} } = {{Window/appHistory}}.{{AppHistory/reload(options)|reload}}(<var ignore>options</var>)</code>
  <dd>
    <p>Reloads the current page. The {{AppHistoryNavigationOptions/info}} and {{AppHistoryReloadOptions/state}} options behave as described above.

    <p>The default behavior of performing a from-network-or-cache reload of the current page can be overriden by using the {{AppHistory/navigate}} event's {{AppHistoryNavigateEvent/transitionWhile()}} method. Doing so will mean this call only updates state or passes along the appropriate {{AppHistoryNavigationOptions/info}}, plus performing whatever actions the {{AppHistory/navigate}} event handler sees fit to carry out.

    <p>The returned promises will behave as follows:

    * If the reload is aborted, both promises will reject with an "{{AbortError}}" {{DOMException}}.
    * If the reload is intercepted by using the {{AppHistory/navigate}} event's {{AppHistoryNavigateEvent/transitionWhile()}} method, {{AppHistoryResult/committed}} will fulfill immediately, and {{AppHistoryResult/finished}} will fulfill or reject according to the promises passed to {{AppHistoryNavigateEvent/transitionWhile()}}.
    * Otherwise, both promises will never settle.
  </dd>
</dl>

<!-- The following algorithms have several steps that would benefit from https://github.com/heycam/webidl/issues/983. -->

<div algorithm>
  The <dfn method for="AppHistory">navigate(|url|, |options|)</dfn> method steps are:

  1. <a spec="HTML" lt="parse a URL">Parse</a> |url| relative to [=this=]'s [=relevant settings object=]. If that returns failure, then return [=an early error result=] for a "{{SyntaxError}}" {{DOMException}}. Otherwise, let |urlRecord| be the <a spec="HTML">resulting URL record</a>.

  1. If [=this=]'s [=relevant global object=]'s [=associated Document=] is not [=Document/fully active=], then return [=an early error result=] for an "{{InvalidStateError}}" {{DOMException}}.

  1. If [=this=]'s [=relevant global object=]'s [=associated Document=]'s <a spec="HTML">unload counter</a> is greater than 0, then return [=an early error result=] for an "{{InvalidStateError}}" {{DOMException}}.

  1. Let |serializedState| be null.

  1. If |options|["{{AppHistoryNavigateOptions/state}}"] [=map/exists=], then set |serializedState| to [$StructuredSerializeForStorage$](|options|["{{AppHistoryNavigateOptions/state}}"]). If this throws an exception, then return [=an early error result=] for that exception.

  1. Let |info| be |options|["{{AppHistoryNavigationOptions/info}}"] if it exists; otherwise, undefined.

  1. Let |historyHandling| be "<a for="history handling behavior">`replace`</a>" if |options|["{{AppHistoryNavigateOptions/replace}}"] is true; otherwise, "<a for="history handling behavior">`default`</a>".

  1. Return the result of [=performing a non-traverse app history navigation=] given [=this=], |urlRecord|, |serializedState|, |info|, and |historyHandling|.
</div>

<div algorithm>
  The <dfn method for="AppHistory">reload(|options|)</dfn> method steps are:

  1. If [=this=]'s [=relevant global object=]'s [=associated Document=] is not [=Document/fully active=], then return [=an early error result=] for an "{{InvalidStateError}}" {{DOMException}}.

  1. If [=this=]'s [=relevant global object=]'s [=associated Document=]'s <a spec="HTML">unload counter</a> is greater than 0, then return [=an early error result=] for an "{{InvalidStateError}}" {{DOMException}}.

  1. Let |urlRecord| be [=this=]'s [=relevant global object=]'s [=active document=]'s [=Document/URL=].

  1. Let |serializedState| be null.

  1. If |options|["{{AppHistoryReloadOptions/state}}"] [=map/exists=], then set |serializedState| to [$StructuredSerializeForStorage$](|options|["{{AppHistoryReloadOptions/state}}"]). If this throws an exception, then return [=an early error result=] for that exception.

  1. Otherwise,

    1. Let |current| be the [=AppHistory/current entry=] of [=this=].

    1. If |current| is not null, then set |serializedState| to |current|'s [=session history entry/app history state=].

  1. Let |info| be |options|["{{AppHistoryNavigationOptions/info}}"] if it exists; otherwise, undefined.

  1. Return the result of [=performing a non-traverse app history navigation=] given [=this=], |urlRecord|, |serializedState|, |info|, and "<a for="history handling behavior">`reload`</a>".
</div>

<div algorithm>
  To <dfn>perform a non-traverse app history navigation</dfn> given an {{AppHistory}} object |appHistory|, a [=URL=] |url|, a [=serialized state=]-or-null |serializedState|, a JavaScript value |info|, and a <a spec="HTML">history handling behavior</a> |historyHandling|:

  1. Let |browsingContext| be |appHistory|'s [=relevant global object=]'s [=Window/browsing context=].

  1. [=Assert=]: |browsingContext| is not null.

  1. Assert: |historyHandling| is either "<a for="history handling behavior">`replace`</a>", "<a for="history handling behavior">`reload`</a>", or "<a for="history handling behavior">`default`</a>".

  1. Let |ongoingNavigation| be the result of [=AppHistory/setting the upcoming non-traverse navigation=] for |appHistory| given |info| and |serializedState|.

  1. <a spec="HTML">Navigate</a> |browsingContext| to |url| with <i>[=navigate/historyHandling=]</i> set to |historyHandling|, <i>[=navigate/appHistoryState=]</i> set to |serializedState|, and the <a spec="HTML">source browsing context</a> set to |browsingContext|.

  1. If |appHistory|'s [=AppHistory/upcoming non-traverse navigation=] is |ongoingNavigation|, then:

    <p class="note">This means the <a spec="HTML">navigate</a> algorithm bailed out before ever getting to the [=inner navigate event firing algorithm=] which would [=AppHistory/promote the upcoming navigation to ongoing=].

    1. Set |appHistory|'s [=AppHistory/upcoming non-traverse navigation=] to null.

    1. Return [=an early error result=] for an "{{AbortError}}" {{DOMException}}.

  1. If |ongoingNavigation|'s [=app history API navigation/serialized state=] is non-null, then set |browsingContext|'s [=session history=]'s [=session history/current entry=]'s [=session history entry/app history state=] to |ongoingNavigation|'s [=app history API navigation/serialized state=].

     <p class="note">At this point |ongoingNavigation|'s [=app history API navigation/serialized state=] is no longer needed and can be nulled out instead of keeping it alive for the lifetime of the [=app history API navigation=].

  1. Return «[ "{{AppHistoryResult/committed}}" → |ongoingNavigation|'s [=app history API navigation/committed promise=], "{{AppHistoryResult/finished}}" → |ongoingNavigation|'s [=app history API navigation/finished promise=] ]».
</div>

<p class="note">Unlike {{Location/assign()|location.assign()}} and friends, which are exposed across [=same origin-domain|origin-domain=] boundaries, {{AppHistory/navigate()|appHistory.navigate()}} and {{AppHistory/reload()|appHistory.reload()}} can only be accessed by code with direct synchronous access to the {{Window/appHistory}} property. Thus, we avoid the complications around tracking <a spec="HTML">source browsing contexts</a>, and we don't need to deal with the <a spec="HTML">allowed to navigate</a> check and its accompanying <i>[=navigate/exceptionsEnabled=]</i> flag. We just treat all navigations as being initiated by the {{AppHistory}} object itself.

<p algorithm>
  An <dfn>an early error result</dfn> for an exception |e| is a dictionary instance given by  «[ "{{AppHistoryResult/committed}}" → [=a promise rejected with=] |e|, "{{AppHistoryResult/finished}}" → [=a promise rejected with=] |e| ]».
</p>

<h3 id="global-traversing">Traversing</h3>

<dl class="domintro non-normative">
  <dt><code>{ {{AppHistoryResult/committed}}, {{AppHistoryResult/finished}} } =  {{Window/appHistory}}.{{AppHistory/goTo(key)|goTo}}(<var ignore>key</var>)</code>
  <dt><code>{ {{AppHistoryResult/committed}}, {{AppHistoryResult/finished}} } =  {{Window/appHistory}}.{{AppHistory/goTo(key, options)|goTo}}(<var ignore>key</var>, { {{AppHistoryNavigationOptions/info}} })</code>
  <dd>
    <p>Traverses the <a spec=HTML>joint session history</a> to the closest joint session history entry that matches the {{AppHistoryEntry}} with the given key. {{AppHistoryNavigationOptions/info}} can be set to any value; it will populate the {{AppHistoryNavigateEvent/info}} property of the corresponding {{AppHistory/navigate}} event.

    <p>If a traversal to that <a spec=HTML>joint session history</a> is already in progress, then this will return the promises for that original traversal, and {{AppHistoryNavigationOptions/info}} will be ignored.

    <p>The returned promises will behave as follows:

    * If there is no {{AppHistoryEntry}} in {{AppHistory/entries|appHistory.entries}} with the given key, both will reject with an "{{InvalidStateError}}" {{DOMException}}.
    * For same-document traversals intercepted by the {{AppHistory/navigate}} event's {{AppHistoryNavigateEvent/transitionWhile()}} method, {{AppHistoryResult/committed}} will fulfill as soon as the traversal is processed and {{AppHistory/current|appHistory.current}} is updated, and {{AppHistoryResult/finished}} will fulfill or reject according to the promises passed to {{AppHistoryNavigateEvent/transitionWhile()}}.
    * For non-intercepted same-document traversals, both promises will fulfill as soon as the traversal is processed and {{AppHistory/current|appHistory.current}} is updated
    * For cross-document traversals, both promises will never settle.
  </dd>

  <dt><code>{ {{AppHistoryResult/committed}}, {{AppHistoryResult/finished}} } =  {{Window/appHistory}}.{{AppHistory/back()|back}}()</code>
  <dt><code>{ {{AppHistoryResult/committed}}, {{AppHistoryResult/finished}} } =  {{Window/appHistory}}.{{AppHistory/back(options)|back}}({ {{AppHistoryNavigationOptions/info}} })</code>
  <dd>
    <p>Traverse the <a spec=HTML>joint session history</a> to the closest previous joint session history entry which results in this frame navigating, i.e. results in {{AppHistory/current|appHistory.current}} updating. {{AppHistoryNavigationOptions/info}} can be set to any value; it will populate the {{AppHistoryNavigateEvent/info}} property of the corresponding {{AppHistory/navigate}} event.

    <p>If a traversal to that <a spec=HTML>joint session history</a> is already in progress, then this will return the promises for that original traversal, and {{AppHistoryNavigationOptions/info}} will be ignored.

    <p>The returned promises behave equivalently to those returned by {{AppHistory/goTo()}}.
  </dd>

  <dt><code>{ {{AppHistoryResult/committed}}, {{AppHistoryResult/finished}} } =  {{Window/appHistory}}.{{AppHistory/forward()|forward}}()</code>
  <dt><code>{ {{AppHistoryResult/committed}}, {{AppHistoryResult/finished}} } =  {{Window/appHistory}}.{{AppHistory/forward(options)|forward}}({ {{AppHistoryNavigationOptions/info}} })</code>
  <dd>
    <p>Traverse the <a spec=HTML>joint session history</a> to the closest forward joint session history entry which results in this frame navigating, i.e. results in {{AppHistory/current|appHistory.current}} updating. {{AppHistoryNavigationOptions/info}} can be set to any value; it will populate the {{AppHistoryNavigateEvent/info}} property of the corresponding {{AppHistory/navigate}} event.

    <p>If a traversal to that <a spec=HTML>joint session history</a> is already in progress, then this will return the promises for that original traversal, and {{AppHistoryNavigationOptions/info}} will be ignored.

    <p>The returned promises behave equivalently to those returned by {{AppHistory/goTo()}}.
  </dd>
</dl>

<div algorithm>
  The <dfn method for="AppHistory">goTo(|key|, |options|)</dfn> method steps are:

  1. If [=this=]'s [=AppHistory/current index=] is &minus;1, then return [=an early error result=] for an "{{InvalidStateError}}" {{DOMException}}.

  1. If [=this=]'s [=AppHistory/entry list=] does not contain any {{AppHistoryEntry}} whose [=AppHistoryEntry/session history entry=]'s [=session history entry/app history key=] equals |key|, then return [=an early error result=] for an "{{InvalidStateError}}" {{DOMException}}.

  1. Return the result of [=performing an app history traversal=] given [=this=], |key|, and |options|.
</div>

<div algorithm>
  The <dfn method for="AppHistory">back(|options|)</dfn> method steps are:

  1. If [=this=]'s [=AppHistory/current index=] is &minus;1 or 0, then return [=an early error result=] for an "{{InvalidStateError}}" {{DOMException}}.

  1. Let |key| be [=this=]'s [=AppHistory/entry list=][[=this=]'s [=AppHistory/current index=] &minus; 1]'s [=AppHistoryEntry/session history entry=]'s [=session history entry/app history key=].

  1. Return the result of [=performing an app history traversal=] given [=this=], |key|, and |options|.
</div>

<div algorithm>
  The <dfn method for="AppHistory">forward(|options|)</dfn> method steps are:

  1. If [=this=]'s [=AppHistory/current index=] is &minus;1 or is equal to [=this=]'s [=AppHistory/entry list=]'s [=list/size=] &minus; 1, then return [=an early error result=] for an "{{InvalidStateError}}" {{DOMException}}.

  1. Let |key| be [=this=]'s [=AppHistory/entry list=][[=this=]'s [=AppHistory/current index=] + 1]'s [=AppHistoryEntry/session history entry=]'s [=session history entry/app history key=].

  1. Return the result of [=performing an app history traversal=] given [=this=], |key|, and |options|.
</div>

<div algorithm>
  <p class="advisement">The following algorithm is specified in terms of the <a href="https://github.com/whatwg/html/pull/6315">session history rewrite pull request</a> against the HTML Standard, because the existing session history traversal infrastructure is broken enough that it's hard to build on. It is expected to track that work as it continues.</p>

  To <dfn>perform an app history traversal</dfn> given an {{AppHistory}} object |appHistory|, a string |key|, and an {{AppHistoryNavigationOptions}} |options|:

  1. If |appHistory|'s [=relevant global object=]'s [=associated Document=] is not [=Document/fully active=], then return [=an early error result=] for an "{{InvalidStateError}}" {{DOMException}}.

  1. If |appHistory|'s [=relevant global object=]'s [=associated Document=]'s <a spec="HTML">unload counter</a> is greater than 0, then return [=an early error result=] for an "{{InvalidStateError}}" {{DOMException}}.

  1. If |appHistory|'s [=AppHistory/current entry=]'s [=AppHistoryEntry/session history entry=]'s [=session history entry/app history key=] equals |key|, then return «[ "{{AppHistoryResult/committed}}" → [=a promise resolved with=] |appHistory|'s [=AppHistory/current entry=], "{{AppHistoryResult/finished}}" → [=a promise resolved with=] |appHistory|'s [=AppHistory/current entry=] ]»

  1. If |appHistory|'s [=AppHistory/upcoming traverse navigations=][|key|] [=map/exists=], then:

    1. Let |navigation| be |appHistory|'s [=AppHistory/upcoming traverse navigations=][|key|].

    1. Return «[ "{{AppHistoryResult/committed}}" → |navigation|'s [=app history API navigation/committed promise=], "{{AppHistoryResult/finished}}" → |navigation|'s [=app history API navigation/finished promise=] ]».

  1. Let |navigable| be |appHistory|'s [=relevant global object=]'s [=Window/browsing context=]'s [=browsing context/containing navigable=].

  1. Let |traversable| be |navigable|'s [=navigable/traversable navigable=].

  1. Let |initiatorBC| be |appHistory|'s [=relevant global object=]'s [=Window/browsing context=].

  1. Let |info| be |options|["{{AppHistoryNavigationOptions/info}}"] if it [=map/exists=], or undefined otherwise.

  1. Let |ongoingNavigation| be the result of [=AppHistory/setting an upcoming traverse navigation=] for |appHistory| given |key| and |info|.

  1. [=parallel queue/Enqueue the following steps=] on |traversable|'s [=traversable navigable/session history traversal queue=]:

    1. Let |navigableEntries| be the result of [=navigable/getting the session history entries=] given |navigable|.

    1. Let |targetEntry| be the [=session history entry=] in |navigableEntries| whose [=session history entry/app history key=] equals |key|. If no such entry exists, then:

      1. [=app history API navigation/Reject the finished promise=] for |ongoingNavigation| with an "{{InvalidStateError}}" {{DOMException}}.

      1. Abort these steps.

      <p class="note">This can occur if the |appHistory| object's view of session history is outdated, which can happen for brief periods while all the relevant threads and processes are being synchronized in reaction to a history change (such as the user clearing their history).

    1. If |targetEntry| is |navigable|'s [=navigable/active session history entry=], then abort these steps.

       <p class="note">This can occur if a previously-queued-up traversal already took us to this session history entry. In that case that previous traversal will have dealt with |ongoingNavigation| already.

    1. Let |targetStep| be null.

    1. If |targetEntry|'s [=session history entry/step=] is greater than |traversable|'s [=traversable navigable/current session history step=], then set |targetStep| to |targetEntry|'s [=session history entry/step=].

    1. Otherwise:

      1. Let |afterTarget| be the [=session history entry=] after |targetEntry| in |navigableEntries|.

      1. Let |allSteps| be the result of [=traversable navigable/getting all history steps=] that are part of the target session TODO.

      1. Set |targetStep| to the greatest number in |allSteps| that is less than |afterTarget|'s [=session history entry/step=].

    1. [=Apply the history step=] |targetStep| to |traversable|, with true, |initiatorBC|, and "<code>[=user navigation involvement/none=]</code>".

      - If this aborts due to user-canceled unloading or due to the {{AppHistory/navigate}} event being canceled, then [=finalize with an aborted navigation error=] given |appHistory| and |ongoingNavigation|.

      - If this aborts due to the initiator allowed-to-navigate check, then [=finalize with an aborted navigation error=] given |appHistory|, |ongoingNavigation|, and a [=new=] "{{SecurityError}}" {{DOMException}} created in |appHistory|'s [=relevant Realm=].

      <p class="advisement">Eventually [=apply the history step=] will have well-specified hooks for communicating these conditions back to its caller.</p>

  1. Return «[ "{{AppHistoryResult/committed}}" → |ongoingNavigation|'s [=app history API navigation/committed promise=], "{{AppHistoryResult/finished}}" → |ongoingNavigation|'s [=app history API navigation/finished promise=] ]».
</div>

<h3 id="global-events">Event handlers</h3>

The following are the [=event handlers=] (and their corresponding [=event handler event types=]) that must be supported, as [=event handler IDL attributes=], by objects implementing the {{AppHistory}} interface:

<table>
  <thead>
    <th>[=Event handler=]
    <th>[=Event handler event type=]
  <tbody>
    <tr>
      <td><dfn attribute for="AppHistory">onnavigate</dfn>
      <td><dfn event for="AppHistory">navigate</dfn>
    <tr>
      <td><dfn attribute for="AppHistory">onnavigatesuccess</dfn>
      <td><dfn event for="AppHistory">navigatesuccess</dfn>
    <tr>
      <td><dfn attribute for="AppHistory">onnavigateerror</dfn>
      <td><dfn event for="AppHistory">navigateerror</dfn>
    <tr>
      <td><dfn attribute for="AppHistory">oncurrentchange</dfn>
      <td><dfn event for="AppHistory">currentchange</dfn>
</table>

<h2 id="navigate-event">The {{AppHistory/navigate}} event</h2>

<h3 id="navigate-event-class">The {{AppHistoryNavigateEvent}} class</h3>

<xmp class="idl">
[Exposed=Window]
interface AppHistoryNavigateEvent : Event {
  constructor(DOMString type, AppHistoryNavigateEventInit eventInit);

  readonly attribute AppHistoryNavigationType navigationType;
  readonly attribute AppHistoryDestination destination;
  readonly attribute boolean canTransition;
  readonly attribute boolean userInitiated;
  readonly attribute boolean hashChange;
  readonly attribute AbortSignal signal;
  readonly attribute FormData? formData;
  readonly attribute any info;

  undefined transitionWhile(Promise<undefined> newNavigationAction);
};

dictionary AppHistoryNavigateEventInit : EventInit {
  AppHistoryNavigationType navigationType = "push";
  required AppHistoryDestination destination;
  boolean canTransition = false;
  boolean userInitiated = false;
  boolean hashChange = false;
  required AbortSignal signal;
  FormData? formData = null;
  any info;
};

enum AppHistoryNavigationType {
  "reload",
  "push",
  "replace",
  "traverse"
};
</xmp>

<dl class="domintro non-normative">
  <dt><code><var ignore>event</var>.{{AppHistoryNavigateEvent/navigationType}}</code>
  <dd>
    <p>One of "{{AppHistoryNavigationType/reload}}", "{{AppHistoryNavigationType/push}}", "{{AppHistoryNavigationType/replace}}", or "{{AppHistoryNavigationType/traverse}}", indicating what type of navigation this is.
  </dd>
  <dt><code><var ignore>event</var>.{{AppHistoryNavigateEvent/destination}}</code>
  <dd>
    <p>An {{AppHistoryDestination}} representing the destination of the navigation.
  </dd>

  <dt><code><var ignore>event</var>.{{AppHistoryNavigateEvent/canTransition}}</code>
  <dd>
    <p>True if {{AppHistoryNavigateEvent/transitionWhile()}} can be called to convert this navigation into a single-page navigation; false otherwise.

    <p>Generally speaking, this will be true whenever the current {{Document}} <a spec="HTML">can have its URL rewritten</a> to the destination URL, except for cross-document back/forward navigations, where it will always be false.
  </dd>

  <dt><code><var ignore>event</var>.{{AppHistoryNavigateEvent/userInitiated}}</code>
  <dd>
    <p>True if this navigation was due to a user clicking on an <{a}> element, submitting a <{form}> element, or using the browser UI to navigate; false otherwise.
  </dd>

  <dt><code><var ignore>event</var>.{{AppHistoryNavigateEvent/hashChange}}</code>
  <dd>
    <p>True if this navigation is a <a spec="HTML" lt="navigate to a fragment">fragment navigation</a>; false otherwise.
  </dd>

  <dt><code><var ignore>event</var>.{{AppHistoryNavigateEvent/signal}}</code>
  <dd>
    <p>An {{AbortSignal}} which will become aborted if the navigation gets canceled, e.g. by the user pressing their browser's "Stop" button, or another higher-priority navigation interrupting this one.

    <p>The expected pattern is for developers to pass this along to any async operations, such as {{WindowOrWorkerGlobalScope/fetch()}}, which they perform as part of handling this navigation.
  </dd>

  <dt><code><var ignore>event</var>.{{AppHistoryNavigateEvent/formData}}</code>
  <dd>
    <p>The {{FormData}} representing the submitted form entries for this navigation, if this navigation is a "{{AppHistoryNavigationType/push}}" or "{{AppHistoryNavigationType/replace}}" navigation representing a POST <a spec="HTML" lt="submit">form submission</a>; null otherwise.

    <p>(Notably, this will be null even for "{{AppHistoryNavigationType/reload}}" and "{{AppHistoryNavigationType/traverse}}" navigations that are revisiting a session history entry that was originally created from a form submission.)
  </dd>

  <dt><code><var ignore>event</var>.{{AppHistoryNavigateEvent/info}}</code>
  <dd>
    <p>An arbitrary JavaScript value passed via other app history APIs that initiated this navigation, or null if the navigation was initiated by the user or via a non-app history API.
  </dd>

  <dt><code><var ignore>event</var>.{{AppHistoryNavigateEvent/transitionWhile()|transitionWhile}}(|newNavigationAction|)</code>
  <dd>
    <p>Synchronously converts this navigation into a same-document navigation to the destination URL.

    <p>The given |newNavigationAction| promise is used to signal the duration, and success or failure, of the navigation. After it settles, the browser signals to the user (e.g. via a loading spinner UI, or assistive technology) that the navigation is finished. Additionally, it fires {{AppHistory/navigatesuccess}} or {{AppHistory/navigateerror}} events as appropriate, which other parts of the web application can respond to.

    <p>This method will throw a "{{SecurityError}}" {{DOMException}} if {{AppHistoryNavigateEvent/canTransition}} is false, or if {{Event/isTrusted}} is false. It will throw an "{{InvalidStateError}}" {{DOMException}} if not called synchronously, during event dispatch.
  </dd>
</dl>

The <dfn attribute for="AppHistoryNavigateEvent">navigationType</dfn>, <dfn attribute for="AppHistoryNavigateEvent">destination</dfn>, <dfn attribute for="AppHistoryNavigateEvent">canTransition</dfn>, <dfn attribute for="AppHistoryNavigateEvent">userInitiated</dfn>, <dfn attribute for="AppHistoryNavigateEvent">hashChange</dfn>, <dfn attribute for="AppHistoryNavigateEvent">signal</dfn>, <dfn attribute for="AppHistoryNavigateEvent">formData</dfn>, and <dfn attribute for="AppHistoryNavigateEvent">info</dfn> getter steps are to return the value that the corresponding attribute was initialized to.

An {{AppHistoryNavigateEvent}} has the following associated values which are only conditionally used:

* <dfn for="AppHistoryNavigateEvent">classic history API serialized data</dfn>, a [=serialized state=]-or-null, used when its {{AppHistoryNavigateEvent/navigationType}} is "{{AppHistoryNavigationType/reload}}", "{{AppHistoryNavigationType/push}}" or "{{AppHistoryNavigationType/replace}}"

This is set appropriately when the event is [[#navigate-event-firing|fired]].

An {{AppHistoryNavigateEvent}} also has an associated <dfn for="AppHistoryNavigateEvent">navigation action promises list</dfn>, which is a [=list=] of {{Promise}} objects, initially empty.

<div algorithm>
  The <dfn method for="AppHistoryNavigateEvent">transitionWhile(|newNavigationAction|)</dfn> method steps are:

  1. If [=this=]'s [=relevant global object=]'s [=active Document=] is not [=Document/fully active=], then throw an "{{InvalidStateError}}" {{DOMException}}.
  1. If [=this=]'s {{Event/isTrusted}} attribute was initialized to false, then throw a "{{SecurityError}}" {{DOMException}}.
  1. If [=this=]'s {{AppHistoryNavigateEvent/canTransition}} attribute was initialized to false, then throw a "{{SecurityError}}" {{DOMException}}.
  1. If [=this=]'s [=Event/dispatch flag=] is unset, then throw an "{{InvalidStateError}}" {{DOMException}}.
  1. If [=this=]'s [=Event/canceled flag=] is set, then throw an "{{InvalidStateError}}" {{DOMException}}.
  1. [=list/Append=] |newNavigationAction| to [=this=]'s [=AppHistoryNavigateEvent/navigation action promises list=].
</div>

<h3 id="navigate-event-destination">The {{AppHistoryDestination}} class</h3>

<xmp class="idl">
[Exposed=Window]
interface AppHistoryDestination {
  readonly attribute USVString url;
  readonly attribute DOMString? key;
  readonly attribute DOMString? id;
  readonly attribute long long index;
  readonly attribute boolean sameDocument;

  any getState();
};
</xmp>

<dl class="domintro non-normative">
  <dt><code><var ignore>event</var>.{{AppHistoryNavigateEvent/destination}}.{{AppHistoryDestination/url}}</code>
  <dd>
    <p>The URL being navigated to.
  </dd>

  <dt><code><var ignore>event</var>.{{AppHistoryNavigateEvent/destination}}.{{AppHistoryDestination/key}}</code>
  <dd>
    <p>The value of the {{AppHistoryEntry/key}} property of the destination {{AppHistoryEntry}}, if this is a "{{AppHistoryNavigationType/traverse}}" navigation, or null otherwise.
  </dd>

  <dt><code><var ignore>event</var>.{{AppHistoryNavigateEvent/destination}}.{{AppHistoryDestination/id}}</code>
  <dd>
    <p>The value of the {{AppHistoryEntry/id}} property of the destination {{AppHistoryEntry}}, if this is a "{{AppHistoryNavigationType/traverse}}" navigation, or null otherwise.
  </dd>

  <dt><code><var ignore>event</var>.{{AppHistoryNavigateEvent/destination}}.{{AppHistoryDestination/index}}</code>
  <dd>
    <p>The value of the {{AppHistoryEntry/index}} property of the destination {{AppHistoryEntry}}, if this is a "{{AppHistoryNavigationType/traverse}}" navigation, or &minus;1 otherwise.
  </dd>

  <dt><code><var ignore>event</var>.{{AppHistoryNavigateEvent/destination}}.{{AppHistoryDestination/sameDocument}}</code>
  <dd>
    <p>Indicates whether or not this navigation is to the same {{Document}} as the current {{Window/document}} value, or not. This will be true, for example, in cases of fragment navigations or {{History/pushState()|history.pushState()}} navigations.

    <p>Note that this property indicates the original nature of the navigation. If a cross-document navigation is converted into a same-document navigation using {{AppHistoryNavigateEvent/transitionWhile()|event.transitionWhile()}}, that will not change the value of this property.
  </dd>

  <dt><code><var ignore>state</var> = <var ignore>event</var>.{{AppHistoryNavigateEvent/destination}}.{{AppHistoryDestination/getState()}}</code>
  <dd>
    <p>For "{{AppHistoryNavigationType/traverse}}" navigations, returns the deserialization of the state stored in the destination session history entry.

    <p>For "{{AppHistoryNavigationType/push}}" and "{{AppHistoryNavigationType/replace}}" navigations, returns the deserialization of the state passed to {{AppHistory/navigate()|appHistory.navigate()}}, if the navigation was initiated in that way, or undefined if it wasn't.

    <p>For "{{AppHistoryNavigationType/reload}}" navigations, returns the deserialization of the state passed to {{AppHistory/reload()|appHistory.reload()}}, if the reload was initiated in that way, or undefined if it wasn't.
  </dd>
</dl>

An {{AppHistoryDestination}} has an associated <dfn for="AppHistoryDestination">URL</dfn>, which is a [=URL=].

An {{AppHistoryDestination}} has an associated <dfn for="AppHistoryDestination">key</dfn>, which is a [=string=]-or-null.

An {{AppHistoryDestination}} has an associated <dfn for="AppHistoryDestination">id</dfn>, which is a [=string=]-or-null.

An {{AppHistoryDestination}} has an associated <dfn for="AppHistoryDestination">index</dfn>, which is an integer.

An {{AppHistoryDestination}} has an associated <dfn for="AppHistoryDestination">state</dfn>, which is a [=serialized state=]-or-null.

An {{AppHistoryDestination}} has an associated <dfn for="AppHistoryDestination">is same document</dfn>, which is a boolean.

The <dfn attribute for="AppHistoryDestination">url</dfn> getter steps are to return [=this=]'s [=AppHistoryDestination/URL=], [=URL serializer|serialized=].

The <dfn attribute for="AppHistoryDestination">key</dfn> getter steps are to return [=this=]'s [=AppHistoryDestination/key=].

The <dfn attribute for="AppHistoryDestination">id</dfn> getter steps are to return [=this=]'s [=AppHistoryDestination/id=].

The <dfn attribute for="AppHistoryDestination">index</dfn> getter steps are to return [=this=]'s [=AppHistoryDestination/index=].

The <dfn attribute for="AppHistoryDestination">sameDocument</dfn> getter steps are to return [=this=]'s [=AppHistoryDestination/is same document=].

<div algorithm>
  The <dfn method for="AppHistoryDestination">getState()</dfn> method steps are:

  1. If [=this=]'s [=AppHistoryDestination/state=] is null, then return undefined.
  1. Return [$StructuredDeserialize$]([=this=]'s [=AppHistoryDestination/state=]).
</div>

<h3 id="navigate-event-firing">Firing the event</h3>

<div algorithm="fire a traversal navigate event">
  To <dfn>fire a traversal `navigate` event</dfn> at an {{AppHistory}} |appHistory| given a [=session history entry=] <dfn for="fire a traversal navigate event">|destinationEntry|</dfn>, and an optional [=user navigation involvement=] <dfn for="fire a traversal navigate event">|userInvolvement|</dfn> (default "<code>[=user navigation involvement/none=]</code>"):

  1. Let |event| be the result of [=creating an event=] given {{AppHistoryNavigateEvent}}, in |appHistory|'s [=relevant Realm=].
  1. Let |destination| be a [=new=] {{AppHistoryDestination}} created in |appHistory|'s [=relevant Realm=].
  1. Set |destination|'s [=AppHistoryDestination/URL=] to |destinationEntry|'s [=session history entry/URL=].
  1. If |destinationEntry|'s [=session history entry/origin=] is [=same origin=] with |appHistory|'s [=relevant settings object=]'s [=environment settings object/origin=], then:
    1. Set |destination|'s [=AppHistoryDestination/key=] to |destinationEntry|'s [=session history entry/app history key=].
    1. Set |destination|'s [=AppHistoryDestination/id=] to |destinationEntry|'s [=session history entry/app history id=].
    1. Set |destination|'s [=AppHistoryDestination/index=] to the result of [=getting the app history index=] of |destinationEntry| within |appHistory|.
    1. Set |destination|'s [=AppHistoryDestination/state=] to |destinationEntry|'s [=session history entry/app history state=].
  1. Otherwise,
    1. Set |destination|'s [=AppHistoryDestination/key=] to null.
    1. Set |destination|'s [=AppHistoryDestination/id=] to null.
    1. Set |destination|'s [=AppHistoryDestination/index=] to &minus;1.
    1. Set |destination|'s [=AppHistoryDestination/state=] to null.
  1. Set |destination|'s [=AppHistoryDestination/is same document=] to true if |destinationEntry|'s [=session history entry/document=] is equal to |appHistory|'s [=relevant global object=]'s [=associated Document=]; otherwise false.
  1. Let |result| be the result of performing the [=inner navigate event firing algorithm=] given |appHistory|, "{{AppHistoryNavigationType/traverse}}", |event|, |destination|, |userInvolvement|, and null.
  1. Assert: |result| is true (traversals are never cancelable).
</div>

<div algorithm="fire a push or replace navigate event">
  To <dfn>fire a push or replace `navigate` event</dfn> at an {{AppHistory}} |appHistory| given an {{AppHistoryNavigationType}} <dfn for="fire a push or replace navigate event">|navigationType|</dfn>, a [=URL=] <dfn for="fire a push or replace navigate event">|destinationURL|</dfn>, a boolean <dfn for="fire a push or replace navigate event">|isSameDocument|</dfn>, an optional [=user navigation involvement=] <dfn for="fire a push or replace navigate event">|userInvolvement|</dfn> (default "<code>[=user navigation involvement/none=]</code>"), an optional [=serialized state=]-or-null <dfn for="fire a push or replace navigate event">|state|</dfn> (default null), an optional [=list=] of {{FormData}} [=FormData/entries=] or null <dfn for="fire a push or replace navigate event">|formDataEntryList|</dfn> (default null), and an optional [=serialized state=]-or-null <dfn for="fire a push or replace navigate event">|classicHistoryAPISerializedData|</dfn> (default null):

  1. Let |event| be the result of [=creating an event=] given {{AppHistoryNavigateEvent}}, in |appHistory|'s [=relevant Realm=].
  1. Set |event|'s [=AppHistoryNavigateEvent/classic history API serialized data=] to |classicHistoryAPISerializedData|.
  1. Let |destination| be a [=new=] {{AppHistoryDestination}} created in |appHistory|'s [=relevant Realm=].
  1. Set |destination|'s [=AppHistoryDestination/URL=] to |destinationURL|.
  1. Set |destination|'s [=AppHistoryDestination/key=] to null.
  1. Set |destination|'s [=AppHistoryDestination/id=] to null.
  1. Set |destination|'s [=AppHistoryDestination/index=] to &minus;1.
  1. Set |destination|'s [=AppHistoryDestination/state=] to |state|.
  1. Set |destination|'s [=AppHistoryDestination/is same document=] to |isSameDocument|.
  1. Return the result of performing the [=inner navigate event firing algorithm=] given |appHistory|, |navigationType|, |event|, |destination|, |userInvolvement|, and |formDataEntryList|.
</div>

<div algorithm>
  The <dfn>inner `navigate` event firing algorithm</dfn> is the following steps, given an {{AppHistory}} |appHistory|, an {{AppHistoryNavigationType}} |navigationType|, an {{AppHistoryNavigateEvent}} |event|, an {{AppHistoryDestination}} |destination|, a [=user navigation involvement=] |userInvolvement|, and a [=list=] of {{FormData}} [=FormData/entries=] or null |formDataEntryList|:

  1. [=AppHistory/Promote the upcoming navigation to ongoing=] given |appHistory| and |destination|'s [=AppHistoryDestination/key=].
  1. Let |ongoingNavigation| be |appHistory|'s [=AppHistory/ongoing navigation=].
  1. If |appHistory| [=AppHistory/has entries and events disabled=], then:
    1. If |ongoingNavigation| is not null, then [=app history API navigation/clean up=] |ongoingNavigation|.
       <p class="note">In this case the [=app history API navigation/committed promise=] and [=app history API navigation/finished promise=] will never fulfill, since we never create {{AppHistoryEntry}}s for the initial `about:blank` {{Document}} so we have nothing to [=resolve=] them with.
    1. Return true.
  1. Let |document| be |appHistory|'s [=relevant global object=]'s [=associated document=].
  1. If |document| <a spec="HTML">can have its URL rewritten</a> to |destination|'s [=AppHistoryDestination/URL=], and either |destination|'s [=AppHistoryDestination/is same document=] is true or |navigationType| is not "{{AppHistoryNavigationType/traverse}}", then initialize |event|'s {{AppHistoryNavigateEvent/canTransition}} to true. Otherwise, initialize it to false.
  1. If |navigationType| is not "{{AppHistoryNavigationType/traverse}}", then initialize |event|'s {{Event/cancelable}} to true. Otherwise, initialize it to false.
  1. Initialize |event|'s {{Event/type}} to "{{AppHistory/navigate}}".
  1. Initialize |event|'s {{AppHistoryNavigateEvent/navigationType}} to |navigationType|.
  1. Initialize |event|'s {{AppHistoryNavigateEvent/destination}} to |destination|.
  1. If |ongoingNavigation| is not null, then initialize |event|'s {{AppHistoryNavigateEvent/info}} to |ongoingNavigation|'s [=app history API navigation/info=]. Otherwise, initialize it to undefined.
     <p class="note">At this point |ongoingNavigation|'s [=app history API navigation/info=] is no longer needed and can be nulled out instead of keeping it alive for the lifetime of the [=app history API navigation=].
  1. Initialize |event|'s {{AppHistoryNavigateEvent/signal}} to a [=new=] {{AbortSignal}} created in |appHistory|'s [=relevant Realm=].
  1. Let |currentURL| be |document|'s [=Document/URL=].
  1. If all of the following are true:
    * |destination|'s [=AppHistoryDestination/is same document=] is true;
    * |destination|'s [=AppHistoryDestination/URL=] [=url/equals=] |currentURL| with <i>[=url/equals/exclude fragments=]</i> set to true; and
    * |destination|'s [=AppHistoryDestination/URL=]'s [=url/fragment=] is not [=string/is|identical to=] |currentURL|'s [=url/fragment=]

    then initialize |event|'s {{AppHistoryNavigateEvent/hashChange}} to true. Otherwise, initialize it to false.
  1. If |userInvolvement| is not "<code>[=user navigation involvement/none=]</code>", then initialize |event|'s {{AppHistoryNavigateEvent/userInitiated}} to true. Otherwise, initialize it to false.
  1. If |formDataEntryList| is not null, then initialize |event|'s {{AppHistoryNavigateEvent/formData}} to a [=new=] {{FormData}} created in |appHistory|'s [=relevant Realm=], associated to |formDataEntryList|. Otherwise, initialize it to null.
  1. [=Assert=]: |appHistory|'s [=AppHistory/ongoing navigate event=] is null.
  1. Set |appHistory|'s [=AppHistory/ongoing navigate event=] to |event|.
  1. [=Assert=]: |appHistory|'s [=AppHistory/ongoing navigation signal=] is null.
  1. Set |appHistory|'s [=AppHistory/ongoing navigation signal=] to |event|'s {{AppHistoryNavigateEvent/signal}}.
  1. Let |dispatchResult| be the result of [=dispatching=] |event| at |appHistory|.
  1. Set |appHistory|'s [=AppHistory/ongoing navigate event=] to null.
  1. If |dispatchResult| is false:
    1. If |navigationType| is not "{{AppHistoryNavigationType/traverse}}" and |event|'s {{AppHistoryNavigateEvent/signal}} is not [=AbortSignal/aborted=], then [=finalize with an aborted navigation error=] given |appHistory| and |ongoingNavigation|.
       <p class="note">If |navigationType| is "{{AppHistoryNavigationType/traverse}}", then we will [=finalize with an aborted navigation error=] in [=perform an app history traversal=].
    1. Return false.
  1. Let |hadTransitionWhile| be true if |event|'s [=AppHistoryNavigateEvent/navigation action promises list=] is not empty; otherwise false.
  1. Let |endResultIsSameDocument| be true if |hadTransitionWhile| is true or |destination|'s [=AppHistoryDestination/is same document=] is true.
  1. If |hadTransitionWhile| is true:
    1. Let |fromEntry| be the [=AppHistory/current entry=] for |appHistory|.
    1. Assert: |fromEntry| is not null.
    1. Set |appHistory|'s [=AppHistory/transition=] to a [=new=] {{AppHistoryTransition}} created in |appHistory|'s [=relevant Realm=], whose [=AppHistoryTransition/navigation type=] is |navigationType|, [=AppHistoryTransition/from entry=] is |fromEntry|, and whose [=AppHistoryTransition/finished promise=] is [=a new promise=] created in |appHistory|'s [=relevant Realm=].
  1. If |endResultIsSameDocument| is true:
    1. Let |transition| be |appHistory|'s [=AppHistory/transition=].
    1. Assert: |transition| is not null.
    1. [=Wait for all=] of |event|'s [=AppHistoryNavigateEvent/navigation action promises list=], with the following success steps:
        1. If |event|'s {{AppHistoryNavigateEvent/signal}} is [=AbortSignal/aborted=], then abort these steps.
        1. [=Fire an event=] named {{AppHistory/navigatesuccess}} at |appHistory|.
        1. [=Resolve=] |transition|'s [=AppHistoryTransition/finished promise=] with undefined.
        1. If |appHistory|'s [=AppHistory/transition=] is |transition|, then set |appHistory|'s [=AppHistory/transition=] to null.
        1. If |ongoingNavigation| is non-null, then [=app history API navigation/resolve the finished promise=] for |ongoingNavigation|.
      and the following failure steps given reason |rejectionReason|:
        1. If |event|'s {{AppHistoryNavigateEvent/signal}} is [=AbortSignal/aborted=], then abort these steps.
        1. [=Fire an event=] named {{AppHistory/navigateerror}} at |appHistory| using {{ErrorEvent}}, with {{ErrorEvent/error}} initialized to |rejectionReason|, and {{ErrorEvent/message}}, {{ErrorEvent/filename}}, {{ErrorEvent/lineno}}, and {{ErrorEvent/colno}} initialized to appropriate values that can be extracted from |rejectionReason| in the same underspecified way the user agent typically does for the <a spec="HTML">report an exception</a> algorithm.
        1. [=Reject=] |transition|'s [=AppHistoryTransition/finished promise=] with |rejectionReason|.
        1. If |appHistory|'s [=AppHistory/transition=] is |transition|, then set |appHistory|'s [=AppHistory/transition=] to null.
        1. If |ongoingNavigation| is non-null, then [=app history API navigation/reject the finished promise=] for |ongoingNavigation| with |rejectionReason|.
  1. Otherwise, if |ongoingNavigation| is non-null, then:
    1. Set |ongoingNavigation|'s [=app history API navigation/serialized state=] to null.
       <p class="note">This ensures that any call to {{AppHistory/navigate()|appHistory.navigate()}} which triggered this algorithm does not overwrite the [=session history entry/app history state=] of the [=session history/current entry=] for cross-document navigations.
    1. [=app history API navigation/Clean up=] |ongoingNavigation|.
  1. If |hadTransitionWhile| is true and |navigationType| is not "{{AppHistoryNavigationType/traverse}}":
    1. Let |isPush| be true if |navigationType| is "{{AppHistoryNavigationType/push}}"; otherwise, false.
    1. Run the <a spec="HTML">URL and history update steps</a> given |document| and |event|'s {{AppHistoryNavigateEvent/destination}}'s [=AppHistoryDestination/URL=], with <i>[=URL and history update steps/serializedData=]</i> set to |event|'s [=AppHistoryNavigateEvent/classic history API serialized data=] and <i>[=URL and history update steps/isPush=]</i> set to |isPush|.
    1. Return false.
  1. Return true.
</div>

<div algorithm>
  To <dfn>finalize with an aborted navigation error</dfn> given an {{AppHistory}} |appHistory|, an [=app history API navigation=] or null |ongoingNavigation|, and an optional {{DOMException}} |error|:

  1. If |error| was not given, then set |error| to a [=new=] "{{AbortError}}" {{DOMException}}, created in |appHistory|'s [=relevant Realm=].
  1. If |appHistory|'s [=AppHistory/ongoing navigate event=] is non-null, then:
    1. Set |appHistory|'s [=AppHistory/ongoing navigate event=]'s [=Event/canceled flag=] to true.
    1. Set |appHistory|'s [=AppHistory/ongoing navigate event=] to null.
  1. If |appHistory|'s [=AppHistory/ongoing navigation signal=] is non-null, then:
    1. [=AbortSignal/Signal abort=] on |appHistory|'s [=AppHistory/ongoing navigation signal=] given |error|.
    1. Set |appHistory|'s [=AppHistory/ongoing navigation signal=] to null.
  1. [=Fire an event=] named {{AppHistory/navigateerror}} at |appHistory| using {{ErrorEvent}}, with {{ErrorEvent/error}} initialized to |error|, and {{ErrorEvent/message}}, {{ErrorEvent/filename}}, {{ErrorEvent/lineno}}, and {{ErrorEvent/colno}} initialized to appropriate values that can be extracted from |error| and the current JavaScript stack in the same underspecified way the user agent typically does for the <a spec="HTML">report an exception</a> algorithm.
     <p class="note">Thus, for example, if this algorithm is reached because of a call to {{Window/stop()|window.stop()}}, these properties would probably end up initialized based on the line of script that called {{Window/stop()|window.stop()}}. But if it's because the user clicked the stop button, these properties would probably end up with default values like the empty string or 0.
  1. If |ongoingNavigation| is non-null, then:
    1. Set |ongoingNavigation|'s [=app history API navigation/serialized state=] to null.
       <p class="note">This ensures that any call to {{AppHistory/navigate()|appHistory.navigate()}} which triggered this algorithm does not overwrite the [=session history entry/app history state=] of the [=session history/current entry=] for aborted navigations.
    1. [=app history API navigation/Reject the finished promise=] for |ongoingNavigation| with |error|.
  1. If |appHistory|'s [=AppHistory/transition=] is not null, then:
    1. [=Reject=] |appHistory|'s [=AppHistory/transition=]'s [=AppHistoryTransition/finished promise=] with |error|.
    1. Set |appHistory|'s [=AppHistory/transition=] to null.
</div>

<div algorithm>
  To <dfn>inform app history about canceling navigation</dfn> in a [=browsing context=] |bc|:

  1. Let |appHistory| be |bc|'s [=browsing context/active window=]'s [=Window/app history=].
  1. If |appHistory|'s [=AppHistory/ongoing navigation signal=] is null, then return.
  1. [=Finalize with an aborted navigation error=] given |appHistory| and |appHistory|'s [=AppHistory/ongoing navigation=].
</div>

<div algorithm>
  To <dfn>inform app history about browsing context discarding</dfn> given a [=browsing context=] |bc|:

  1. [=Inform app history about canceling navigation=] in |bc|.
  1. Let |appHistory| be |bc|'s [=browsing context/active window=]'s [=Window/app history=].
  1. Let |traversals| be a [=list/clone=] of |appHistory|'s [=AppHistory/upcoming traverse navigations=].
  1. For each |traversal| of |traversals|: [=finalize with an aborted navigation error=] given |appHistory| and |traversal|.
</div>

<h2 id="apphistoryentry-class">App history entries</h2>

<xmp class="idl">
[Exposed=Window]
interface AppHistoryEntry : EventTarget {
  readonly attribute USVString url;
  readonly attribute DOMString key;
  readonly attribute DOMString id;
  readonly attribute long long index;
  readonly attribute boolean sameDocument;

  any getState();

  attribute EventHandler onnavigateto;
  attribute EventHandler onnavigatefrom;
  attribute EventHandler onfinish;
  attribute EventHandler ondispose;
};
</xmp>

<dl class="domintro non-normative">
  <dt><code><var ignore>entry</var>.{{AppHistoryEntry/url}}</code>
  <dd>
    <p>The URL of this app history entry.
  </dd>

  <dt><code><var ignore>entry</var>.{{AppHistoryEntry/key}}</code>
  <dd>
    <p>A [=user agent=]-generated random UUID string representing this app history entry's place in the app history list. This value will be reused by other {{AppHistoryEntry}} instances that replace this one due to replace-style navigations. This value will survive session restores.

    <p>This is useful for navigating back to this location in the app history entry list, using {{AppHistory/goTo(key)|appHistory.goTo(key)}}.
  </dd>

  <dt><code><var ignore>entry</var>.{{AppHistoryEntry/id}}</code>
  <dd>
    <p>A [=user agent=]-generated random UUID string representing this specific app history entry. This value will <em>not</em> be reused by other {{AppHistoryEntry}} instances. This value will survive session restores.

    <p>This is useful for associating data with this app history entry using other storage APIs.
  </dd>

  <dt><code><var ignore>entry</var>.{{AppHistoryEntry/index}}</code>
  <dd>
    <p>The index of this app history entry within {{AppHistory/entries()|appHistory.entries()}}, or &minus;1 if the entry is not in the app history list.
  </dd>

  <dt><code><var ignore>entry</var>.{{AppHistoryEntry/sameDocument}}</code>
  <dd>
    <p>Indicates whether or not this app history entry is for the same {{Document}} as the current {{Window/document}} value, or not. This will be true, for example, when the entry represents a fragment navigation or single-page app navigations.
  </dd>

  <dt><code><var ignore>state</var> = <var ignore>entry</var>.{{AppHistoryEntry/getState()|getState}}()</code>
  <dd>
    <p>Returns the deserialization of the state stored in this entry, which was added to the entry using {{AppHistory/navigate()|appHistory.navigate()}}. This state survives session restores.

    <p>Note that in general, unless the state value is a primitive, <code>entry.getState() !== entry.getState()</code>, since a fresh copy is returned each time.

    <p>This state is unrelated to the classic history API's {{History/state|history.state}}.
  </dd>
</dl>

Each {{AppHistoryEntry}} has an associated <dfn for="AppHistoryEntry">session history entry</dfn>, which is a [=session history entry=].

Each {{AppHistoryEntry}} has an associated <dfn for="AppHistoryEntry">index</dfn>, which is an integer.

<div algorithm>
  The <dfn attribute for="AppHistoryEntry">key</dfn> getter steps are:

  1. If [=this=]'s [=relevant global object=]'s [=associated Document=] is not [=Document/fully active=], then return the empty string.
  1. Return [=this=]'s [=AppHistoryEntry/session history entry=]'s [=session history entry/app history key=].
</div>

<div algorithm>
  The <dfn attribute for="AppHistoryEntry">id</dfn> getter steps are:

  1. If [=this=]'s [=relevant global object=]'s [=associated Document=] is not [=Document/fully active=], then return the empty string.
  1. Return [=this=]'s [=AppHistoryEntry/session history entry=]'s [=session history entry/app history id=].
</div>

<div algorithm>
  The <dfn attribute for="AppHistoryEntry">url</dfn> getter steps are:

  1. If [=this=]'s [=relevant global object=]'s [=associated Document=] is not [=Document/fully active=], then return the empty string.
  1. Return [=this=]'s [=AppHistoryEntry/session history entry=]'s [=session history entry/URL=], [=URL serializer|serialized=].
</div>

<div algorithm>
  The <dfn attribute for="AppHistoryEntry">index</dfn> getter steps are:

  1. If [=this=]'s [=relevant global object=]'s [=associated Document=] is not [=Document/fully active=], then return &minus;1.
  1. Return [=this=]'s [=AppHistoryEntry/index=].
</div>

<div algorithm>
  The <dfn attribute for="AppHistoryEntry">sameDocument</dfn> getter steps are:

  1. If [=this=]'s [=relevant global object=]'s [=associated Document=] is not [=Document/fully active=], then return false.
  1. Return true if [=this=]'s [=AppHistoryEntry/session history entry=]'s [=session history entry/document=] equals [=this=]'s [=relevant global object=]'s [=associated Document=], and false otherwise.
</div>

<div algorithm>
  The <dfn method for="AppHistoryEntry">getState()</dfn> method steps are:

  1. If [=this=]'s [=relevant global object=]'s [=associated Document=] is not [=Document/fully active=], then return undefined.
  1. If [=this=]'s [=AppHistoryEntry/session history entry=]'s [=session history entry/app history state=] is null, then return undefined.
  1. Return [$StructuredDeserialize$]([=this=]'s [=AppHistoryEntry/session history entry=]'s [=session history entry/app history state=]).

  <p class="note">Unlike {{History/state|history.state}}, this will deserialize upon each access.

  <p class="note">This can in theory throw an exception, if attempting to deserialize a large {{ArrayBuffer}} when not enough memory is available.
</div>

The following are the [=event handlers=] (and their corresponding [=event handler event types=]) that must be supported, as [=event handler IDL attributes=], by objects implementing the {{AppHistoryEntry}} interface:

<table>
  <thead>
    <th>[=Event handler=]
    <th>[=Event handler event type=]
  <tbody>
    <tr>
      <td><dfn attribute for="AppHistoryEntry">onnavigateto</dfn>
      <td><dfn event for="AppHistoryEntry">navigateto</dfn>
    <tr>
      <td><dfn attribute for="AppHistoryEntry">onnavigatefrom</dfn>
      <td><dfn event for="AppHistoryEntry">navigatefrom</dfn>
    <tr>
      <td><dfn attribute for="AppHistoryEntry">onfinish</dfn>
      <td><dfn event for="AppHistoryEntry">finish</dfn>
    <tr>
      <td><dfn attribute for="AppHistoryEntry">ondispose</dfn>
      <td><dfn event for="AppHistoryEntry">dispose</dfn>
</table>

TODO: actually fire {{AppHistoryEntry/finish}}, {{AppHistoryEntry/navigateto}}, and {{AppHistoryEntry/navigatefrom}}.

<h2 id="navigate-patches">Patches to fire the {{AppHistory/navigate}} event</h2>

The following section details monkeypatches to [[!HTML]] that cause the {{AppHistory/navigate}} event to be fired appropriately, and for canceling the event to cancel the navigation. The first few sections detail slight tweaks to existing algorithms to pass through useful information into the navigation and history traversal algorithms. Then, [[#navigate-algorithm-patches]] contains the actual firing of the event.

<h3 id="form-patches">Form submission patches</h3>

To properly thread the form entry list from its creation through to {{AppHistoryNavigateEvent}}'s {{AppHistoryNavigateEvent/formData}} property, we need the following modifications:

<div algorithm="form navigate">
  Modify the <a spec="HTML">navigate</a> algorithm to take a [=list=] of [=FormData/entries=] or null <dfn for="navigate">|entryList|</dfn> (default null), replacing its |navigationType| parameter. Then insert a step somewhere early in the algorithm to convert this back into the |navigationType| variable used by the [=in parallel=] section that is ultimately passed to [[CSP]]:

  1. Let |navigationType| be "`form-submission`" if |entryList| is non-null; otherwise, "`other`".
</div>

<div algorithm="plan to navigate">
  Modify the <a spec="HTML">plan to navigate</a> algorithm to take an additional optional argument |entryList| (default null). Then, modify the step which calls <a spec="HTML">navigate</a> to pass it along:

  1. <a spec="HTML">Navigate</a> <var ignore>target browsing context</var> to <var ignore>destination</var>, with <i>[=navigate/historyHandling=]</i> set to <var ignore>historyHandling</var> <del>and <i>[=navigate/navigationType=]</i> set to "`form-submission`"</del><ins><i>[=navigate/entryList=]</i> set to |entryList|</ins>.
</div>

<div algorithm="submit as entity body">
  Modify the <a spec="HTML">submit as entity body</a> algorithm to pass <var ignore>entry list</var> along to <a spec="HTML">plan to navigate</a> as a second argument.
</div>

<h3 id="user-initiated-patches">Browser UI/user-initiated patches</h3>

To more rigorously specify when a navigation is initiated from browser UI or by the user interacting with <{a}>, <{area}>, and <{form}> elements, both for the purposes of the {{AppHistoryNavigateEvent}}'s {{AppHistoryNavigateEvent/userInitiated}} property and for prohibiting interception of certain types of browser-UI-initiated navigations, we need the following modifications:

Introduce (right before the definition of the <a spec="HTML">navigate</a> algorithm) the concept of a <dfn>user navigation involvement</dfn>, which is one of the following:

: "<dfn for="user navigation involvement"><code>browser UI</code></dfn>"
:: The navigation was initiated by the user via browser UI mechanisms
: "<dfn for="user navigation involvement"><code>activation</code></dfn>"
:: The navigation was initiated by the user via the [=EventTarget/activation behavior=] of an element
: "<dfn for="user navigation involvement"><code>none</code></dfn>"
:: The navigation was not initiated by the user

Define the <dfn for="Event">user navigation involvement</dfn> for an {{Event}} |event| as "<code>[=user navigation involvement/activation=]</code>" if |event|'s {{Event/isTrusted}} attribute is initialized to true, and "<code>[=user navigation involvement/none=]</code>" otherwise.

Modify the <a spec="HTML">navigate</a> algorithm to take an optional named argument <dfn for="navigate"><var ignore>userInvolvement</var></dfn> (default "<code>[=user navigation involvement/none=]</code>"). Then, update the paragraph talking about browser-UI initiated navigation as follows:

<blockquote>
  A user agent may provide various ways for the user to explicitly cause a browsing context to <a spec="HTML">navigate</a>, in addition to those defined in this specification.<ins> Such cases must set the <i>[=navigate/userInvolvement=]</i> argument to "<code>[=user navigation involvement/browser UI=]</code>".</ins>
</blockquote>

<p class="note">This infrastructure partially solves <a href="https://github.com/whatwg/html/issues/5381">whatwg/html#5381</a>, and it'd be ideal to update the \`<a http-header><code>Sec-Fetch-Site</code></a>\` spec at the same time.</p>

Modify the <a spec="HTML">navigate to a fragment</a> algorithm to take a new <var ignore>userInvolvement</var> argument. Then, update the call to it from <a spec="HTML">navigate</a> to set <i>[=navigate/userInvolvement=]</i> to this <var ignore>userInvolvement</var> value.

Modify the <a spec="HTML">traverse the history by a delta</a> argument to take an optional named argument <dfn for="traverse the history by a delta"><var ignore>userInvolvement</var></dfn> (default "<code>[=user navigation involvement/none=]</code>"). Then, update the paragraph talking about user-initiated navigation as follows:

<blockquote>
  When the user navigates through a [=browsing context=], e.g. using a browser's back and forward buttons, the user agent must <a spec="HTML">traverse the history by a delta</a> with a delta equivalent to the action specified by the user<del> and</del><ins>,</ins> the browsing context being operated on<ins>, and <i>[=traverse the history by a delta/userInvolvement=]</i> set to "<code>[=user navigation involvement/browser UI=]</code>"</ins>.
</blockquote>

<hr>

Modify the <a spec="HTML">follow the hyperlink</a> algorithm to take a new <var ignore>userInvolvement</var> argument. Then, update the call to it from <a spec="HTML">navigate</a> to set <i>[=navigate/userInvolvement=]</i> to this <var ignore>userInvolvement</var> value.

<div algorithm="area activation behavior">
  Modify the [=EventTarget/activation behavior=] of <{area}> elements by introducing the |event| argument and replacing the <a spec="HTML">follow the hyperlink</a> step with the following:

  1. Otherwise, <a spec="HTML">follow the hyperlink</a> created by <var ignore>element</var> with the [=Event/user navigation involvement=] for |event|.
</div>

<div algorithm="a activation behavior">
  Modify the [=EventTarget/activation behavior=] of <{a}> elements by replacing its <a spec="HTML">follow the hyperlink</a> step with the following:

  1. Otherwise, <a spec="HTML">follow the hyperlink</a> created by <var ignore>element</var> with the [=Event/user navigation involvement=] for <var ignore>event</var>.
</div>

Expand the section on "<a href="https://html.spec.whatwg.org/multipage/semantics.html#providing-users-with-a-means-to-follow-hyperlinks-created-using-the-link-element">Providing users with a means to follow hyperlinks created using the `link` element</a>" by adding the following sentence:

<blockquote><ins>Such invocations of <a spec="HTML">follow the hyperlink</a> algorithm must set the <i>[=navigate/userInvolvement=]</i> argument to "<code>[=user navigation involvement/browser UI=]</code>".</ins></blockquote>

<hr>

Modify the <a spec="HTML">plan to navigate</a> algorithm to take a <var ignore>userInvolvement</var> argument. Then, update the call to it from <a spec="HTML">navigate</a> to set <i>[=navigate/userInvolvement=]</i> to this <var ignore>userInvolvement</var> value.

Modify the <a spec="HTML" lt="submitted">submit</a> algorithm to take an optional <var ignore>userInvolvement</var> argument (default "<code>[=user navigation involvement/none=]</code>").  Have the <a spec="HTML" lt="submitted">submit</a> algorithm pass along its value to all invocations of <a spec="HTML">plan to navigate</a>.

Modify the definition of the [=EventTarget/activation behavior=] for <{input}> elements to take an <var ignore>event</var> argument. Then, pass along this argument to the invocation of the <a spec="HTML">input activation behavior</a>.

Modify the Submit Button state's <a spec="HTML">input activation behavior</a> by having it take an <var ignore>event<var> argument and pass along the [=Event/user navigation involvement=] for <var ignore>event</var> as the final argument when it calls <a spec="HTML" lt="submitted">submit</a>.

Modify the Image Button state's <a spec="HTML">input activation behavior</a> by having it take an <var ignore>event<var> argument and pass along the [=Event/user navigation involvement=] for <var ignore>event</var> as the final argument when it calls <a spec="HTML" lt="submitted">submit</a>.

Modify the <{button}> element's [=EventTarget/activation behavior=] by having it take an <var ignore>event</var> argument and, in the Submit Button case, to pass along the [=Event/user navigation involvement=] for <var ignore>event</var> as the final argument when it calls <a spec="HTML" lt="submitted">submit</a>.

Modify the no-<a spec="HTML">submit button</a> case for <a href="https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#implicit-submission">implicit form submission</a> to pass along "<code>[=user navigation involvement/activation=]</code>" as the final argument when it calls <a spec="HTML" lt="submitted">submit</a>.

<p class="note">The case of implicit submission when a submit button is present is automatically taken care of because it fires a (trusted) click event at the submit button.</p>

<h3 id="navigate-algorithm-patches">Navigation algorithm updates</h3>

With the above infrastructure in place, we can actually fire and handle the {{AppHistory/navigate}} event in the following locations:

<div algorithm="shared history push/replace steps">
  Modify the <a spec="HTML">shared history push/replace state steps</a> by inserting the following steps right before the step that runs the <a spec="HTML">URL and history update steps</a>.

  1. Let |appHistory| be <var ignore>history</var>'s [=relevant global object=]'s [=Window/app history=].
  1. Let |navigationType| be "{{AppHistoryNavigationType/push}}" if <var ignore>isPush</var> is true, and "{{AppHistoryNavigationType/replace}}" otherwise.
  1. Let |continue| be the result of [=firing a push or replace navigate event=] at |appHistory| with <i>[=fire a push or replace navigate event/navigationType=]</i> set to |navigationType|, <i>[=fire a push or replace navigate event/isSameDocument=]</i> set to true, <i>[=fire a push or replace navigate event/destinationURL=]</i> set to <var ignore>newURL</var>, and <i>[=fire a push or replace navigate event/classicHistoryAPISerializedData=]</i> set to <var ignore>serializedData</var>.
  1. If |continue| is false, return.
</div>

<div algorithm="navigate to a fragment">
  Modify the <a spec="HTML">navigate to a fragment</a> algorithm by prepending the following steps. Recall that per [[#user-initiated-patches]] we have introduced a |userInvolvement| argument.

  1. Let |appHistory| be the [=session history/current entry=]'s <a spec="HTML" for="session history entry">document</a>'s [=relevant global object=]'s [=Window/app history=].
  1. Let |navigationType| be the result of [=converting a history handling behavior to a navigation type=] given <var ignore>historyHandling</var>.
  1. Let |continue| be the result of [=firing a push or replace navigate event=] at |appHistory| given with <i>[=fire a push or replace navigate event/navigationType=]</i> set to |navigationType|, <i>[=fire a push or replace navigate event/isSameDocument=]</i> set to true, <i>[=fire a push or replace navigate event/userInvolvement=]</i> set to |userInvolvement|, and <i>[=fire a push or replace navigate event/destinationURL=]</i> set to <var ignore>url</var>.
  1. If |continue| is false, return.
</div>

<div algorithm="navigate" id="navigate-modifications">
  Modify the <a spec="HTML">navigate</a> algorithm to take an optional <dfn for="navigate">|appHistoryState|</dfn> argument (default null). Then, insert the following steps right before the step which goes [=in parallel=]. (Recall that per [[#user-initiated-patches]] we have introduced |userInvolvement| argument, and per [[#form-patches]] we have introduced an |entryList| argument.)

  1. Let |appHistory| be <var ignore>browsingContext</var>'s [=browsing context/active window=]'s [=Window/app history=].
  1. If all of the following are false:
    * <var ignore>historyHandling</var> is "<a for="history handling behavior">`entry update`</a>"
    * <var ignore>userInvolvement</var> is "<code>[=user navigation involvement/browser UI=]</code>"
    * <var ignore>browsingContext</var>'s [=active document=]'s [=Document/origin=] is not [=same origin-domain=] with the [=source browsing context=]'s [=active document=]'s [=Document/origin=]
    * <var ignore>browsingContext</var> is <a spec="HTML">still on its initial `about:blank` `Document`</a>
    * <var ignore>resource</var> is a [=request=], and <var ignore>resource</var>'s [=request/URL=]'s [=url/scheme=] is not a [=fetch scheme=]

    then:

      1. Let |navigationType| be the result of [=converting a history handling behavior to a navigation type=] given <var ignore>historyHandling</var>.
      1. Let |continue| be the result of [=firing a push or replace navigate event=] at |appHistory| with <i>[=fire a push or replace navigate event/navigationType=]</i> set to |navigationType|, <i>[=fire a push or replace navigate event/isSameDocument=]</i> set to false, <i>[=fire a push or replace navigate event/userInvolvement=]</i> set to |userInvolvement|, <i>[=fire a push or replace navigate event/formDataEntryList=]</i> set to |entryList|, <i>[=fire a push or replace navigate event/destinationURL=]</i> set to <var ignore>url</var>, and <i>[=fire a push or replace navigate event/state=]</i> set to |appHistoryState|.
      1. If |continue| is false, return.

    <p class="note">"<a for="history handling behavior">`entry update`</a>" is excluded since {{AppHistory/navigate}} would have fired earlier as part of <a spec="HTML">traversing the history by a delta</a>.

    <p class="note">"<code>[=user navigation involvement/browser UI=]</code>" or [=same origin-domain|cross origin-domain=] navigations that cause <a spec="HTML" lt="navigate to a fragment">fragment navigations</a> <em>do</em> fire the {{AppHistory/navigate}} event; those are handled as part of the <a spec="HTML">navigate to a fragment</a> algorithm called earlier in <a spec="HTML">navigate</a>, which is not guarded by this condition.
</div>

<div algorithm>
  To <dfn>convert a history handling behavior to a navigation type</dfn> given a <a spec="HTML">history handling behavior</a> |historyHandling|:

  1. [=Assert=]: |historyHandling| is not "<a spec="HTML" for="history handling behavior">`entry update`</a>".
  1. Return the result of switching on |historyHandling|:

    <dl class="switch">
    : "<a spec="HTML" for="history handling behavior">`reload`</a>"
    :: "{{AppHistoryNavigationType/reload}}"
    : "<a spec="HTML" for="history handling behavior">`replace`</a>"
    :: "{{AppHistoryNavigationType/replace}}"
    : "<a spec="HTML" for="history handling behavior">`default`</a>"
    :: "{{AppHistoryNavigationType/push}}"
</div>

<h3 id="navigate-event-traversal-patches">History traversal updates</h3>

<div algorithm="traverse the history by a delta">
  The <a spec="HTML">traverse the history by a delta</a> algorithm will be totally re-written as part of <a href="https://github.com/whatwg/html/pull/6315">the session history rewrite</a>. Here we reproduce the final version of the algorithm, after both that rewrite and with appropriate app history updates. Recall that per [[#user-initiated-patches]] we have introduced a |userInvolvement| argument, so the arguments are now |delta|, |source browsing context|, and |userInvolvement|.

  1. Let |traversable| be |source browsing context|'s [=browsing context/containing navigable=]'s [=navigable/traversable navigable=].
  1. Let |initiatorOrigin| be |source browsing context|'s [=active document=]'s [=Document/origin=].
  1. [=parallel queue/enqueue steps|Enqueue the following steps=] to |traversable|'s [=traversable navigable/session history traversal queue=]:
    1. Let |allSteps| be the result of [=traversable navigable/getting all history steps=] for |traversable|.
    1. Let |currentStepIndex| be the index of the [=traversable navigable/current session history step=] within |allSteps|.
    1. Let |targetStepIndex| be |currentStepIndex| plus |delta|.
    1. If |allSteps|[|targetStepIndex|] does not [=set/exist=], then return.
    1. [=Apply the history step=] |allSteps|[|targetStepIndex|] to |traversable| with true, <var ignore>step</var>, |initiatorOrigin|, and |userInvolvement|.
</div>

<div algorithm="apply the history step">
  Modify the <a spec="HTML">apply the history step</a> algorithm as follows. Inside the loop over each <var ignore>navigable</var> of <var ignore>toTraverse</var>, inside the task that is posted, after the check if |targetEntry|'s document is |previousDocument| that might abort the algorithm, add the following steps:

  1. [=Fire a traversal navigate event=] at |previousDocument|'s [=relevant global object=]'s [=Window/app history=] with <i>[=fire a traversal navigate event/destinationEntry=]</i> set to |targetEntry| and <i>[=fire a traversal navigate event/userInvolvement=]</i> set to <var ignore>userInvolvement</var>.
</div>

<h2 id="session-history-patches">Patches to session history</h2>

This section details monkeypatches to [[!HTML]] to track appropriate data for associating an {{AppHistory}} with a [=session history entry=].

<h3 id="session-history-new-she-fields">New [=session history entry=] items</h3>

Each [=session history entry=] gains the following new [=struct/items=]:

* <dfn for="session history entry">origin</dfn>, an [=origin=]

* <dfn for="session history entry">app history key</dfn>, a string, initially set to the result of [=generating a random UUID=]

* <dfn for="session history entry">app history id</dfn>, a string, initially set to the result of [=generating a random UUID=]

* <dfn for="session history entry">app history state</dfn>, which is [=serialized state=] or null, initially null

<h3 id="session-history-patches-key">Carrying over the app history key</h3>

<div algorithm="update the session history with the new page key patch">
  Update the <a spec="HTML">update the session history with the new page</a> algorithm's "<a for="history handling behavior">`replace`</a>" case by adding the following step after the construction of |newEntry|:

  1. If |newEntry|'s [=session history entry/origin=] is the [=same origin|same=] as |sessionHistory|'s [=session history/current entry=]'s [=session history entry/origin=], then set |newEntry|'s [=session history entry/app history key=] to |sessionHistory|'s [=session history/current entry=]'s [=session history entry/app history key=].
</div>

<h3 id="session-history-patches-state">Carrying over the app history state</h3>

<div algorithm="navigate to a fragment state patch">
  Update the <a spec="HTML">navigate to a fragment</a> algorithm by updating the step which creates and appends a new session history entry to carry over the [=session history entry/app history state=] from the [=session history/current entry=] as well.
</div>

<h3 id="session-history-patches-origin">Tracking the [=session history entry/origin=] member</h3>

Update the <a spec="HTML">update the session history with the new page</a> algorithm's "<a for="history handling behavior">`replace`</a>" and "<a for="history handling behavior">`default`</a>" cases to set <var ignore>newEntry</var>'s [=session history entry/origin=] to <var ignore>newDocument</var>'s [=Document/origin=] as part of its creation.

Update the <a spec="HTML">navigate to a fragment</a> algorithm to set the new [=session history entry=]'s [=session history entry/origin=] to the [=session history/current entry=]'s [=session history entry/document=]'s [=Document/origin=].

Update the <a spec="HTML">URL and history update steps</a> algorithm to set the new [=session history entry=]'s [=session history entry/origin=] to <var ignore>document</var>'s [=Document/origin=].

Potentially update the <a spec="HTML">traverse the history</a> algorithm to consult the new [=session history entry/origin=] field, instead of checking the [=session history entry/document=]'s [=Document/origin=], since the [=session history entry/document=] can disappear?? Needs further investigation.

<h3 id="session-history-patches-update">Updating the {{AppHistory}} object</h3>

<div algorithm="traverse the history update patch">
  Update the <a spec="HTML">traverse the history</a> algorithm by adding the following step before the final step which fires various events:

  1. [=AppHistory/Update the entries=] of <var ignore>newDocument</var>'s [=relevant global object=]'s [=Window/app history=].
</div>

<div algorithm="URL and history update steps update patch">
  Update the <a spec="HTML">URL and history update steps</a> by appending the following final step:

  1. [=AppHistory/Update the entries=] of <var ignore>document</var>'s [=relevant global object=]'s [=Window/app history=].
</div>

<p class="note">We do not [=AppHistory/update the entries=] when initially <a spec="HTML">creating a new browsing context</a>, as we intentionally don't want to include the initial `about:blank` {{Document}} in any app history entry list.

<h2 id="other-patches">Other patches</h2>

<h3 id="cancel-navigation">Canceling navigation and traversals</h3>

The existing HTML specification discusses canceling a navigation and traverals in a few places. However, the process is not very well-defined, and per <a href="https://github.com/whatwg/html/issues/6927">whatwg/html#6927</a>, is not very interoperable. We plan to make it more rigorous, after the <a href="https://github.com/whatwg/html/issues/5767">session history rewrite</a> lands.

Specifically, the spec uses a few phrases:

* "Cancel any existing but not-yet-mature attempts to navigate a [=browsing context=]", in the <a spec="HTML">navigate</a> algorithm and the <a spec="HTML">traverse the history by a delta</a> algorithm. This cancels any ongoing navigations, including history traversal navigations which have made their way back into the main event loop to perform an "<a for="history handling behavior">`entry update`</a>" navigation.

* "Cancel that navigation", in the <a spec="HTML">stop document loading</a> algorithm. This is likely supposed to work the same as the above?

* "Remove any tasks queued by the history traversal task source that are associated with any Document objects in the top-level browsing context's document family." This cancels queued-up traversals that have not yet made their way back to the main event loop. This is currently called from any same-document navigations, i.e. the <a spec="HTML">URL and history update steps</a> and <a spec="HTML">navigating to a fragment</a>, as well as as part of <a spec="HTML">traverse the history</a> for cross-document traversals.

<a href="https://github.com/whatwg/html/issues/6927">whatwg/html#6927</a> reveals that implementations don't really follow this breakdown. In particular, modulo one case in Firefox, traversals are only canceled as part of [=browsing context/discarding=] a browsing context.

That leaves us with two main operations: canceling not-yet-mature navigations, and dealing with browsing context discarding.

<hr>

App history introduces a new complication here, which is that a navigation might have <a spec="HTML">matured</a> but still be "ongoing", in the sense of [[#ongoing-state]]. That is, consider a case such as:

<xmp highlight="js">
appHistory.addEventListener("navigate", e => {
  e.transitionWhile(new Promise(r => setTimeout(r, 1_000)));
  e.signal.addEventListener("abort", () => { ... });
});

const p = appHistory.navigate("#1");

setTimeout(() => window.stop(), 500);
</xmp>

Without the {{AppHistory/navigate}} event handler, this kind of synchronous fragment navigation would be straightforward: it matures synchronously, and the {{Window/stop()}} call does nothing. But because we have used the {{AppHistory/navigate}} handler to indicate that the navigation is still ongoing, we want the {{Window/stop()}} call to [=finalize with an aborted navigation error|finalize that navigation with an aborted navigation error=], in particular causing `p` to reject and the {{AbortSignal/abort}} event to fire on `e.signal`.

<hr>

The integration is then as follows:

* Wherever the spec ends up canceling not-yet-mature navigations for a [=browsing context=] |bc|, we also [=inform app history about canceling navigation=] in |bc|. (Regardless of whether or not there are any not-yet-mature navigations still in flight.)

* When the spec [=browsing context/discards=] a [=browsing context=] |bc|, we also [=inform app history about browsing context discarding=] given |bc|. (Regardless of whether or not there are any not-yet-mature navigations still in flight, or any traversals queued up.)
