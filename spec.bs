<pre class="metadata">
Title: Navigation API
Shortname: navigation-api
Repository: WICG/navigation-api
Inline Github Issues: true
Group: WICG
Status: CG-DRAFT
Level: 1
URL: https://wicg.github.io/navigation-api/
Boilerplate: omit conformance, omit feedback-header
Editor: Domenic Denicola, Google https://www.google.com/, d@domenic.me, https://domenic.me/
Abstract: The navigation API provides a web application-focused way of managing same-origin same-frame history entries and navigations.
!Participate: <a href="https://github.com/WICG/navigation-api">GitHub WICG/navigation-api</a> (<a href="https://github.com/WICG/navigation-api/issues/new">new issue</a>, <a href="https://github.com/WICG/navigation-api/issues?state=open">open issues</a>)
!Commits: <a href="https://github.com/WICG/navigation-api/commits/main/spec.bs">GitHub spec.bs commits</a>
Complain About: accidental-2119 yes, missing-example-ids yes
Indent: 2
Default Biblio Status: current
Markup Shorthands: markdown yes
Assume Explicit For: yes
</pre>

<pre class="link-defaults">
spec: html; type: element; text: a
spec: html; type: element-attr; for: a; text: download
</pre>
<pre class="anchors">
spec: html; urlPrefix: https://html.spec.whatwg.org/multipage/
  type: dfn
    text: serialized state; url: history.html#serialized-state
    text: session history; url: history.html#session-history
    text: session history entry; url: history.html#session-history-entry
    for: session history
      text: current entry; url: history.html#current-entry
    for: session history entry
      text: document; url: history.html#she-document
      text: policy container; url: history.html#she-policy-container
      text: URL; url: history.html#she-url
      text: scroll position data; url: history.html#she-scroll-position
      text: scroll restoration mode; url: history.html#she-scroll-restoration-mode
    for: history handling behavior
      text: default; url: browsing-the-web.html#hh-default
      text: reload; url: browsing-the-web.html#hh-reload
      text: replace; url: browsing-the-web.html#hh-replace
      text: entry update; url: browsing-the-web.html#hh-entry-update
    for: navigate
      text: historyHandling; url: browsing-the-web.html#navigation-hh
      text: navigationType; url: browsing-the-web.html#navigation-navigationtype
      text: exceptionsEnabled; url: browsing-the-web.html#exceptions-enabled
    for: browsing context
      text: discard; url: window-object.html#a-browsing-context-is-discarded
  type: method
    for: Document; text: open(unused1, unused2); url: multipage/dynamic-markup-insertion.html#dom-document-open
  type: http-header
    text: Cross-Origin-Opener-Policy; url: multipage/iana.html#cross-origin-opener-policy-2
spec: html; urlPrefix: https://whatpr.org/html/6315/
  type: dfn
    text: session history traversal queue; for: traversable navigable; url: history.html#tn-session-history-traversal-queue
    text: current session history step; for: traversable navigable; url: history.html#tn-current-session-history-step
    text: get all history steps; for: traversable navigable; url: history.html#getting-all-history-steps
    text: step; for: session history entry; url: history.html#she-step
    text: apply the history step; url: history.html#apply-the-history-step
    text: containing navigable; for: browsing context; url: browsers.html#bc-navigable
    text: navigable; url: history.html#navigable
    text: URL and history update steps; url: browsers.html#url-and-history-update-steps
    text: shared history push/replace state steps; url: browsers.html#shared-history-push/replace-state-steps
    text: update document for history step application; url: history.html#update-document-for-history-step-application
    text: reactivate; url: history.html#reactivate-a-document
    text: navigate to a fragment; url: history.html#navigate-fragid
    text: navigation and traversal task source; url: webappapis.html#navigation-and-traversal-task-source
    for: URL and history update steps
      text: serializedData; url: history.html#uhus-serializeddata
      text: historyHandling; url: history.html#uhus-historyhandling
    for: navigable
      text: active window; url: browsers.html#nav-window
      text: active document; url: history.html#nav-document
      text: traversable navigable; url: history.html#nav-traversable
      text: current session history entry; url: history.html#nav-current-history-entry
      text: active session history entry; url: history.html#nav-active-history-entry
      text: get the session history entries; url: history.html#getting-session-history-entries
    text: navigable; for: Window; url: browsers.html#window-navigable
spec: uuid; type: dfn; urlPrefix: https://wicg.github.io/uuid/
  text: generate a random UUID; url: #dfn-generate-a-random-uuid
</pre>

<style>
.selected-text-file-an-issue {
  position: fixed;
  bottom: 0;
  right: 0;
  background: rgba(255, 255, 255, 0.8);
  font-size: smaller;
  padding: 4px 10px;
  z-index: 4;
}

dfn var {
  font-style: italic;
}

table {
  margin: 1em 0;
}

/* WHATWG-style <hr>s, instead of WICG-style. Specific selector is necessary to override WICG styles. */
:not(.head) > :not(.head) + hr {
  display: block;
  background: none;
  border: none;
  padding: 0;
  margin: 3em 0;
  height: auto;
}
:not(.head) > :not(.head) + hr::before {
  content: none;
}

/* domintro from https://resources.whatwg.org/standard.css */
.domintro {
  position: relative;
  color: green;
  background: #DDFFDD;
  margin: 2.5em 0 2em 0;
  padding: 1.5em 1em 0.5em 2em;
}

.domintro dt, .domintro dt * {
  color: black;
  font-size: inherit;
}
.domintro dd {
  margin: 0.5em 0 1em 2em; padding: 0;
}
.domintro dd p {
  margin: 0.5em 0;
}
.domintro::before {
  content: 'For web developers (non-normative)';
  background: green;
  color: white;
  padding: 0.15em 0.25em;
  font-style: normal;
  position: absolute;
  top: -0.8em;
  left: -0.8em;
}

/* .XXX from https://resources.whatwg.org/standard.css */
.XXX {
  color: #D50606;
  background: white;
  border: solid #D50606;
}
</style>

<script src="https://resources.whatwg.org/file-issue.js" async></script>

<h2 id="global">The {{Navigation}} class</h2>

<xmp class="idl">
partial interface Window {
  [Replaceable] readonly attribute Navigation navigation;
};
</xmp>

Each {{Window}} object has an associated <dfn for="Window">navigation API</dfn>, which is a new {{Navigation}} instance created alongside the {{Window}}.

The <dfn attribute for="Window">navigation</dfn> getter steps are to return [=this=]'s [=Window/navigation API=].

<xmp class="idl">
[Exposed=Window]
interface Navigation : EventTarget {
  sequence<NavigationHistoryEntry> entries();
  readonly attribute NavigationHistoryEntry? currentEntry;
  undefined updateCurrentEntry(NavigationUpdateCurrentEntryOptions options);
  readonly attribute NavigationTransition? transition;

  readonly attribute boolean canGoBack;
  readonly attribute boolean canGoForward;

  NavigationResult navigate(USVString url, optional NavigationNavigateOptions options = {});
  NavigationResult reload(optional NavigationReloadOptions options = {});

  NavigationResult traverseTo(DOMString key, optional NavigationOptions options = {});
  NavigationResult back(optional NavigationOptions options = {});
  NavigationResult forward(optional NavigationOptions options = {});

  attribute EventHandler onnavigate;
  attribute EventHandler onnavigatesuccess;
  attribute EventHandler onnavigateerror;
  attribute EventHandler oncurrententrychange;
};

dictionary NavigationUpdateCurrentEntryOptions {
  required any state;
};

dictionary NavigationOptions {
  any info;
};

dictionary NavigationNavigateOptions : NavigationOptions {
  any state;
  NavigationHistoryBehavior history = "auto";
};

dictionary NavigationReloadOptions : NavigationOptions {
  any state;
};

dictionary NavigationResult {
  Promise<NavigationHistoryEntry> committed;
  Promise<NavigationHistoryEntry> finished;
};

enum NavigationHistoryBehavior {
  "auto",
  "push",
  "replace"
};
</xmp>

Each {{Navigation}} object has an associated <dfn for="Navigation">entry list</dfn>, a [=list=] of {{NavigationHistoryEntry}} objects, initially empty.

Each {{Navigation}} object has an associated <dfn for="Navigation">current entry index</dfn>, an integer, initially &minus;1.

<div algorithm>
  A {{Navigation}} |navigation| <dfn for="Navigation">has entries and events disabled</dfn> if the following steps return true:

  1. Let |browsingContext| be |navigation|'s [=relevant global object=]'s [=Window/browsing context=].

  1. If |browsingContext| is null, then return true.

  1. If |browsingContext| is <a spec="HTML">still on its initial `about:blank` `Document`</a>, then return true.

  1. If |navigation|'s [=relevant global object=]'s [=associated Document=]'s [=Document/origin=] is [=opaque origin|opaque=], then return true.

  1. Return false.
</div>

<div algorithm>
  To <dfn for="Navigation">update the entries</dfn> for a {{Navigation}} instance |navigation| given a {{NavigationType}}-or-null |navigationTypeForCurrententrychange| and a boolean |deferNotification| (default false):

  1. If |navigation| [=Navigation/has entries and events disabled=], then:

    1. [=Assert=]: |navigation|'s [=Navigation/entry list=] [=list/is empty=].

    1. Return.

  1. Let |sessionHistory| be |navigation|'s [=relevant global object=]'s [=Window/browsing context=]'s [=session history=].

     <div class="note">
      <p>It is expected that this include session history entries in the entire [=browsing session=], including those in different <a spec="HTML">browsing context groups</a> due to \`<a http-header>`Cross-Origin-Opener-Policy`</a>\`-induced switches. This will be better-defined when <a href="https://github.com/whatwg/html/pull/6315">whatwg/html#6315</a> is finalized; see also <a href="https://github.com/whatwg/html/issues/6356">whatwg/html#6356</a> for some discussion of the impact of manual navigation on this "session" concept.

      <p>Note that it is OK to expose the data in these entries to the current page through {{NavigationHistoryEntry}} instances, since any [=session history entry/navigation API state=] will have been put there affirmatively, and the [=session history entry/URL=] is hidden appropriately by the {{NavigationHistoryEntry/url|url}} getter when the [=session history entry/document=] indicates that its URL is sensitive through the <a>"`no-referrer`"</a> or <a>"`origin`"</a> [=referrer policies=].
    </div>

  1. Let |navigationAPISHEs| be a new empty list.

  1. Let |oldCurrentNHE| be the [=Navigation/current entry=] of |navigation|.

  1. Let |currentSHE| be |sessionHistory|'s [=session history/current entry=].

  1. Let |backwardIndex| be the index of |currentSHE| within |sessionHistory|, minus 1.

  1. While |backwardIndex| > 0:

    1. Let |she| be |sessionHistory|[|backwardIndex|].

    1. If |she|'s [=session history entry/origin=] is [=same origin=] with |currentSHE|'s [=session history entry/origin=], then [=list/prepend=] |she| to |navigationAPISHEs|.

    1. Otherwise, [=iteration/break=].

    1. Set |backwardIndex| to |backwardIndex| &minus; 1.

  1. [=list/Append=] |currentSHE| to |navigationAPISHEs|.

  1. Let |forwardIndex| be the index of |currentSHE| within |sessionHistory|, plus 1.

  1. While |forwardIndex| &lt; |sessionHistory|'s [=list/size=]:

    1. Let |she| be |sessionHistory|[|forwardIndex|].

    1. If |she|'s [=session history entry/origin=] is [=same origin=] with |currentSHE|'s [=session history entry/origin=], then [=list/append=] |she| to |navigationAPISHEs|.

    1. Otherwise, [=iteration/break=].

    1. Set |forwardIndex| to |forwardIndex| + 1.

  1. Let |newCurrentIndex| be the index of |currentSHE| within |navigationAPISHEs|.

  1. Let |newEntryList| be an empty list.

  1. [=list/For each=] |oldNHE| of |navigation|'s [=Navigation/entry list=]:

    1. Set |oldNHE|'s [=NavigationHistoryEntry/index=] to &minus;1.

  1. Let |index| be 0.

  1. Let |disposedNHEs| be a [=list/clone=] of |navigation|'s [=Navigation/entry list=].

  1. [=list/For each=] |she| of |navigationAPISHEs|:

    1. If |navigation|'s [=Navigation/entry list=] [=list/contains=] a {{NavigationHistoryEntry}} |existingNHE| whose [=NavigationHistoryEntry/session history entry=] is |she|, then:

      1. [=list/Append=] |existingNHE| to |newEntryList|.

      1. [=list/Remove=] |existingNHE| from |disposedNHEs|.

    1. Otherwise:

      1. Let |newAHE| be a [=new=] {{NavigationHistoryEntry}} created in the [=relevant realm=] of |navigation|.

      1. Set |newAHE|'s [=NavigationHistoryEntry/session history entry=] to |she|.

      1. [=list/Append=] |newAHE| to |newEntryList|.

    1. Set |newEntryList|[|index|]'s [=NavigationHistoryEntry/index=] to |index|.

    1. Set |index| to |index| + 1.

  1. Set |navigation|'s [=Navigation/entry list=] to |newEntryList|.

  1. Set |navigation|'s [=Navigation/current entry index=] to |newCurrentIndex|.

  1. If |deferNotification| is true, then [=queue a global task=] on the [=navigation and traversal task source=] given |navigation|'s [=relevant global object=] to run the following steps. Otherwise, proceed onward to run these steps within the current task.

  1. If |navigation|'s [=Navigation/ongoing navigation=] is non-null, then [=navigation API method navigation/notify about the committed-to entry=] given |navigation|'s [=Navigation/ongoing navigation=] and the [=Navigation/current entry=] of |navigation|.

     <p class="note">It is important to do this before firing the {{NavigationHistoryEntry/dispose}} or {{Navigation/currententrychange}} events, since event handlers could start another navigation, or otherwise change the value of |navigation|'s [=Navigation/ongoing navigation=].

  1. If |oldCurrentNHE| is not null, and |oldCurrentNHE| does not equal |navigation|'s [=Navigation/current entry=], then:

    1. Assert: |navigationTypeForCurrententrychange| is not null.

    1. [=Fire an event=] named {{Navigation/currententrychange}} at |navigation| using {{NavigationCurrentEntryChangeEvent}}, with its {{NavigationCurrentEntryChangeEvent/navigationType}} attribute initialized to |navigationTypeForCurrententrychange| and its {{NavigationCurrentEntryChangeEvent/from}} initialized to |oldCurrentNHE|.

    <p class="note">|oldCurrentNHE| is null the first time [=Navigation/update the entries=] is run for a {{Navigation}} object, i.e. on new {{Document}} creation. |oldCurrentNHE| and |navigation|'s [=Navigation/current entry=] are equal if we are [=reactivating=] a page in the back/forward cache. In both cases, {{Navigation/currententrychange}} does not fire.

  1. [=list/For each=] |disposedAHE| of |disposedNHEs|:

    1. [=Fire an event=] named {{NavigationHistoryEntry/dispose}} at |disposedAHE|.
</div>

<div algorithm>
  To <dfn>get the navigation API history index</dfn> of a [=session history entry=] |she| within a {{Navigation}} |navigation|:

  1. Let |index| be 0.

  1. [=list/For each=] |ahe| of |navigation|'s [=Navigation/entry list=]:

    1. If |ahe|'s [=NavigationHistoryEntry/session history entry=] is equal to |she|, then return |index|.

    1. Increment |index| by 1.

  1. [=Assert=]: this step is never reached.
</div>

<h3 id="entries-api">Introspecting the navigation API history entry list</h3>

<dl class="domintro non-normative">
  <dt><code><var ignore>entries</var> = {{Window/navigation}}.{{Navigation/entries()|entries}}()</code>
  <dd>
    <p>Returns an array of {{NavigationHistoryEntry}} instances representing the current navigation history entry list, i.e. all session history entries for this {{Window}} that are [=same origin=] and contiguous to the current session history entry.
  </dd>

  <dt><code>{{Window/navigation}}.{{Navigation/canGoBack}}</code>
  <dd>
    <p>Returns true if the current {{NavigationHistoryEntry}} is not the first one in the navigation history entry list.
  </dd>

  <dt><code>{{Window/navigation}}.{{Navigation/canGoForward}}</code>
  <dd>
    <p>Returns true if the current {{NavigationHistoryEntry}} is not the last one in the navigation history entry list.
  </dd>
</dl>

<div algorithm>
  The <dfn method for="Navigation">entries()</dfn> method steps are:

  1. If [=this=] [=Navigation/has entries and events disabled=], then return the empty list.

  1. Return [=this=]'s [=Navigation/entries list=].
</div>

<div algorithm>
  The <dfn attribute for="Navigation">canGoBack</dfn> getter steps are:

  1. If [=this=] [=Navigation/has entries and events disabled=], then return false.

  1. [=Assert=]: [=this=]'s [=Navigation/current entry index=] is not &minus;1.

  1. If [=this=]'s [=Navigation/current entry index=] is 0, then return false.

  1. Return true.
</div>

<div algorithm>
  The <dfn attribute for="Navigation">canGoForward</dfn> getter steps are:

  1. If [=this=] [=Navigation/has entries and events disabled=], then return false.

  1. [=Assert=]: [=this=]'s [=Navigation/current entry index=] is not &minus;1.

  1. If [=this=]'s [=Navigation/current entry index=] is equal to [=this=]'s [=Navigation/entry list=]'s [=list/size=] &minus; 1, then return false.

  1. Return true.
</div>

<h3 id="current-entry">The current entry</h3>

<xmp class="idl">
[Exposed=Window]
interface NavigationCurrentEntryChangeEvent : Event {
  constructor(DOMString type, NavigationCurrentEntryChangeEventInit eventInit);

  readonly attribute NavigationType? navigationType;
  readonly attribute NavigationHistoryEntry from;
};

dictionary NavigationCurrentEntryChangeEventInit : EventInit {
  NavigationType? navigationType = null;
  required NavigationHistoryEntry destination;
};
</xmp>

<dl class="domintro non-normative">
  <dt><code>{{Window/navigation}}.{{Navigation/currentEntry}}</code>
  <dd>
    <p>The current {{NavigationHistoryEntry}}.
  </dd>

  <dt><code>{{Window/navigation}}.{{Navigation/updateCurrentEntry()|updateCurrentEntry}}({ {{NavigationUpdateCurrentEntryOptions/state}} })</code>
  <dd>
    <p>Update the [=session history entry/navigation API state=] of the current {{NavigationHistoryEntry}}, without performing a navigation like {{Navigation/reload()|navigation.reload()}} would do.

    <p>This method is best used to capture updates to the page that have already happened, and need to be reflected into the navigation API state. For cases where the state update is meant to drive a page update, instead use {{Navigation/navigate()|navigation.navigate()}} or {{Navigation/reload()|navigation.reload()}}.
  </dd>
</dl>

<div algorithm>
  The <dfn for="Navigation">current entry</dfn> for a {{Navigation}} |navigation| is the result running of the following algorithm:

  1. If |navigation| [=Navigation/has entries and events disabled=], then return null.

  1. [=Assert=]: |navigation|'s [=Navigation/current entry index=] is not &minus;1.

  1. Return |navigation|'s [=Navigation/entry list=][|navigation|'s [=Navigation/current entry index=]].
</div>

<p algorithm>
  The <dfn attribute for="Navigation">currentEntry</dfn> getter steps are to return the [=Navigation/current entry=] for [=this=].
</p>

<div algorithm>
  The <dfn method for="Navigation">updateCurrentEntry(|options|)</dfn> method steps are:

  1. Let |current| be the [=Navigation/current entry=] for [=this=].

  1. If |current| is null, then throw an "{{InvalidStateError}}" {{DOMException}}.

  1. Let |serializedState| be [$StructuredSerializeForStorage$](|options|["{{NavigationUpdateCurrentEntryOptions/state}}"]), rethrowing any exceptions.

  1. Set |current|'s [=NavigationHistoryEntry/session history entry=]'s [=session history entry/navigation API state=] to |serializedState|.

  1. [=Fire an event=] named {{Navigation/currententrychange}} at [=this=] using {{NavigationCurrentEntryChangeEvent}}, with its {{NavigationCurrentEntryChangeEvent/navigationType}} attribute initialized to null and its {{NavigationCurrentEntryChangeEvent/from}} initialized to |current|.
</div>

<h3 id="ongoing-state">Ongoing navigation tracking</h3>

<xmp class="idl">
[Exposed=Window]
interface NavigationTransition {
  readonly attribute NavigationType navigationType;
  readonly attribute NavigationHistoryEntry from;
  readonly attribute Promise<undefined> finished;

  NavigationResult rollback(optional NavigationOptions options = {});
};
</xmp>

<dl class="domintro">
  <dt><code>{{Window/navigation}}.{{Navigation/transition}}</code>
  <dd>
    <p>A {{NavigationTransition}} object representing any ongoing navigation that hasn't yet reached the {{Navigation/navigatesuccess}} or {{Navigation/navigateerror}} stage, if one exists, or null if there is no such transition ongoing.

    <p>Since {{Navigation/currentEntry|navigation.currentEntry}} (and other properties like {{Location/href|location.href}}) are updated immediately upon navigation, this {{Navigation/transition|navigation.transition}} property is useful for determining when such navigations are not yet fully settled, according to any promises passed to {{NavigateEvent/transitionWhile()|event.transitionWhile()}}.
  </dd>

  <dt><code>{{Window/navigation}}.{{Navigation/transition}}.{{NavigationTransition/navigationType}}</code></dt>
  <dd>
    <p>One of "{{NavigationType/reload}}", "{{NavigationType/push}}", "{{NavigationType/replace}}", or "{{NavigationType/traverse}}", indicating what type of navigation this transition is for.
  </dd>

  <dt><code>{{Window/navigation}}.{{Navigation/transition}}.{{NavigationTransition/from}}</code></dt>
  <dd>
    <p>The {{NavigationHistoryEntry}} from which the transition is coming. This can be useful to compare against {{Navigation/currentEntry|navigation.currentEntry}}.
  </dd>

  <dt><code>{{Window/navigation}}.{{Navigation/transition}}.{{NavigationTransition/finished}}</code></dt>
  <dd>
    <p>A promise which fulfills at the same time the {{Navigation/navigatesuccess}} event fires, or rejects at the same time the {{Navigation/navigateerror}} fires.
  </dd>

  <dt><code>{ {{NavigationResult/committed}}, {{NavigationResult/finished}} } = {{Window/navigation}}.{{Navigation/transition}}.{{NavigationTransition/rollback(options)|rollback}}()</code></dt>
  <dt><code>{ {{NavigationResult/committed}}, {{NavigationResult/finished}} } = {{Window/navigation}}.{{Navigation/transition}}.{{NavigationTransition/rollback(options)|rollback}}({ {{NavigationOptions/info}} })</code></dt>
  <dd>
    <p>Aborts the ongoing navigation, and immediately performs another navigation which is the logical opposite of the one represented by this transition:

    * If {{NavigationTransition/navigationType}} is "{{NavigationType/reload}}", it will perform a replace navigation that resets the navigation API state to that found in the {{NavigationHistoryEntry}} stored in {{NavigationTransition/from}}.

    * If {{NavigationTransition/navigationType}} is "{{NavigationType/push}}", it will traverse to the {{NavigationHistoryEntry}} stored in {{NavigationTransition/from}}, and then delete the previously-current {{NavigationHistoryEntry}} from the navigation history entry list, so that it cannot be reached with {{Navigation/forward()|navigation.forward()}} or the forward button.

    * If {{NavigationTransition/navigationType}} is "{{NavigationType/replace}}", it will perform another replace navigation that resets the URL and navigation API state to those found in the {{NavigationHistoryEntry}} stored in {{NavigationTransition/from}}.

    * If {{NavigationTransition/navigationType}} is "{{NavigationType/traverse}}", it will traverse to the {{NavigationHistoryEntry}} stored in {{NavigationTransition/from}}. (This could involve going either forward or backward in the navigation history entry list.)

    <p>Aborting the ongoing navigation will cause {{Navigation/navigateerror}} to fire, any {{NavigateEvent/signal|navigateEvent.signal}} instances to fire {{AbortSignal/abort}}, and any relevant promises to reject. This includes {{NavigationTransition/finished|navigation.transition.finished}}.

    <p>Then, the rollback navigation described above starts. This will fire a {{Navigation/navigate}} event, and reset {{Navigation/transition|navigation.transition}} to a new {{NavigationTransition}} instance. The {{NavigationOptions/info}} option, if provided, will populate the {{NavigateEvent/info}} property of the fired event.

    <p>This method can only be called while the transition is still ongoing, i.e. while {{Navigation/transition|navigation.transition}} equals this {{NavigationTransition}} object. Calling it afterward will cause both returned promises rejected with an "{{InvalidStateError}}" {{DOMException}}.
  </dd>
</dl>

A {{Navigation}} has a <dfn for="Navigation">transition</dfn>, which is a {{NavigationTransition}} or null.

The <dfn attribute for="Navigation">transition</dfn> getter steps are to return [=this=]'s [=Navigation/transition=].

<hr>

A {{NavigationTransition}} has an associated <dfn for="NavigationTransition">navigation type</dfn>, which is a {{NavigationType}}.

A {{NavigationTransition}} has an associated <dfn for="NavigationTransition">from entry</dfn>, which is a {{NavigationHistoryEntry}}.

A {{NavigationTransition}} has an associated <dfn for="NavigationTransition">finished promise</dfn>, which is an {{Promise}}.

The <dfn attribute for="NavigationTransition">navigationType</dfn> getter steps are to return [=this=]'s [=NavigationTransition/navigation type=].

The <dfn attribute for="NavigationTransition">from</dfn> getter steps are to return [=this=]'s [=NavigationTransition/from entry=].

The <dfn attribute for="NavigationTransition">finished</dfn> getter steps are to return [=this=]'s [=NavigationTransition/finished promise=].

<div algorithm>
  The <dfn method for="NavigationTransition">rollback(|options|)</dfn> method steps are:

  1. TODO use |options|.
</div>

<hr>

During any given navigation, the {{Navigation}} object needs to keep track of the following:

<table class="data">
  <caption>For all navigations
  <thead>
    <tr>
      <th>State
      <th>Duration
      <th>Explanation
  <tbody>
    <tr>
      <td>The {{NavigateEvent}}
      <td>For the duration of event firing
      <td>So that if the navigation is canceled while the event is firing, we can [=Event/canceled flag|cancel=] the event.
    <tr>
      <td>The event's {{NavigateEvent/signal}}
      <td>Until all promises passed to {{NavigateEvent/transitionWhile()}} have settled
      <td>So that if the navigation is canceled, we can [=AbortSignal/signal abort=].
    <tr>
      <td>Whether a new element was <a spec="HTML" lt="focusing steps">focused</a>
      <td>Until all promises passed to {{NavigateEvent/transitionWhile()}} have settled
      <td>So that if one was, focus is not [=potentially reset the focus|reset=]
    <tr>
      <td>The {{NavigationHistoryEntry}} being navigated to
      <td>From when it is determined, until all promises passed to {{NavigateEvent/transitionWhile()}} have settled
      <td>So that we know what to [=resolve=] any {{NavigationResult/committed}} and {{NavigationResult/finished}} promises with.
    <tr>
      <td>Any {{NavigationResult/finished}} {{Promise}} that was returned
      <td>Until all promises passed to {{NavigateEvent/transitionWhile()}} have settled
      <td>So that we can [=resolve=] or [=reject=] it appropriately.
</table>

<table class="data">
  <caption>For non-"{{NavigationType/traverse}}" navigations
  <thead>
    <tr>
      <th>State
      <th>Duration
      <th>Explanation
  <tbody>
    <tr>
      <td>Any {{NavigationNavigateOptions/state}}
      <td>For the duration of event firing
      <td>So that we can update the current entry's state after the event successfully finishes firing without being canceled.
</table>

<table class="data">
  <caption>For "{{NavigationType/traverse}}" navigations
  <thead>
    <tr>
      <th>State
      <th>Duration
      <th>Explanation
  <tbody>
    <tr>
      <td>Any {{NavigationOptions/info}}
      <td>Until the task is queued to fire the {{Navigation/navigate}} event
      <td>So that we can use it to fire the {{Navigation/navigate}} event after the the trip through the [=traversable navigable/session history traversal queue=].
    <tr>
      <td>Any {{NavigationResult/committed}} {{Promise}} that was returned
      <td>Until the [=session history=] is updated (inside that same task)
      <td>So that we can [=resolve=] or [=reject=] it appropriately.
    <tr>
      <td>Whether {{NavigateEvent/transitionWhile()}} was called
      <td>Until the [=session history=] is updated (inside that same task)
      <td>So that we can suppress the normal scroll restoration logic in favor of the chosen {{NavigationTransitionWhileOptions/scrollRestoration}} option value.
</table>

Furthermore, we need to account for the fact that there might be multiple traversals queued up, e.g. via

<xmp highlight="js">
const key1 = navigation.entries()[navigation.currentEntry.index - 1].key;
const key2 = navigation.entries()[navigation.currentEntry.index + 1].key;

navigation.traverseTo(key1); // intentionally no await
navigation.traverseTo(key2);
</xmp>

And, while non-traversal navigations cannot be queued in the same way since a new non-traversal navigation cancels an old one, we need to keep some state around so that we can properly cancel the old one. That is, given

<xmp highlight="js">
const p1 = navigation.navigate(url1).finished;
const p2 = navigation.navigate(url2).finished;
</xmp>

we need to ensure that when navigating to `url2`, we still have the {{Promise}} `p1` around so that we can reject it. We can't just get rid of any ongoing navigation promises the moment the second call to {{Navigation/navigate()}} happens.

We also need to ensure that, if we start a new navigation, navigations which have gotten as far as firing {{Navigation/navigate}} events, but not yet as far as firing {{Navigation/navigatesuccess}} or {{Navigation/navigateerror}}, get [=finalized with an aborted navigation error=].

We end up accomplishing all this using the following setup:

Each {{Navigation}} object has an associated <dfn for="Navigation">ongoing navigate event</dfn>, a {{NavigateEvent}} or null, initially null.

Each {{Navigation}} object has an associated <dfn for="Navigation">ongoing navigation signal</dfn>, which is an {{AbortSignal}} or null, initially null.

Each {{Navigation}} object has an associated <dfn for="Navigation">focus changed during ongoing navigation</dfn>, which is a boolean, initially false.

Each {{Navigation}} object has an associated <dfn for="Navigation">suppress normal scroll restoration during ongoing navigation</dfn>, which is a boolean, initially false.

Each {{Navigation}} object has an associated <dfn for="Navigation">ongoing navigation</dfn>, which is a [=navigation API method navigation=] or null, initially null.

Each {{Navigation}} object has an associated <dfn for="Navigation">upcoming non-traverse navigation</dfn>, which is a [=navigation API method navigation=] or null, initially null.

Each {{Navigation}} object has an associated <dfn for="Navigation">upcoming traverse navigations</dfn>, which is a [=map=] from strings to [=navigation API method navigations=], initially empty.

An <dfn>navigation API method navigation</dfn> is a [=struct=] with the following [=struct/items=]:

* An <dfn for="navigation API method navigation">navigation object</dfn>, a {{Navigation}}
* A <dfn for="navigation API method navigation">key</dfn>, a string or null
* An <dfn for="navigation API method navigation">info</dfn>, a JavaScript value
* An <dfn for="navigation API method navigation">serialized state</dfn>, a [=serialized state=] or null
* A <dfn for="navigation API method navigation">committed-to entry</dfn>, a {{NavigationHistoryEntry}} or null
* A <dfn for="navigation API method navigation">committed promise</dfn>, a {{Promise}}
* A <dfn for="navigation API method navigation">finished promise</dfn>, a {{Promise}}

<p class="note">We need to store the [=Navigation/ongoing navigation signal=], [=Navigation/focus changed during ongoing navigation=], and [=Navigation/suppress normal scroll restoration during ongoing navigation=] separately from the [=navigation API method navigation=] struct, since it needs to be tracked even for navigations that are not via the navigation API.

<div algorithm>
  To <dfn for="Navigation">set the upcoming non-traverse navigation</dfn> given a {{Navigation}} |navigation|, a JavaScript value |info|, and a [=serialized state=]-or-null |serializedState|:

  1. Let |committedPromise| and |finishedPromise| be [=a new promise|new promises=] created in |navigation|'s [=relevant Realm=].

  1. [=Mark as handled=] |finishedPromise|.

     <div class="note" id="note-finished-promise-mark-as-handled">
      The web developer doesn't necessarily care about |finishedPromise| being rejected:

      * They might only care about |committedPromise|.

      * They could be doing multiple synchronous navigations within the same task, in which case all but the last will be aborted (causing their |finishedPromise| to reject). This could be an application bug, but also could just be an emergent feature of disparate parts of the application overriding each others' actions.

      * They might prefer to listen to other transition-failure signals instead of |finishedPromise|, e.g., the {{Navigation/navigateerror}} event, or the {{NavigationTransition/finished|navigation.transition.finished}} promise.

      As such, we mark it as handled to ensure that it never triggers {{Window/unhandledrejection}} events.
     </div>

  1. Let |ongoingNavigation| be a [=navigation API method navigation=] whose [=navigation API method navigation/navigation object=] is |navigation|, [=navigation API method navigation/key=] is null, [=navigation API method navigation/info=] is |info|, [=navigation API method navigation/serialized state=] is |serializedState|, [=navigation API method navigation/committed-to entry=] is null, [=navigation API method navigation/committed promise=] is |committedPromise|, and [=navigation API method navigation/finished promise=] is |finishedPromise|.

  1. [=Assert=]: |navigation|'s [=Navigation/upcoming non-traverse navigation=] is null.

  1. Set |navigation|'s [=Navigation/upcoming non-traverse navigation=] to |ongoingNavigation|.

  1. Return |ongoingNavigation|.
</div>

<div algorithm>
  To <dfn for="Navigation">set an upcoming traverse navigation</dfn> given a {{Navigation}} |navigation|, a string |key|, and a JavaScript value |info|:

  1. Let |committedPromise| and |finishedPromise| be [=a new promise|new promises=] created in |navigation|'s [=relevant Realm=].

  1. [=Mark as handled=] |finishedPromise|.

     <p class="note">See <a href="#note-finished-promise-mark-as-handled">the previous discussion</a> as to why this is done.</p>

  1. Let |traversal| be a [=navigation API method navigation=] whose whose [=navigation API method navigation/navigation object=] is |navigation|, [=navigation API method navigation/key=] is |key|, [=navigation API method navigation/info=] is |info|, [=navigation API method navigation/serialized state=] is null, [=navigation API method navigation/committed-to entry=] is null, [=navigation API method navigation/committed promise=] is |committedPromise|, and [=navigation API method navigation/finished promise=] is |finishedPromise|.

  1. Set |navigation|'s [=Navigation/upcoming traverse navigations=][|key|]  to |traversal|.

  1. Return |traversal|.
</div>

<div algorithm>
  To <dfn for="Navigation">promote the upcoming navigation to ongoing</dfn> given a {{Navigation}} |navigation| and a string-or-null |destinationKey|:

  1. [=Assert=]: |navigation|'s [=Navigation/ongoing navigation=] is null.

  1. If |destinationKey| is not null, then:

    1. [=Assert=]: |navigation|'s [=Navigation/upcoming non-traverse navigation=] is null.

    1. If |navigation|'s [=Navigation/upcoming traverse navigations=][|destinationKey|] [=map/exists=], then:

      1. Set |navigation|'s [=Navigation/ongoing navigation=] to |navigation|'s [=Navigation/upcoming traverse navigations=][|destinationKey|].

      1. [=map/Remove=] |navigation|'s [=Navigation/upcoming traverse navigations=][|destinationKey|].

  1. Otherwise,

    1. Set |navigation|'s [=Navigation/ongoing navigation=] to |navigation|'s [=Navigation/upcoming non-traverse navigation=].

    1. Set |navigation|'s [=Navigation/upcoming non-traverse navigation=] to null.
</div>

<div algorithm>
  To <dfn for="navigation API method navigation">clean up</dfn> a [=navigation API method navigation=] |navigation|:

  1. Let |navigation| be |navigation|'s [=navigation API method navigation/navigation object=].

  1. If |navigation|'s [=Navigation/ongoing navigation=] is |navigation|, then set |navigation|'s [=Navigation/ongoing navigation=] to null.

  1. Otherwise,

    1. [=Assert=]: |navigation|'s [=navigation API method navigation/key=] is not null.

    1. [=Assert=]: |navigation|'s [=Navigation/upcoming traverse navigations=][|navigation|'s [=navigation API method navigation/key=]] [=map/exists=].

    1. [=map/Remove=] |navigation|'s [=Navigation/upcoming traverse navigations=][|navigation|'s [=navigation API method navigation/key=]].
</div>

<div algorithm>
  To <dfn for="navigation API method navigation">notify about the committed-to entry</dfn> given a [=navigation API method navigation=] |navigation| and a {{NavigationHistoryEntry}} |entry|:

  1. Set |navigation|'s [=navigation API method navigation/committed-to entry=] to |entry|.

  1. [=Resolve=] |navigation|'s [=navigation API method navigation/committed promise=] with |entry|.

     <p class="note">After this point, |navigation|'s [=navigation API method navigation/committed promise=] is only needed in cases where it has not yet been returned to author code. Implementations might want to clear it out to avoid keeping it alive for the lifetime of the [=navigation API method navigation=].
</div>

<div algorithm>
  To <dfn for="navigation API method navigation">resolve the finished promise</dfn> for a [=navigation API method navigation=] |navigation|:

  1. If |navigation|'s [=navigation API method navigation/finished promise=] is null, then return.

  1. [=Resolve=] |navigation|'s [=navigation API method navigation/finished promise=] with its [=navigation API method navigation/committed-to entry=].

  1. [=navigation API method navigation/Clean up=] |navigation|.
</div>

<div algorithm>
  To <dfn for="navigation API method navigation">reject the finished promise</dfn> for a [=navigation API method navigation=] |navigation| with a JavaScript value |exception|:

  1. If |navigation|'s [=navigation API method navigation/finished promise=] is null, then return.

  1. [=Reject=] |navigation|'s [=navigation API method navigation/finished promise=] with |exception|.

  1. If |navigation|'s [=navigation API method navigation/committed promise=] is not null, then [=reject=] |navigation|'s [=navigation API method navigation/committed promise=] with |exception|.

  1. [=navigation API method navigation/Clean up=] |navigation|.
</div>

<h3 id="global-navigate">Navigating</h3>

<dl class="domintro non-normative">
  <dt><code>{ {{NavigationResult/committed}}, {{NavigationResult/finished}} } = {{Window/navigation}}.{{Navigation/navigate(url, options)|navigate}}(<var ignore>url</var>)</code>
  <dt><code>{ {{NavigationResult/committed}}, {{NavigationResult/finished}} } = {{Window/navigation}}.{{Navigation/navigate(url, options)|navigate}}(<var ignore>url</var>, <var ignore>options</var>)</code>
  <dd>
    <p>Navigates the current page to the given <var ignore>url</var>. <var ignore>options</var> can contain the following values:

    * {{NavigationNavigateOptions/history}} can be set to "{{NavigationHistoryBehavior/replace}}" to replace the current session history entry, instead of pushing a new one.
    * {{NavigationOptions/info}} can be set to any value; it will populate the {{NavigateEvent/info}} property of the corresponding {{Navigation/navigate}} event.
    * {{NavigationNavigateOptions/state}} can be set to any [=serializable object|serializable=] value; it will populate the state retrieved by {{NavigationHistoryEntry/getState()|navigation.currentEntry.getState()}} once the navigation completes, for same-document navigations. (It will be ignored for navigations that end up cross-document.)

    <p>By default this will perform a full navigation (i.e., a cross-document navigation, unless the given URL differs only in a fragment from the current one). The {{Navigation/navigate}} event's {{NavigateEvent/transitionWhile()}} method can be used to convert it into a same-document navigation.

    <p>The returned promises will behave as follows:

    * For navigations that get aborted, both promises will reject with an "{{AbortError}}" {{DOMException}}.
    * For same-document navigations created by using the {{Navigation/navigate}} event's {{NavigateEvent/transitionWhile()}} method, {{NavigationResult/committed}} will fulfill immediately, and {{NavigationResult/finished}} will fulfill or reject according to the promises passed to {{NavigateEvent/transitionWhile()}}.
    * For other same-document navigations (e.g., non-intercepted [=navigate to a fragment|fragment navigations=], both promises will fulfill immediately.
    * For cross-document navigations, or navigations that result in 204/205 [=response/statuses=] or `Content-Disposition: attachment` header fields from the server (and thus do not actually navigate), both promises will never settle.

    <p>In all cases, when the returned promises fulfill, it will be with the {{NavigationHistoryEntry}} that was navigated to.
  </dd>

  <dt><code>{ {{NavigationResult/committed}}, {{NavigationResult/finished}} } = {{Window/navigation}}.{{Navigation/reload(options)|reload}}(<var ignore>options</var>)</code>
  <dd>
    <p>Reloads the current page. The {{NavigationOptions/info}} and {{NavigationReloadOptions/state}} options behave as described above.

    <p>The default behavior of performing a from-network-or-cache reload of the current page can be overriden by using the {{Navigation/navigate}} event's {{NavigateEvent/transitionWhile()}} method. Doing so will mean this call only updates state or passes along the appropriate {{NavigationOptions/info}}, plus performing whatever actions the {{Navigation/navigate}} event handler sees fit to carry out.

    <p>The returned promises will behave as follows:

    * If the reload is aborted, both promises will reject with an "{{AbortError}}" {{DOMException}}.
    * If the reload is intercepted by using the {{Navigation/navigate}} event's {{NavigateEvent/transitionWhile()}} method, {{NavigationResult/committed}} will fulfill immediately, and {{NavigationResult/finished}} will fulfill or reject according to the promises passed to {{NavigateEvent/transitionWhile()}}.
    * Otherwise, both promises will never settle.
  </dd>
</dl>

<!-- The following algorithms have several steps that would benefit from https://github.com/heycam/webidl/issues/983. -->

<div algorithm>
  The <dfn method for="Navigation">navigate(|url|, |options|)</dfn> method steps are:

  1. <a spec="HTML" lt="parse a URL">Parse</a> |url| relative to [=this=]'s [=relevant settings object=]. If that returns failure, then return [=an early error result=] for a "{{SyntaxError}}" {{DOMException}}. Otherwise, let |urlRecord| be the <a spec="HTML">resulting URL record</a>.

  1. Let |document| be [=this=]'s [=relevant global object=]'s [=associated document=].

  1. If |options|["{{NavigationNavigateOptions/history}}"] is "{{NavigationHistoryBehavior/push}}", and any of the following are true:

     * |document|'s <a spec="HTML">is initial about:blank</a> is true;
     * |document| is not <a spec="HTML">completely loaded</a>;
     * |url| equals |document|'s [=Document/URL=]; or
     * |url|'s [=url/scheme=] is "`javascript`"

     then return [=an early error result=] for a "{{NotSupportedError}}" {{DOMException}}.

     <div class="note">
      <p>These are the conditions under which a push navigation will be converted into a replace navigation by the <a spec="HTML">navigate</a> algorithm or by the below step. If the developer explicitly requested a push, we fail to let them know it won't happen.

      <p>In the future, we could consider loosening some of these conditions, e.g., allowing explicitly-requested push navigations to the current URL or before the document is completely loaded.
     </div>

  1. Let |serializedState| be null.

  1. If |options|["{{NavigationNavigateOptions/state}}"] [=map/exists=], then set |serializedState| to [$StructuredSerializeForStorage$](|options|["{{NavigationNavigateOptions/state}}"]). If this throws an exception, then return [=an early error result=] for that exception.

     <p class="note">It is important to perform this step early, since serialization can invoke web developer code, which in turn might change the state checked in later steps.</p>

  1. Let |info| be |options|["{{NavigationOptions/info}}"] if it exists; otherwise, undefined.

  1. Let |historyHandling| be "<a for="history handling behavior">`replace`</a>" if |options|["{{NavigationNavigateOptions/history}}"] is "{{NavigationHistoryBehavior/replace}}" or if |document| is not <a spec="HTML">completely loaded</a>; otherwise, "<a for="history handling behavior">`default`</a>".

  1. Return the result of [=performing a non-traverse navigation API navigation=] given [=this=], |urlRecord|, |serializedState|, |info|, and |historyHandling|.
</div>

<div algorithm>
  The <dfn method for="Navigation">reload(|options|)</dfn> method steps are:

  1. Let |urlRecord| be [=this=]'s [=relevant global object=]'s [=active document=]'s [=Document/URL=].

  1. Let |serializedState| be null.

  1. If |options|["{{NavigationReloadOptions/state}}"] [=map/exists=], then set |serializedState| to [$StructuredSerializeForStorage$](|options|["{{NavigationReloadOptions/state}}"]). If this throws an exception, then return [=an early error result=] for that exception.

     <p class="note">It is important to perform this step early, since serialization can invoke web developer code, which in turn might change the state checked in later steps.</p>

  1. Otherwise,

    1. Let |current| be the [=Navigation/current entry=] of [=this=].

    1. If |current| is not null, then set |serializedState| to |current|'s [=session history entry/navigation API state=].

  1. Let |info| be |options|["{{NavigationOptions/info}}"] if it exists; otherwise, undefined.

  1. Return the result of [=performing a non-traverse navigation API navigation=] given [=this=], |urlRecord|, |serializedState|, |info|, and "<a for="history handling behavior">`reload`</a>".
</div>

<div algorithm>
  To <dfn>perform a non-traverse navigation API navigation</dfn> given a {{Navigation}} object |navigation|, a [=URL=] |url|, a [=serialized state=]-or-null |serializedState|, a JavaScript value |info|, and a <a spec="HTML">history handling behavior</a> |historyHandling|:

  1. If |navigation|'s [=relevant global object=]'s [=associated Document=] is not [=Document/fully active=], then return [=an early error result=] for an "{{InvalidStateError}}" {{DOMException}}.

  1. If |navigation|'s [=relevant global object=]'s [=associated Document=]'s <a spec="HTML">unload counter</a> is greater than 0, then return [=an early error result=] for an "{{InvalidStateError}}" {{DOMException}}.

  1. Let |browsingContext| be |navigation|'s [=relevant global object=]'s [=Window/browsing context=].

  1. [=Assert=]: |browsingContext| is not null.

  1. [=Assert=]: |historyHandling| is either "<a for="history handling behavior">`replace`</a>", "<a for="history handling behavior">`reload`</a>", or "<a for="history handling behavior">`default`</a>".

  1. Let |ongoingNavigation| be the result of [=Navigation/setting the upcoming non-traverse navigation=] for |navigation| given |info| and |serializedState|.

  1. <a spec="HTML">Navigate</a> |browsingContext| to |url| with <i>[=navigate/historyHandling=]</i> set to |historyHandling|, <i>[=navigate/navigationAPIState=]</i> set to |serializedState|, and the <a spec="HTML">source browsing context</a> set to |browsingContext|.

  1. If |navigation|'s [=Navigation/upcoming non-traverse navigation=] is |ongoingNavigation|, then:

    <p class="note">This means the <a spec="HTML">navigate</a> algorithm bailed out before ever getting to the [=inner navigate event firing algorithm=] which would [=Navigation/promote the upcoming navigation to ongoing=].

    1. Set |navigation|'s [=Navigation/upcoming non-traverse navigation=] to null.

    1. Return [=an early error result=] for an "{{AbortError}}" {{DOMException}}.

  1. If |ongoingNavigation|'s [=navigation API method navigation/serialized state=] is non-null, then set |browsingContext|'s [=session history=]'s [=session history/current entry=]'s [=session history entry/navigation API state=] to |ongoingNavigation|'s [=navigation API method navigation/serialized state=].

     <p class="note">At this point |ongoingNavigation|'s [=navigation API method navigation/serialized state=] is no longer needed and can be nulled out instead of keeping it alive for the lifetime of the [=navigation API method navigation=].

  1. Return «[ "{{NavigationResult/committed}}" → |ongoingNavigation|'s [=navigation API method navigation/committed promise=], "{{NavigationResult/finished}}" → |ongoingNavigation|'s [=navigation API method navigation/finished promise=] ]».
</div>

<p class="note">Unlike {{Location/assign()|location.assign()}} and friends, which are exposed across [=same origin-domain|origin-domain=] boundaries, {{Navigation/navigate()|navigation.navigate()}} and {{Navigation/reload()|navigation.reload()}} can only be accessed by code with direct synchronous access to the {{Window/navigation}} property. Thus, we avoid the complications around tracking <a spec="HTML">source browsing contexts</a>, and we don't need to deal with the <a spec="HTML">allowed to navigate</a> check and its accompanying <i>[=navigate/exceptionsEnabled=]</i> flag. We just treat all navigations as being initiated by the {{Navigation}} object itself.

<p algorithm>
  An <dfn>an early error result</dfn> for an exception |e| is a dictionary instance given by  «[ "{{NavigationResult/committed}}" → [=a promise rejected with=] |e|, "{{NavigationResult/finished}}" → [=a promise rejected with=] |e| ]».
</p>

<h3 id="global-traversing">Traversing</h3>

<dl class="domintro non-normative">
  <dt><code>{ {{NavigationResult/committed}}, {{NavigationResult/finished}} } =  {{Window/navigation}}.{{Navigation/traverseTo(key)|traverseTo}}(<var ignore>key</var>)</code>
  <dt><code>{ {{NavigationResult/committed}}, {{NavigationResult/finished}} } =  {{Window/navigation}}.{{Navigation/traverseTo(key, options)|traverseTo}}(<var ignore>key</var>, { {{NavigationOptions/info}} })</code>
  <dd>
    <p>Traverses the <a spec=HTML>joint session history</a> to the closest joint session history entry that matches the {{NavigationHistoryEntry}} with the given key. {{NavigationOptions/info}} can be set to any value; it will populate the {{NavigateEvent/info}} property of the corresponding {{Navigation/navigate}} event.

    <p>If a traversal to that <a spec=HTML>joint session history</a> is already in progress, then this will return the promises for that original traversal, and {{NavigationOptions/info}} will be ignored.

    <p>The returned promises will behave as follows:

    * If there is no {{NavigationHistoryEntry}} in {{Navigation/entries|navigation.entries}} with the given key, both will reject with an "{{InvalidStateError}}" {{DOMException}}.
    * For same-document traversals intercepted by the {{Navigation/navigate}} event's {{NavigateEvent/transitionWhile()}} method, {{NavigationResult/committed}} will fulfill as soon as the traversal is processed and {{Navigation/currentEntry|navigation.currentEntry}} is updated, and {{NavigationResult/finished}} will fulfill or reject according to the promises passed to {{NavigateEvent/transitionWhile()}}.
    * For non-intercepted same-document traversals, both promises will fulfill as soon as the traversal is processed and {{Navigation/currentEntry|navigation.currentEntry}} is updated
    * For cross-document traversals, or traversals that result in 204/205 [=response/statuses=] or `Content-Disposition: attachment` header fields from the server (and thus do not actually traverse), both promises will never settle.
  </dd>

  <dt><code>{ {{NavigationResult/committed}}, {{NavigationResult/finished}} } =  {{Window/navigation}}.{{Navigation/back()|back}}()</code>
  <dt><code>{ {{NavigationResult/committed}}, {{NavigationResult/finished}} } =  {{Window/navigation}}.{{Navigation/back(options)|back}}({ {{NavigationOptions/info}} })</code>
  <dd>
    <p>Traverse the <a spec=HTML>joint session history</a> to the closest previous joint session history entry which results in this frame navigating, i.e. results in {{Navigation/currentEntry|navigation.currentEntry}} updating. {{NavigationOptions/info}} can be set to any value; it will populate the {{NavigateEvent/info}} property of the corresponding {{Navigation/navigate}} event.

    <p>If a traversal to that <a spec=HTML>joint session history</a> is already in progress, then this will return the promises for that original traversal, and {{NavigationOptions/info}} will be ignored.

    <p>The returned promises behave equivalently to those returned by {{Navigation/traverseTo()}}.
  </dd>

  <dt><code>{ {{NavigationResult/committed}}, {{NavigationResult/finished}} } =  {{Window/navigation}}.{{Navigation/forward()|forward}}()</code>
  <dt><code>{ {{NavigationResult/committed}}, {{NavigationResult/finished}} } =  {{Window/navigation}}.{{Navigation/forward(options)|forward}}({ {{NavigationOptions/info}} })</code>
  <dd>
    <p>Traverse the <a spec=HTML>joint session history</a> to the closest forward joint session history entry which results in this frame navigating, i.e. results in {{Navigation/currentEntry|navigation.currentEntry}} updating. {{NavigationOptions/info}} can be set to any value; it will populate the {{NavigateEvent/info}} property of the corresponding {{Navigation/navigate}} event.

    <p>If a traversal to that <a spec=HTML>joint session history</a> is already in progress, then this will return the promises for that original traversal, and {{NavigationOptions/info}} will be ignored.

    <p>The returned promises behave equivalently to those returned by {{Navigation/traverseTo()}}.
  </dd>
</dl>

<div algorithm>
  The <dfn method for="Navigation">traverseTo(|key|, |options|)</dfn> method steps are:

  1. If [=this=]'s [=Navigation/current entry index=] is &minus;1, then return [=an early error result=] for an "{{InvalidStateError}}" {{DOMException}}.

  1. If [=this=]'s [=Navigation/entry list=] does not contain any {{NavigationHistoryEntry}} whose [=NavigationHistoryEntry/session history entry=]'s [=session history entry/navigation API key=] equals |key|, then return [=an early error result=] for an "{{InvalidStateError}}" {{DOMException}}.

  1. Return the result of [=performing a navigation API traversal=] given [=this=], |key|, and |options|.
</div>

<div algorithm>
  The <dfn method for="Navigation">back(|options|)</dfn> method steps are:

  1. If [=this=]'s [=Navigation/current entry index=] is &minus;1 or 0, then return [=an early error result=] for an "{{InvalidStateError}}" {{DOMException}}.

  1. Let |key| be [=this=]'s [=Navigation/entry list=][[=this=]'s [=Navigation/current entry index=] &minus; 1]'s [=NavigationHistoryEntry/session history entry=]'s [=session history entry/navigation API key=].

  1. Return the result of [=performing a navigation API traversal=] given [=this=], |key|, and |options|.
</div>

<div algorithm>
  The <dfn method for="Navigation">forward(|options|)</dfn> method steps are:

  1. If [=this=]'s [=Navigation/current entry index=] is &minus;1 or is equal to [=this=]'s [=Navigation/entry list=]'s [=list/size=] &minus; 1, then return [=an early error result=] for an "{{InvalidStateError}}" {{DOMException}}.

  1. Let |key| be [=this=]'s [=Navigation/entry list=][[=this=]'s [=Navigation/current entry index=] + 1]'s [=NavigationHistoryEntry/session history entry=]'s [=session history entry/navigation API key=].

  1. Return the result of [=performing a navigation API traversal=] given [=this=], |key|, and |options|.
</div>

<div algorithm>
  <p class="advisement">The following algorithm is specified in terms of the <a href="https://github.com/whatwg/html/pull/6315">session history rewrite pull request</a> against the HTML Standard, because the existing session history traversal infrastructure is broken enough that it's hard to build on. It is expected to track that work as it continues.</p>

  To <dfn>perform a navigation API traversal</dfn> given a {{Navigation}} object |navigation|, a string |key|, and a {{NavigationOptions}} |options|:

  1. If |navigation|'s [=relevant global object=]'s [=associated Document=] is not [=Document/fully active=], then return [=an early error result=] for an "{{InvalidStateError}}" {{DOMException}}.

  1. If |navigation|'s [=relevant global object=]'s [=associated Document=]'s <a spec="HTML">unload counter</a> is greater than 0, then return [=an early error result=] for an "{{InvalidStateError}}" {{DOMException}}.

  1. If |navigation|'s [=Navigation/current entry=]'s [=NavigationHistoryEntry/session history entry=]'s [=session history entry/navigation API key=] equals |key|, then return «[ "{{NavigationResult/committed}}" → [=a promise resolved with=] |navigation|'s [=Navigation/current entry=], "{{NavigationResult/finished}}" → [=a promise resolved with=] |navigation|'s [=Navigation/current entry=] ]»

  1. If |navigation|'s [=Navigation/upcoming traverse navigations=][|key|] [=map/exists=], then:

    1. Let |navigation| be |navigation|'s [=Navigation/upcoming traverse navigations=][|key|].

    1. Return «[ "{{NavigationResult/committed}}" → |navigation|'s [=navigation API method navigation/committed promise=], "{{NavigationResult/finished}}" → |navigation|'s [=navigation API method navigation/finished promise=] ]».

  1. Let |navigable| be |navigation|'s [=relevant global object=]'s [=Window/browsing context=]'s [=browsing context/containing navigable=].

  1. Let |traversable| be |navigable|'s [=navigable/traversable navigable=].

  1. Let |initiatorBC| be |navigation|'s [=relevant global object=]'s [=Window/browsing context=].

  1. Let |info| be |options|["{{NavigationOptions/info}}"] if it [=map/exists=], or undefined otherwise.

  1. Let |ongoingNavigation| be the result of [=Navigation/setting an upcoming traverse navigation=] for |navigation| given |key| and |info|.

  1. [=parallel queue/Enqueue the following steps=] on |traversable|'s [=traversable navigable/session history traversal queue=]:

    1. Let |navigableEntries| be the result of [=navigable/getting the session history entries=] given |navigable|.

    1. Let |targetEntry| be the [=session history entry=] in |navigableEntries| whose [=session history entry/navigation API key=] equals |key|. If no such entry exists, then:

      1. [=navigation API method navigation/Reject the finished promise=] for |ongoingNavigation| with an "{{InvalidStateError}}" {{DOMException}}.

      1. Abort these steps.

      <p class="note">This can occur if the |navigation| object's view of session history is outdated, which can happen for brief periods while all the relevant threads and processes are being synchronized in reaction to a history change (such as the user clearing their history).

    1. If |targetEntry| is |navigable|'s [=navigable/active session history entry=], then abort these steps.

       <p class="note">This can occur if a previously-queued-up traversal already took us to this session history entry. In that case that previous traversal will have dealt with |ongoingNavigation| already.

    1. Let |targetStep| be null.

    1. If |targetEntry|'s [=session history entry/step=] is greater than |traversable|'s [=traversable navigable/current session history step=], then set |targetStep| to |targetEntry|'s [=session history entry/step=].

    1. Otherwise:

      1. Let |afterTarget| be the [=session history entry=] after |targetEntry| in |navigableEntries|.

      1. Let |allSteps| be the result of [=traversable navigable/getting all history steps=] that are part of the target session TODO.

      1. Set |targetStep| to the greatest number in |allSteps| that is less than |afterTarget|'s [=session history entry/step=].

    1. [=Apply the history step=] |targetStep| to |traversable|, with true, |initiatorBC|, and "<code>[=user navigation involvement/none=]</code>".

      - If this aborts due to user-canceled unloading or due to the {{Navigation/navigate}} event being canceled, then [=finalize with an aborted navigation error=] given |navigation| and |ongoingNavigation|.

      - If this aborts due to the initiator allowed-to-navigate check, then [=finalize with an aborted navigation error=] given |navigation|, |ongoingNavigation|, and a [=new=] "{{SecurityError}}" {{DOMException}} created in |navigation|'s [=relevant Realm=].

      <p class="advisement">Eventually [=apply the history step=] will have well-specified hooks for communicating these conditions back to its caller.</p>

  1. Return «[ "{{NavigationResult/committed}}" → |ongoingNavigation|'s [=navigation API method navigation/committed promise=], "{{NavigationResult/finished}}" → |ongoingNavigation|'s [=navigation API method navigation/finished promise=] ]».
</div>

<h3 id="global-events">Event handlers</h3>

The following are the [=event handlers=] (and their corresponding [=event handler event types=]) that must be supported, as [=event handler IDL attributes=], by objects implementing the {{Navigation}} interface:

<table>
  <thead>
    <th>[=Event handler=]
    <th>[=Event handler event type=]
  <tbody>
    <tr>
      <td><dfn attribute for="Navigation">onnavigate</dfn>
      <td><dfn event for="Navigation">navigate</dfn>
    <tr>
      <td><dfn attribute for="Navigation">onnavigatesuccess</dfn>
      <td><dfn event for="Navigation">navigatesuccess</dfn>
    <tr>
      <td><dfn attribute for="Navigation">onnavigateerror</dfn>
      <td><dfn event for="Navigation">navigateerror</dfn>
    <tr>
      <td><dfn attribute for="Navigation">oncurrententrychange</dfn>
      <td><dfn event for="Navigation">currententrychange</dfn>
</table>

<h2 id="navigate-event">The {{Navigation/navigate}} event</h2>

<h3 id="navigate-event-class">The {{NavigateEvent}} class</h3>

<xmp class="idl">
[Exposed=Window]
interface NavigateEvent : Event {
  constructor(DOMString type, NavigateEventInit eventInit);

  readonly attribute NavigationType navigationType;
  readonly attribute NavigationDestination destination;
  readonly attribute boolean canTransition;
  readonly attribute boolean userInitiated;
  readonly attribute boolean hashChange;
  readonly attribute AbortSignal signal;
  readonly attribute FormData? formData;
  readonly attribute DOMString? downloadRequest;
  readonly attribute any info;

  undefined transitionWhile(Promise<undefined> newNavigationAction,
                            optional NavigationTransitionWhileOptions options = {});
  undefined restoreScroll();
};

dictionary NavigateEventInit : EventInit {
  NavigationType navigationType = "push";
  required NavigationDestination destination;
  boolean canTransition = false;
  boolean userInitiated = false;
  boolean hashChange = false;
  required AbortSignal signal;
  FormData? formData = null;
  DOMString? downloadRequest = null;
  any info;
};

dictionary NavigationTransitionWhileOptions {
  NavigationFocusReset focusReset;
  NavigationScrollRestoration scrollRestoration;
};

enum NavigationFocusReset {
  "after-transition",
  "manual"
};

enum NavigationScrollRestoration {
  "after-transition",
  "manual"
};

enum NavigationType {
  "reload",
  "push",
  "replace",
  "traverse"
};
</xmp>

<dl class="domintro non-normative">
  <dt><code><var ignore>event</var>.{{NavigateEvent/navigationType}}</code>
  <dd>
    <p>One of "{{NavigationType/reload}}", "{{NavigationType/push}}", "{{NavigationType/replace}}", or "{{NavigationType/traverse}}", indicating what type of navigation this is.
  </dd>
  <dt><code><var ignore>event</var>.{{NavigateEvent/destination}}</code>
  <dd>
    <p>A {{NavigationDestination}} representing the destination of the navigation.
  </dd>

  <dt><code><var ignore>event</var>.{{NavigateEvent/canTransition}}</code>
  <dd>
    <p>True if {{NavigateEvent/transitionWhile()}} can be called to convert this navigation into a single-page navigation; false otherwise.

    <p>Generally speaking, this will be true whenever the current {{Document}} <a spec="HTML">can have its URL rewritten</a> to the destination URL, except for cross-document back/forward navigations, where it will always be false.
  </dd>

  <dt><code><var ignore>event</var>.{{NavigateEvent/userInitiated}}</code>
  <dd>
    <p>True if this navigation was due to a user clicking on an <{a}> element, submitting a <{form}> element, or using the browser UI to navigate; false otherwise.
  </dd>

  <dt><code><var ignore>event</var>.{{NavigateEvent/hashChange}}</code>
  <dd>
    <p>True if this navigation is a [=navigate to a fragment|fragment navigation=]; false otherwise.
  </dd>

  <dt><code><var ignore>event</var>.{{NavigateEvent/signal}}</code>
  <dd>
    <p>An {{AbortSignal}} which will become aborted if the navigation gets canceled, e.g. by the user pressing their browser's "Stop" button, or another higher-priority navigation interrupting this one.

    <p>The expected pattern is for developers to pass this along to any async operations, such as {{WindowOrWorkerGlobalScope/fetch()}}, which they perform as part of handling this navigation.
  </dd>

  <dt><code><var ignore>event</var>.{{NavigateEvent/formData}}</code>
  <dd>
    <p>The {{FormData}} representing the submitted form entries for this navigation, if this navigation is a "{{NavigationType/push}}" or "{{NavigationType/replace}}" navigation representing a POST <a spec="HTML" lt="submit">form submission</a>; null otherwise.

    <p>(Notably, this will be null even for "{{NavigationType/reload}}" and "{{NavigationType/traverse}}" navigations that are revisiting a session history entry that was originally created from a form submission.)
  </dd>

  <dt><code><var ignore>event</var>.{{NavigateEvent/downloadRequest}}</code>
  <dd>
    <p>Represents whether or not this navigation was requested to be a download, by using an <{a}> or <{area}> element's <{a/download}> attribute:

    * If a download was not requested, then this property is null.
    * If a download was requested, returns the filename that was supplied, via `<a download="filename" href="...">`. (This could be the empty string, as in the case of `<a download href="...">`.)

    <p>Note that a download being requested does not always mean that a download will happen: for example, the download might be blocked by browser security policies, or end up being treated as a push navigation for <a href="https://github.com/whatwg/html/issues/7718" class="XXX">unspecified reasons</a>.

    <p>Similarly, a navigation might end up being a download even if it was not requested to be one, due to the destination server responding with a `Content-Disposition: attachment` header.

    <p>Finally, note that the {{Navigation/navigate}} event will not fire at all for downloads initiated using browser UI affordances, e.g., those created by right-clicking and choosing to save the target of the link.
  </dd>

  <dt><code><var ignore>event</var>.{{NavigateEvent/info}}</code>
  <dd>
    <p>An arbitrary JavaScript value passed via {{Window/navigation}} APIs that initiated this navigation, or null if the navigation was initiated by the user or via a non-{{Window/navigation}} API.
  </dd>

  <dt><code><var ignore>event</var>.{{NavigateEvent/transitionWhile()|transitionWhile}}(|newNavigationAction|)</code>
  <dt><code><var ignore>event</var>.{{NavigateEvent/transitionWhile()|transitionWhile}}(|newNavigationAction|, { {{NavigationTransitionWhileOptions/focusReset}}: "{{NavigationFocusReset/manual}}" })</code>
  <dt><code><var ignore>event</var>.{{NavigateEvent/transitionWhile()|transitionWhile}}(|newNavigationAction|, { {{NavigationTransitionWhileOptions/scrollRestoration}}: "{{NavigationScrollRestoration/manual}}" })</code>
  <dd>
    <p>Converts this navigation into a same-document navigation to the destination URL.

    <p>The given |newNavigationAction| promise is used to signal the duration, and success or failure, of the navigation. After it settles, the browser signals to the user (e.g. via a loading spinner UI, or assistive technology) that the navigation is finished. Additionally, it fires {{Navigation/navigatesuccess}} or {{Navigation/navigateerror}} events as appropriate, which other parts of the web application can respond to.

    <p>By default, using this method will cause focus to reset when the |newNavigationAction| promise (and any other promises passed in other calls to {{NavigateEvent/transitionWhile()}}) settle. Focus will be reset to the first element with the <{html-global/autofocus}> attribute set, or the <{body}> element if the attribute isn't present. The {{NavigationTransitionWhileOptions/focusReset}} option can be set to "{{NavigationFocusReset/manual}}" to avoid this behavior.

    <p>By default, using this method for "{{NavigationType/traverse}}" navigations will cause the browser's scroll restoration logic to be delayed until the |newNavigationAction| promise (and any other promises passed in other calls to {{NavigateEvent/transitionWhile()}}) settle. The {{NavigationTransitionWhileOptions/scrollRestoration}} option can be set to "{{NavigationScrollRestoration/manual}}" to turn off scroll restoration entirely for this navigation.

    <p>This method will throw a "{{SecurityError}}" {{DOMException}} if {{NavigateEvent/canTransition}} is false, or if {{Event/isTrusted}} is false. It will throw an "{{InvalidStateError}}" {{DOMException}} if not called synchronously, during event dispatch.
  </dd>
</dl>

The <dfn attribute for="NavigateEvent">navigationType</dfn>, <dfn attribute for="NavigateEvent">destination</dfn>, <dfn attribute for="NavigateEvent">canTransition</dfn>, <dfn attribute for="NavigateEvent">userInitiated</dfn>, <dfn attribute for="NavigateEvent">hashChange</dfn>, <dfn attribute for="NavigateEvent">signal</dfn>, <dfn attribute for="NavigateEvent">formData</dfn>, <dfn attribute for="NavigateEvent">downloadRequest</dfn>, and <dfn attribute for="NavigateEvent">info</dfn> getter steps are to return the value that the corresponding attribute was initialized to.

A {{NavigateEvent}} has a <dfn for="NavigateEvent">classic history API serialized data</dfn>, a [=serialized state=]-or-null. It is only used in some cases where the event's {{NavigateEvent/navigationType}} is "{{NavigationType/push}}" or "{{NavigationType/replace}}", and is set appropriately when the event is [[#navigate-event-firing|fired]].

A {{NavigateEvent}} has a <dfn for="NavigateEvent">focus reset behavior</dfn>, a {{NavigationFocusReset}}-or-null, initially null.

A {{NavigateEvent}} has a <dfn for="NavigateEvent">scroll restoration behavior</dfn>, a {{NavigationScrollRestoration}}-or-null, initially null.

A {{NavigateEvent}} has a <dfn for="NavigateEvent">did process scroll restoration</dfn>, a boolean, initially false.

A {{NavigateEvent}} has a <dfn for="NavigateEvent">navigation action promises list</dfn>, which is a [=list=] of {{Promise}} objects, initially empty.

<div algorithm>
  The <dfn method for="NavigateEvent">transitionWhile(|newNavigationAction|, |options|)</dfn> method steps are:

  1. If [=this=]'s [=relevant global object=]'s [=active Document=] is not [=Document/fully active=], then throw an "{{InvalidStateError}}" {{DOMException}}.
  1. If [=this=]'s {{Event/isTrusted}} attribute was initialized to false, then throw a "{{SecurityError}}" {{DOMException}}.
  1. If [=this=]'s {{NavigateEvent/canTransition}} attribute was initialized to false, then throw a "{{SecurityError}}" {{DOMException}}.
  1. If [=this=]'s [=Event/dispatch flag=] is unset, then throw an "{{InvalidStateError}}" {{DOMException}}.
  1. If [=this=]'s [=Event/canceled flag=] is set, then throw an "{{InvalidStateError}}" {{DOMException}}.
  1. [=list/Append=] |newNavigationAction| to [=this=]'s [=NavigateEvent/navigation action promises list=].
  1. If |options|["{{NavigationTransitionWhileOptions/focusReset}}"] [=map/exists=], then:
    1. If [=this=]'s [=NavigateEvent/focus reset behavior=] is not null, and it is not equal to |options|["{{NavigationTransitionWhileOptions/focusReset}}"], then the user agent may [=report a warning to the console=] indicating that the {{NavigationTransitionWhileOptions/focusReset}} option for a previous call to {{NavigateEvent/transitionWhile()}} was overridden by this new value, and the previous value will be ignored.
    1. Set [=this=]'s [=NavigateEvent/focus reset behavior=] to |options|["{{NavigationTransitionWhileOptions/focusReset}}"].
  1. If |options|["{{NavigationTransitionWhileOptions/scrollRestoration}}"] [=map/exists=], and [=this=]'s {{NavigateEvent/navigationType}} attribute was initialized to "{{NavigationType/traverse}}", then:
    1. If [=this=]'s [=NavigateEvent/scroll restoration behavior=] is not null, and it is not equal to |options|["{{NavigationTransitionWhileOptions/scrollRestoration}}"], then the user agent may [=report a warning to the console=] indicating that the {{NavigationTransitionWhileOptions/scrollRestoration}} option for a previous call to {{NavigateEvent/transitionWhile()}} was overridden by this new value, and the previous value will be ignored.
    1. Set [=this=]'s [=NavigateEvent/scroll restoration behavior=] to |options|["{{NavigationTransitionWhileOptions/scrollRestoration}}"].
</div>

<div algorithm>
  The <dfn method for="NavigateEvent">restoreScroll()</dfn> method steps are:

  1. If [=this=]'s {{NavigateEvent/navigationType}} was not initialized to "{{NavigationType/traverse}}", then throw an "{{InvalidStateError}}" {{DOMException}}.
  1. If [=this=]'s [=NavigateEvent/scroll restoration behavior=] is not "{{NavigationScrollRestoration/manual}}", then throw an "{{InvalidStateError}}" {{DOMException}}.
  1. If [=this=]'s [=NavigateEvent/did process scroll restoration=] is true, then throw an "{{InvalidStateError}}" {{DOMException}}.
  1. [=Restore scroll position data=] given [=this=]'s [=relevant global object=]'s [=Window/navigable=]'s [=navigable/active session history entry=].
</div>

<h3 id="navigate-event-destination">The {{NavigationDestination}} class</h3>

<xmp class="idl">
[Exposed=Window]
interface NavigationDestination {
  readonly attribute USVString url;
  readonly attribute DOMString? key;
  readonly attribute DOMString? id;
  readonly attribute long long index;
  readonly attribute boolean sameDocument;

  any getState();
};
</xmp>

<dl class="domintro non-normative">
  <dt><code><var ignore>event</var>.{{NavigateEvent/destination}}.{{NavigationDestination/url}}</code>
  <dd>
    <p>The URL being navigated to.
  </dd>

  <dt><code><var ignore>event</var>.{{NavigateEvent/destination}}.{{NavigationDestination/key}}</code>
  <dd>
    <p>The value of the {{NavigationHistoryEntry/key}} property of the destination {{NavigationHistoryEntry}}, if this is a "{{NavigationType/traverse}}" navigation, or null otherwise.
  </dd>

  <dt><code><var ignore>event</var>.{{NavigateEvent/destination}}.{{NavigationDestination/id}}</code>
  <dd>
    <p>The value of the {{NavigationHistoryEntry/id}} property of the destination {{NavigationHistoryEntry}}, if this is a "{{NavigationType/traverse}}" navigation, or null otherwise.
  </dd>

  <dt><code><var ignore>event</var>.{{NavigateEvent/destination}}.{{NavigationDestination/index}}</code>
  <dd>
    <p>The value of the {{NavigationHistoryEntry/index}} property of the destination {{NavigationHistoryEntry}}, if this is a "{{NavigationType/traverse}}" navigation, or &minus;1 otherwise.
  </dd>

  <dt><code><var ignore>event</var>.{{NavigateEvent/destination}}.{{NavigationDestination/sameDocument}}</code>
  <dd>
    <p>Indicates whether or not this navigation is to the same {{Document}} as the current {{Window/document}} value, or not. This will be true, for example, in cases of fragment navigations or {{History/pushState()|history.pushState()}} navigations.

    <p>Note that this property indicates the original nature of the navigation. If a cross-document navigation is converted into a same-document navigation using {{NavigateEvent/transitionWhile()|event.transitionWhile()}}, that will not change the value of this property.
  </dd>

  <dt><code><var ignore>state</var> = <var ignore>event</var>.{{NavigateEvent/destination}}.{{NavigationDestination/getState()}}</code>
  <dd>
    <p>For "{{NavigationType/traverse}}" navigations, returns the deserialization of the state stored in the destination session history entry.

    <p>For "{{NavigationType/push}}" and "{{NavigationType/replace}}" navigations, returns the deserialization of the state passed to {{Navigation/navigate()|navigation.navigate()}}, if the navigation was initiated in that way, or undefined if it wasn't.

    <p>For "{{NavigationType/reload}}" navigations, returns the deserialization of the state passed to {{Navigation/reload()|navigation.reload()}}, if the reload was initiated in that way, or undefined if it wasn't.
  </dd>
</dl>

A {{NavigationDestination}} has an associated <dfn for="NavigationDestination">URL</dfn>, which is a [=URL=].

A {{NavigationDestination}} has an associated <dfn for="NavigationDestination">key</dfn>, which is a [=string=]-or-null.

A {{NavigationDestination}} has an associated <dfn for="NavigationDestination">id</dfn>, which is a [=string=]-or-null.

A {{NavigationDestination}} has an associated <dfn for="NavigationDestination">index</dfn>, which is an integer.

A {{NavigationDestination}} has an associated <dfn for="NavigationDestination">state</dfn>, which is a [=serialized state=]-or-null.

A {{NavigationDestination}} has an associated <dfn for="NavigationDestination">is same document</dfn>, which is a boolean.

The <dfn attribute for="NavigationDestination">url</dfn> getter steps are to return [=this=]'s [=NavigationDestination/URL=], [=URL serializer|serialized=].

The <dfn attribute for="NavigationDestination">key</dfn> getter steps are to return [=this=]'s [=NavigationDestination/key=].

The <dfn attribute for="NavigationDestination">id</dfn> getter steps are to return [=this=]'s [=NavigationDestination/id=].

The <dfn attribute for="NavigationDestination">index</dfn> getter steps are to return [=this=]'s [=NavigationDestination/index=].

The <dfn attribute for="NavigationDestination">sameDocument</dfn> getter steps are to return [=this=]'s [=NavigationDestination/is same document=].

<div algorithm>
  The <dfn method for="NavigationDestination">getState()</dfn> method steps are:

  1. If [=this=]'s [=NavigationDestination/state=] is null, then return undefined.
  1. Return [$StructuredDeserialize$]([=this=]'s [=NavigationDestination/state=]).
</div>

<h3 id="navigate-event-firing">Firing the event</h3>

<div algorithm="fire a traversal navigate event">
  To <dfn>fire a traversal `navigate` event</dfn> at a {{Navigation}} |navigation| given a [=session history entry=] <dfn for="fire a traversal navigate event">|destinationEntry|</dfn>, and an optional [=user navigation involvement=] <dfn for="fire a traversal navigate event">|userInvolvement|</dfn> (default "<code>[=user navigation involvement/none=]</code>"):

  1. Let |event| be the result of [=creating an event=] given {{NavigateEvent}}, in |navigation|'s [=relevant Realm=].
  1. Set |event|'s [=NavigateEvent/classic history API serialized data=] to null.
  1. Let |destination| be a [=new=] {{NavigationDestination}} created in |navigation|'s [=relevant Realm=].
  1. Set |destination|'s [=NavigationDestination/URL=] to |destinationEntry|'s [=session history entry/URL=].
  1. If |destinationEntry|'s [=session history entry/origin=] is [=same origin=] with |navigation|'s [=relevant settings object=]'s [=environment settings object/origin=], then:
    1. Set |destination|'s [=NavigationDestination/key=] to |destinationEntry|'s [=session history entry/navigation API key=].
    1. Set |destination|'s [=NavigationDestination/id=] to |destinationEntry|'s [=session history entry/navigation API ID=].
    1. Set |destination|'s [=NavigationDestination/index=] to the result of [=getting the navigation API history index=] of |destinationEntry| within |navigation|.
    1. Set |destination|'s [=NavigationDestination/state=] to |destinationEntry|'s [=session history entry/navigation API state=].
  1. Otherwise,
    1. Set |destination|'s [=NavigationDestination/key=] to null.
    1. Set |destination|'s [=NavigationDestination/id=] to null.
    1. Set |destination|'s [=NavigationDestination/index=] to &minus;1.
    1. Set |destination|'s [=NavigationDestination/state=] to null.
  1. Set |destination|'s [=NavigationDestination/is same document=] to true if |destinationEntry|'s [=session history entry/document=] is equal to |navigation|'s [=relevant global object=]'s [=associated Document=]; otherwise false.
  1. Let |result| be the result of performing the [=inner navigate event firing algorithm=] given |navigation|, "{{NavigationType/traverse}}", |event|, |destination|, |userInvolvement|, null, and null.
  1. [=Assert=]: |result| is true (traversals are never cancelable).
</div>

<div algorithm="fire a non-traversal navigate event">
  To <dfn>fire a non-traversal `navigate` event</dfn> at a {{Navigation}} |navigation| given a {{NavigationType}} <dfn for="fire a non-traversal navigate event">|navigationType|</dfn>, a [=URL=] <dfn for="fire a non-traversal navigate event">|destinationURL|</dfn>, a boolean <dfn for="fire a non-traversal navigate event">|isSameDocument|</dfn>, an optional [=user navigation involvement=] <dfn for="fire a non-traversal navigate event">|userInvolvement|</dfn> (default "<code>[=user navigation involvement/none=]</code>"), an optional [=serialized state=]-or-null <dfn for="fire a non-traversal navigate event">|state|</dfn> (default null), an optional [=entry list=] or null <dfn for="fire a non-traversal navigate event">|formDataEntryList|</dfn> (default null), and an optional [=serialized state=]-or-null <dfn for="fire a non-traversal navigate event">|classicHistoryAPISerializedData|</dfn> (default null):

  1. Let |event| be the result of [=creating an event=] given {{NavigateEvent}}, in |navigation|'s [=relevant Realm=].
  1. Set |event|'s [=NavigateEvent/classic history API serialized data=] to |classicHistoryAPISerializedData|.
  1. Let |destination| be a [=new=] {{NavigationDestination}} created in |navigation|'s [=relevant Realm=].
  1. Set |destination|'s [=NavigationDestination/URL=] to |destinationURL|.
  1. Set |destination|'s [=NavigationDestination/key=] to null.
  1. Set |destination|'s [=NavigationDestination/id=] to null.
  1. Set |destination|'s [=NavigationDestination/index=] to &minus;1.
  1. Set |destination|'s [=NavigationDestination/state=] to |state|.
  1. Set |destination|'s [=NavigationDestination/is same document=] to |isSameDocument|.
  1. Return the result of performing the [=inner navigate event firing algorithm=] given |navigation|, |navigationType|, |event|, |destination|, |userInvolvement|, |formDataEntryList|, and null.
</div>

<div algorithm="fire a download-requested navigate event">
  To <dfn>fire a download-requested `navigate` event</dfn> at a {{Navigation}} |navigation| given a [=URL=] <dfn for="fire a download-requested navigate event">|destinationURL|</dfn>, a [=user navigation involvement=] <dfn for="fire a download-requested navigate event">|userInvolvement|</dfn>, and a string <dfn for="fire a download-requested navigate event">|filename|</dfn>:

  1. Let |event| be the result of [=creating an event=] given {{NavigateEvent}}, in |navigation|'s [=relevant Realm=].
  1. Set |event|'s [=NavigateEvent/classic history API serialized data=] to null.
  1. Let |destination| be a [=new=] {{NavigationDestination}} created in |navigation|'s [=relevant Realm=].
  1. Set |destination|'s [=NavigationDestination/URL=] to |destinationURL|.
  1. Set |destination|'s [=NavigationDestination/key=] to null.
  1. Set |destination|'s [=NavigationDestination/id=] to null.
  1. Set |destination|'s [=NavigationDestination/index=] to &minus;1.
  1. Set |destination|'s [=NavigationDestination/state=] to null.
  1. Set |destination|'s [=NavigationDestination/is same document=] to false.
  1. Return the result of performing the [=inner navigate event firing algorithm=] given |navigation|, "{{NavigationType/push}}", |event|, |destination|, |userInvolvement|, null, and |filename|.
</div>

<div algorithm>
  The <dfn>inner `navigate` event firing algorithm</dfn> is the following steps, given a {{Navigation}} |navigation|, a {{NavigationType}} |navigationType|, a {{NavigateEvent}} |event|, a {{NavigationDestination}} |destination|, a [=user navigation involvement=] |userInvolvement|, an [=entry list=] or null |formDataEntryList|, and a string or null |downloadRequestFilename|:

  1. [=Navigation/Promote the upcoming navigation to ongoing=] given |navigation| and |destination|'s [=NavigationDestination/key=].
  1. Let |ongoingNavigation| be |navigation|'s [=Navigation/ongoing navigation=].
  1. If |navigation| [=Navigation/has entries and events disabled=], then:
    1. If |ongoingNavigation| is not null, then:
      1. Set |ongoingNavigation|'s [=navigation API method navigation/serialized state=] to null.
      1. [=navigation API method navigation/Clean up=] |ongoingNavigation|.

      <p class="note">In this case the [=navigation API method navigation/committed promise=] and [=navigation API method navigation/finished promise=] will never fulfill, since we never create {{NavigationHistoryEntry}}s for the initial `about:blank` {{Document}} so we have nothing to [=resolve=] them with. We also need to prevent any call to {{Navigation/navigate()|navigation.navigate()}} which triggered this algorithm from overwriting the [=session history entry/navigation API state=] of the [=session history/current entry=].
    1. Return true.
  1. Let |document| be |navigation|'s [=relevant global object=]'s [=associated document=].
  1. If |document| <a spec="HTML">can have its URL rewritten</a> to |destination|'s [=NavigationDestination/URL=], and either |destination|'s [=NavigationDestination/is same document=] is true or |navigationType| is not "{{NavigationType/traverse}}", then initialize |event|'s {{NavigateEvent/canTransition}} to true. Otherwise, initialize it to false.
  1. If |navigationType| is not "{{NavigationType/traverse}}", then initialize |event|'s {{Event/cancelable}} to true. Otherwise, initialize it to false.
  1. Initialize |event|'s {{Event/type}} to "{{Navigation/navigate}}".
  1. Initialize |event|'s {{NavigateEvent/navigationType}} to |navigationType|.
  1. Initialize |event|'s {{NavigateEvent/destination}} to |destination|.
  1. Initialize |event|'s {{NavigateEvent/downloadRequest}} to |downloadRequestFilename|.
  1. If |ongoingNavigation| is not null, then initialize |event|'s {{NavigateEvent/info}} to |ongoingNavigation|'s [=navigation API method navigation/info=]. Otherwise, initialize it to undefined.
     <p class="note">At this point |ongoingNavigation|'s [=navigation API method navigation/info=] is no longer needed and can be nulled out instead of keeping it alive for the lifetime of the [=navigation API method navigation=].
  1. Initialize |event|'s {{NavigateEvent/signal}} to a [=new=] {{AbortSignal}} created in |navigation|'s [=relevant Realm=].
  1. Let |currentURL| be |document|'s [=Document/URL=].
  1. If all of the following are true:
    * |destination|'s [=NavigationDestination/is same document=] is true;
    * |destination|'s [=NavigationDestination/URL=] [=url/equals=] |currentURL| with <i>[=url/equals/exclude fragments=]</i> set to true; and
    * |destination|'s [=NavigationDestination/URL=]'s [=url/fragment=] is not [=string/is|identical to=] |currentURL|'s [=url/fragment=]

    then initialize |event|'s {{NavigateEvent/hashChange}} to true. Otherwise, initialize it to false.
  1. If |userInvolvement| is not "<code>[=user navigation involvement/none=]</code>", then initialize |event|'s {{NavigateEvent/userInitiated}} to true. Otherwise, initialize it to false.
  1. If |formDataEntryList| is not null, then initialize |event|'s {{NavigateEvent/formData}} to a [=new=] {{FormData}} created in |navigation|'s [=relevant Realm=], associated to |formDataEntryList|. Otherwise, initialize it to null.
  1. [=Assert=]: |navigation|'s [=Navigation/ongoing navigate event=] is null.
  1. Set |navigation|'s [=Navigation/ongoing navigate event=] to |event|.
  1. [=Assert=]: |navigation|'s [=Navigation/ongoing navigation signal=] is null.
  1. Set |navigation|'s [=Navigation/ongoing navigation signal=] to |event|'s {{NavigateEvent/signal}}.
  1. Set |navigation|'s [=Navigation/focus changed during ongoing navigation=] to false.
  1. Set |navigation|'s [=Navigation/suppress normal scroll restoration during ongoing navigation=] to false.
  1. Let |dispatchResult| be the result of [=dispatching=] |event| at |navigation|.
  1. Set |navigation|'s [=Navigation/ongoing navigate event=] to null.
  1. If |dispatchResult| is false:
    1. If |navigationType| is not "{{NavigationType/traverse}}" and |event|'s {{NavigateEvent/signal}} is not [=AbortSignal/aborted=], then [=finalize with an aborted navigation error=] given |navigation| and |ongoingNavigation|.
       <p class="note">If |navigationType| is "{{NavigationType/traverse}}", then we will [=finalize with an aborted navigation error=] in [=perform a navigation API traversal=].
    1. Return false.
  1. Let |hadTransitionWhile| be true if |event|'s [=NavigateEvent/navigation action promises list=] is not empty; otherwise false.
  1. Let |endResultIsSameDocument| be true if |hadTransitionWhile| is true or |destination|'s [=NavigationDestination/is same document=] is true.
  1. If |hadTransitionWhile| is true:
    1. Let |fromEntry| be the [=Navigation/current entry=] for |navigation|.
    1. [=Assert=]: |fromEntry| is not null.
    1. Set |navigation|'s [=Navigation/transition=] to a [=new=] {{NavigationTransition}} created in |navigation|'s [=relevant Realm=], whose [=NavigationTransition/navigation type=] is |navigationType|, [=NavigationTransition/from entry=] is |fromEntry|, and whose [=NavigationTransition/finished promise=] is [=a new promise=] created in |navigation|'s [=relevant Realm=].
    1. [=Mark as handled=] |navigation|'s [=Navigation/transition=]'s [=NavigationTransition/finished promise=].
      <p class="note">See <a href="#note-finished-promise-mark-as-handled">the discussion about other finished promises</a> as to why this is done.</p>
    1. If |navigationType| is "{{NavigationType/traverse}}", then set |navigation|'s [=Navigation/suppress normal scroll restoration during ongoing navigation=] to true.
       <p class="note">If |event|'s [=NavigateEvent/scroll restoration behavior=] was set to "{{NavigationScrollRestoration/after-transition}}", then we will [=potentially perform scroll restoration=] below. Otherwise, there will be no scroll restoration. That is, no navigation which is intercepted by {{NavigateEvent/transitionWhile()}} goes through the normal scroll restoration process; scroll restoration for such navigations is either done manually, by the web developer, or is done after the transition.
  1. If |endResultIsSameDocument| is true:
    1. Let |tweakedPromisesList| be |event|'s  [=NavigateEvent/navigation action promises list=].
    1. If |tweakedPromisesList|'s [=list/size=] is 0, then set |tweakedPromisesList| to « [=a promise resolved with=] {{undefined}} ».
       <p class="note">There is a subtle timing difference between how [=waiting for all=] schedules its success and failure steps when given zero promises versus &geq;1 promises. For most uses of [=waiting for all=], this does not matter. However, with this API, there are so many events and promise handlers which could fire around the same time that the difference is pretty easily observable: it can cause the event/promise handler sequence to vary. (Some of the events and promises involved include: {{Navigation/navigatesuccess}} / {{Navigation/navigateerror}}, {{Navigation/currententrychange}}, {{NavigationHistoryEntry/dispose}}, |ongoingNavigation|'s promises, and the {{NavigationTransition/finished|navigation.transition.finished}} promise.)
    1. [=Wait for all=] of |tweakedPromisesList|, with the following success steps:
        1. If |event|'s {{NavigateEvent/signal}} is [=AbortSignal/aborted=], then abort these steps.
        1. [=Fire an event=] named {{Navigation/navigatesuccess}} at |navigation|.
        1. If |navigation|'s [=Navigation/transition=] is not null, then [=resolve=] |navigation|'s [=Navigation/transition=]'s [=NavigationTransition/finished promise=] with undefined.
        1. Set |navigation|'s [=Navigation/transition=] to null.
        1. If |ongoingNavigation| is non-null, then [=navigation API method navigation/resolve the finished promise=] for |ongoingNavigation|.
        1. [=Potentially reset the focus=] given |navigation| and |event|.
        1. [=Potentially perform scroll restoration=] given |navigation| and |event|.
      and the following failure steps given reason |rejectionReason|:
        1. If |event|'s {{NavigateEvent/signal}} is [=AbortSignal/aborted=], then abort these steps.
        1. [=Fire an event=] named {{Navigation/navigateerror}} at |navigation| using {{ErrorEvent}}, with {{ErrorEvent/error}} initialized to |rejectionReason|, and {{ErrorEvent/message}}, {{ErrorEvent/filename}}, {{ErrorEvent/lineno}}, and {{ErrorEvent/colno}} initialized to appropriate values that can be extracted from |rejectionReason| in the same underspecified way the user agent typically does for the <a spec="HTML">report an exception</a> algorithm.
        1. If |navigation|'s [=Navigation/transition=] is not null, then [=reject=] |navigation|'s [=Navigation/transition=]'s [=NavigationTransition/finished promise=] with |rejectionReason|.
        1. Set |navigation|'s [=Navigation/transition=] to null.
        1. If |ongoingNavigation| is non-null, then [=navigation API method navigation/reject the finished promise=] for |ongoingNavigation| with |rejectionReason|.
        1. [=Potentially reset the focus=] given |navigation| and |event|.
           <p class="note">Although we still [=potentially reset the focus=] for such failed transitions, we do <em>not</em> [=potentially perform scroll restoration=] for them.
  1. Otherwise, if |ongoingNavigation| is non-null, then:
    1. Set |ongoingNavigation|'s [=navigation API method navigation/serialized state=] to null.
       <p class="note">This ensures that any call to {{Navigation/navigate()|navigation.navigate()}} which triggered this algorithm does not overwrite the [=session history entry/navigation API state=] of the [=session history/current entry=] for cross-document navigations.
    1. [=navigation API method navigation/Clean up=] |ongoingNavigation|.
  1. If |hadTransitionWhile| is true and |navigationType| is not "{{NavigationType/traverse}}":
    1. If |navigationType| is not "{{NavigationType/reload}}", then run the [=URL and history update steps=] given |document| and |event|'s {{NavigateEvent/destination}}'s [=NavigationDestination/URL=], with <i>[=URL and history update steps/serializedData=]</i> set to |event|'s [=NavigateEvent/classic history API serialized data=] and <i>[=URL and history update steps/historyHandling=]</i> set to |navigationType|.

       <p class="note">If |navigationType| is "{{NavigationType/reload}}", then we are converting a reload into a "same-document reload", for which the <a spec="HTML">URL and history update steps</a> are not appropriate. Navigation API-related stuff still happens, such as updating the [=session history/current entry=]'s [=session history entry/navigation API state=] if this was caused by a call to {{Navigation/reload()|navigation.reload()}}, and all the <a href="#ongoing-state">ongoing navigation tracking</a> in response to the promise passed to {{NavigateEvent/transitionWhile()}}.
    1. Return false.
  1. Return true.
</div>

<div algorithm>
  To <dfn>finalize with an aborted navigation error</dfn> given a {{Navigation}} |navigation|, a [=navigation API method navigation=] or null |ongoingNavigation|, and an optional {{DOMException}} |error|:

  1. Set |navigation|'s [=Navigation/focus changed during ongoing navigation=] to false.
  1. Set |navigation|'s [=Navigation/suppress normal scroll restoration during ongoing navigation=] to false.
  1. If |error| was not given, then set |error| to a [=new=] "{{AbortError}}" {{DOMException}}, created in |navigation|'s [=relevant Realm=].
  1. If |navigation|'s [=Navigation/ongoing navigate event=] is non-null, then:
    1. Set |navigation|'s [=Navigation/ongoing navigate event=]'s [=Event/canceled flag=] to true.
    1. Set |navigation|'s [=Navigation/ongoing navigate event=] to null.
  1. If |navigation|'s [=Navigation/ongoing navigation signal=] is non-null, then:
    1. [=AbortSignal/Signal abort=] on |navigation|'s [=Navigation/ongoing navigation signal=] given |error|.
    1. Set |navigation|'s [=Navigation/ongoing navigation signal=] to null.
  1. [=Fire an event=] named {{Navigation/navigateerror}} at |navigation| using {{ErrorEvent}}, with {{ErrorEvent/error}} initialized to |error|, and {{ErrorEvent/message}}, {{ErrorEvent/filename}}, {{ErrorEvent/lineno}}, and {{ErrorEvent/colno}} initialized to appropriate values that can be extracted from |error| and the current JavaScript stack in the same underspecified way the user agent typically does for the <a spec="HTML">report an exception</a> algorithm.
     <p class="note">Thus, for example, if this algorithm is reached because of a call to {{Window/stop()|window.stop()}}, these properties would probably end up initialized based on the line of script that called {{Window/stop()|window.stop()}}. But if it's because the user clicked the stop button, these properties would probably end up with default values like the empty string or 0.
  1. If |ongoingNavigation| is non-null, then:
    1. Set |ongoingNavigation|'s [=navigation API method navigation/serialized state=] to null.
       <p class="note">This ensures that any call to {{Navigation/navigate()|navigation.navigate()}} which triggered this algorithm does not overwrite the [=session history entry/navigation API state=] of the [=session history/current entry=] for aborted navigations.
    1. [=navigation API method navigation/Reject the finished promise=] for |ongoingNavigation| with |error|.
  1. If |navigation|'s [=Navigation/transition=] is not null, then:
    1. [=Reject=] |navigation|'s [=Navigation/transition=]'s [=NavigationTransition/finished promise=] with |error|.
    1. Set |navigation|'s [=Navigation/transition=] to null.
</div>

<div algorithm>
  To <dfn>inform the navigation API about canceling navigation</dfn> in a [=browsing context=] |bc|:

  1. Let |navigation| be |bc|'s [=browsing context/active window=]'s [=Window/navigation API=].
  1. If |navigation|'s [=Navigation/ongoing navigation signal=] is null, then return.
  1. [=Finalize with an aborted navigation error=] given |navigation| and |navigation|'s [=Navigation/ongoing navigation=].
</div>

<div algorithm>
  To <dfn>inform the navigation API about browsing context discarding</dfn> given a [=browsing context=] |bc|:

  1. [=Inform the navigation API about canceling navigation=] in |bc|.
  1. Let |navigation| be |bc|'s [=browsing context/active window=]'s [=Window/navigation API=].
  1. Let |traversals| be a [=list/clone=] of |navigation|'s [=Navigation/upcoming traverse navigations=].
  1. For each |traversal| of |traversals|: [=finalize with an aborted navigation error=] given |navigation| and |traversal|.
</div>

<div algorithm>
  To <dfn>potentially reset the focus</dfn> given a {{Navigation}} object |navigation| and an {{NavigateEvent}} |event|:

  1. Let |focusChanged| be |navigation|'s [=Navigation/focus changed during ongoing navigation=].
  1. Set |navigation|'s [=Navigation/focus changed during ongoing navigation=] to false.
  1. If |focusChanged| is true, then return.
  1. If |event|'s [=NavigateEvent/navigation action promises list=]'s [=list/size=] is 0, then return.
  1. If |event|'s [=NavigateEvent/focus reset behavior=] is "{{NavigationFocusReset/manual}}", then return.
     <p class="note">If it was left as null, then we treat that as "{{NavigationFocusReset/after-transition}}", and continue onward.
  1. Let |document| be |navigation|'s [=relevant global object=]'s [=associated Document=].
  1. Let |focusTarget| be the <a spec="HTML">autofocus delegate</a> for |document|.
  1. If |focusTarget| is null, then set |focusTarget| to |document|'s <a spec="HTML" lt="the body element">body element</a>.
  1. If |focusTarget| is null, then set |focusTarget| to |document|'s [=document element=].
  1. Run the <a spec="HTML">focusing steps</a> for |focusTarget|, with |document|'s <a spec="CSS2">viewport</a> as the fallback target.
  1. Move the <a spec="HTML">sequential focus navigation starting point</a> to |focusTarget|.
</div>

<div algorithm>
  To <dfn>potentially perform scroll restoration</dfn> given a {{Navigation}} object |navigation| and an {{NavigateEvent}} |event|:

  1. If |event|'s [=NavigateEvent/navigation action promises list=]'s [=list/size=] is 0, then return.
  1. If |event|'s {{NavigateEvent/navigationType}} was not initialized to "{{NavigationType/traverse}}", then return.
  1. If |event|'s [=NavigateEvent/scroll restoration behavior=] is "{{NavigationScrollRestoration/manual}}", then return.
     <p class="note">If it was left as null, then we treat that as "{{NavigationScrollRestoration/after-transition}}", and continue onward.
  1. If |event|'s [=NavigateEvent/did process scroll restoration=] is true, then return.
  1. Set |event|'s [=NavigateEvent/did process scroll restoration=] to true.
  1. [=Restore scroll position data=] given |navigation|'s [=Navigation/current entry=]'s [=NavigationHistoryEntry/session history entry=].
</div>

<h2 id="NavigationHistoryEntry-class">Navigation API history entries</h2>

<xmp class="idl">
[Exposed=Window]
interface NavigationHistoryEntry : EventTarget {
  readonly attribute USVString? url;
  readonly attribute DOMString key;
  readonly attribute DOMString id;
  readonly attribute long long index;
  readonly attribute boolean sameDocument;

  any getState();

  attribute EventHandler onnavigateto;
  attribute EventHandler onnavigatefrom;
  attribute EventHandler onfinish;
  attribute EventHandler ondispose;
};
</xmp>

<dl class="domintro non-normative">
  <dt><code><var ignore>entry</var>.{{NavigationHistoryEntry/url}}</code>
  <dd>
    <p>The URL of this navigation history entry.

    <p>This can return null if the entry corresponds to a different {{Document}} than the current one (i.e. if {{NavigationHistoryEntry/sameDocument}} is false), and that {{Document}}'s [=policy container/referrer policy=] was <a>"`no-referrer`"</a> or <a>"`origin`"</a>, since that indicates the {{Document}} in question is hiding its URL even from other same-origin pages.
  </dd>

  <dt><code><var ignore>entry</var>.{{NavigationHistoryEntry/key}}</code>
  <dd>
    <p>A [=user agent=]-generated random UUID string representing this navigation history entry's place in the navigation history list. This value will be reused by other {{NavigationHistoryEntry}} instances that replace this one due to replace-style navigations. This value will survive session restores.

    <p>This is useful for navigating back to this entry in the navigation history list, using {{Navigation/traverseTo(key)|navigation.traverseTo(key)}}.
  </dd>

  <dt><code><var ignore>entry</var>.{{NavigationHistoryEntry/id}}</code>
  <dd>
    <p>A [=user agent=]-generated random UUID string representing this specific navigation history entry. This value will <em>not</em> be reused by other {{NavigationHistoryEntry}} instances. This value will survive session restores.

    <p>This is useful for associating data with this navigation history entry using other storage APIs.
  </dd>

  <dt><code><var ignore>entry</var>.{{NavigationHistoryEntry/index}}</code>
  <dd>
    <p>The index of this navigation history entry within {{Navigation/entries()|navigation.entries()}}, or &minus;1 if the entry is not in the navigation history entry list.
  </dd>

  <dt><code><var ignore>entry</var>.{{NavigationHistoryEntry/sameDocument}}</code>
  <dd>
    <p>Indicates whether or not this navigation history entry is for the same {{Document}} as the current {{Window/document}} value, or not. This will be true, for example, when the entry represents a fragment navigation or single-page app navigations.
  </dd>

  <dt><code><var ignore>state</var> = <var ignore>entry</var>.{{NavigationHistoryEntry/getState()|getState}}()</code>
  <dd>
    <p>Returns the deserialization of the state stored in this entry, which was added to the entry using {{Navigation/navigate()|navigation.navigate()}}. This state survives session restores.

    <p>Note that in general, unless the state value is a primitive, <code>entry.getState() !== entry.getState()</code>, since a fresh copy is returned each time.

    <p>This state is unrelated to the classic history API's {{History/state|history.state}}.
  </dd>
</dl>

Each {{NavigationHistoryEntry}} has an associated <dfn for="NavigationHistoryEntry">session history entry</dfn>, which is a [=session history entry=].

Each {{NavigationHistoryEntry}} has an associated <dfn for="NavigationHistoryEntry">index</dfn>, which is an integer.

<div algorithm>
  The <dfn attribute for="NavigationHistoryEntry">key</dfn> getter steps are:

  1. If [=this=]'s [=relevant global object=]'s [=associated Document=] is not [=Document/fully active=], then return the empty string.
  1. Return [=this=]'s [=NavigationHistoryEntry/session history entry=]'s [=session history entry/navigation API key=].
</div>

<div algorithm>
  The <dfn attribute for="NavigationHistoryEntry">id</dfn> getter steps are:

  1. If [=this=]'s [=relevant global object=]'s [=associated Document=] is not [=Document/fully active=], then return the empty string.
  1. Return [=this=]'s [=NavigationHistoryEntry/session history entry=]'s [=session history entry/navigation API ID=].
</div>

<div algorithm>
  The <dfn attribute for="NavigationHistoryEntry">url</dfn> getter steps are:

  1. If [=this=]'s [=relevant global object=]'s [=associated Document=] is not [=Document/fully active=], then return null.
  1. Let |she| be [=this=]'s [=NavigationHistoryEntry/session history entry=].
  1. If |she|'s [=session history entry/document=] does not equal [=this=]'s [=relevant global object=]'s [=associated Document=], and |she|'s [=session history entry/policy container=]'s [=policy container/referrer policy=] is <a>"`no-referrer`"</a> or <a>"`origin`"</a>, then return null.
  1. Return |she|'s [=session history entry/URL=], [=URL serializer|serialized=].
</div>

<div algorithm>
  The <dfn attribute for="NavigationHistoryEntry">index</dfn> getter steps are:

  1. If [=this=]'s [=relevant global object=]'s [=associated Document=] is not [=Document/fully active=], then return &minus;1.
  1. Return [=this=]'s [=NavigationHistoryEntry/index=].
</div>

<div algorithm>
  The <dfn attribute for="NavigationHistoryEntry">sameDocument</dfn> getter steps are:

  1. If [=this=]'s [=relevant global object=]'s [=associated Document=] is not [=Document/fully active=], then return false.
  1. Return true if [=this=]'s [=NavigationHistoryEntry/session history entry=]'s [=session history entry/document=] equals [=this=]'s [=relevant global object=]'s [=associated Document=], and false otherwise.
</div>

<div algorithm>
  The <dfn method for="NavigationHistoryEntry">getState()</dfn> method steps are:

  1. If [=this=]'s [=relevant global object=]'s [=associated Document=] is not [=Document/fully active=], then return undefined.
  1. If [=this=]'s [=NavigationHistoryEntry/session history entry=]'s [=session history entry/navigation API state=] is null, then return undefined.
  1. Return [$StructuredDeserialize$]([=this=]'s [=NavigationHistoryEntry/session history entry=]'s [=session history entry/navigation API state=]).

  <p class="note">Unlike {{History/state|history.state}}, this will deserialize upon each access.

  <p class="note">This can in theory throw an exception, if attempting to deserialize a large {{ArrayBuffer}} when not enough memory is available.
</div>

The following are the [=event handlers=] (and their corresponding [=event handler event types=]) that must be supported, as [=event handler IDL attributes=], by objects implementing the {{NavigationHistoryEntry}} interface:

<table>
  <thead>
    <th>[=Event handler=]
    <th>[=Event handler event type=]
  <tbody>
    <tr>
      <td><dfn attribute for="NavigationHistoryEntry">onnavigateto</dfn>
      <td><dfn event for="NavigationHistoryEntry">navigateto</dfn>
    <tr>
      <td><dfn attribute for="NavigationHistoryEntry">onnavigatefrom</dfn>
      <td><dfn event for="NavigationHistoryEntry">navigatefrom</dfn>
    <tr>
      <td><dfn attribute for="NavigationHistoryEntry">onfinish</dfn>
      <td><dfn event for="NavigationHistoryEntry">finish</dfn>
    <tr>
      <td><dfn attribute for="NavigationHistoryEntry">ondispose</dfn>
      <td><dfn event for="NavigationHistoryEntry">dispose</dfn>
</table>

TODO: actually fire {{NavigationHistoryEntry/finish}}, {{NavigationHistoryEntry/navigateto}}, and {{NavigationHistoryEntry/navigatefrom}}.

<h2 id="navigate-patches">Patches to fire the {{Navigation/navigate}} event</h2>

The following section details monkeypatches to [[!HTML]] that cause the {{Navigation/navigate}} event to be fired appropriately, and for canceling the event to cancel the navigation. The first few sections detail slight tweaks to existing algorithms to pass through useful information into the navigation and history traversal algorithms. Then, [[#navigate-algorithm-patches]] contains the actual firing of the event.

<h3 id="form-patches">Form submission patches</h3>

To properly thread the form entry list from its creation through to {{NavigateEvent}}'s {{NavigateEvent/formData}} property, we need the following modifications:

<div algorithm="form navigate">
  Modify the <a spec="HTML">navigate</a> algorithm to take an [=entry list=] or null <dfn for="navigate">|entryList|</dfn> (default null), replacing its |navigationType| parameter. Then insert a step somewhere early in the algorithm to convert this back into the |navigationType| variable used by the [=in parallel=] section that is ultimately passed to [[CSP]]:

  1. Let |navigationType| be "`form-submission`" if |entryList| is non-null; otherwise, "`other`".
</div>

<div algorithm="plan to navigate">
  Modify the <a spec="HTML">plan to navigate</a> algorithm to take an additional optional argument |entryList| (default null). Then, modify the step which calls <a spec="HTML">navigate</a> to pass it along:

  1. <a spec="HTML">Navigate</a> <var ignore>target browsing context</var> to <var ignore>destination</var>, with <i>[=navigate/historyHandling=]</i> set to <var ignore>historyHandling</var> <del>and <i>[=navigate/navigationType=]</i> set to "`form-submission`"</del><ins><i>[=navigate/entryList=]</i> set to |entryList|</ins>.
</div>

<div algorithm="submit as entity body">
  Modify the <a spec="HTML">submit as entity body</a> algorithm to pass <var ignore>entry list</var> along to <a spec="HTML">plan to navigate</a> as a second argument.
</div>

<h3 id="user-initiated-patches">Browser UI/user-initiated patches</h3>

To more rigorously specify when a navigation is initiated from browser UI or by the user interacting with <{a}>, <{area}>, and <{form}> elements, both for the purposes of the {{NavigateEvent}}'s {{NavigateEvent/userInitiated}} property and for prohibiting interception of certain types of browser-UI-initiated navigations, we need the following modifications:

Introduce (right before the definition of the <a spec="HTML">navigate</a> algorithm) the concept of a <dfn>user navigation involvement</dfn>, which is one of the following:

: "<dfn for="user navigation involvement"><code>browser UI</code></dfn>"
:: The navigation was initiated by the user via browser UI mechanisms
: "<dfn for="user navigation involvement"><code>activation</code></dfn>"
:: The navigation was initiated by the user via the [=EventTarget/activation behavior=] of an element
: "<dfn for="user navigation involvement"><code>none</code></dfn>"
:: The navigation was not initiated by the user

Define the <dfn for="Event">user navigation involvement</dfn> for an {{Event}} |event| as "<code>[=user navigation involvement/activation=]</code>" if |event|'s {{Event/isTrusted}} attribute is initialized to true, and "<code>[=user navigation involvement/none=]</code>" otherwise.

Modify the <a spec="HTML">navigate</a> algorithm to take an optional named argument <dfn for="navigate"><var ignore>userInvolvement</var></dfn> (default "<code>[=user navigation involvement/none=]</code>"). Then, update the paragraph talking about browser-UI initiated navigation as follows:

<blockquote>
  A user agent may provide various ways for the user to explicitly cause a browsing context to <a spec="HTML">navigate</a>, in addition to those defined in this specification.<ins> Such cases must set the <i>[=navigate/userInvolvement=]</i> argument to "<code>[=user navigation involvement/browser UI=]</code>".</ins>
</blockquote>

<p class="note">This infrastructure partially solves <a href="https://github.com/whatwg/html/issues/5381">whatwg/html#5381</a>, and it'd be ideal to update the \`<a http-header><code>Sec-Fetch-Site</code></a>\` spec at the same time.</p>

Modify the [=navigate to a fragment=] algorithm to take a new <var ignore>userInvolvement</var> argument. Then, update the call to it from <a spec="HTML">navigate</a> to set <i>[=navigate/userInvolvement=]</i> to this <var ignore>userInvolvement</var> value.

Modify the <a spec="HTML">traverse the history by a delta</a> argument to take an optional named argument <dfn for="traverse the history by a delta"><var ignore>userInvolvement</var></dfn> (default "<code>[=user navigation involvement/none=]</code>"). Then, update the paragraph talking about user-initiated navigation as follows:

<blockquote>
  When the user navigates through a [=browsing context=], e.g. using a browser's back and forward buttons, the user agent must <a spec="HTML">traverse the history by a delta</a> with a delta equivalent to the action specified by the user<del> and</del><ins>,</ins> the browsing context being operated on<ins>, and <i>[=traverse the history by a delta/userInvolvement=]</i> set to "<code>[=user navigation involvement/browser UI=]</code>"</ins>.
</blockquote>

<hr>

Modify the <a spec="HTML">follow the hyperlink</a> algorithm to take a new <var ignore>userInvolvement</var> argument. Then, update the call to it from <a spec="HTML">navigate</a> to set <i>[=navigate/userInvolvement=]</i> to this <var ignore>userInvolvement</var> value.

<div algorithm="area activation behavior">
  Modify the [=EventTarget/activation behavior=] of <{area}> elements by introducing the |event| argument and replacing the <a spec="HTML">follow the hyperlink</a> step with the following:

  1. Otherwise, <a spec="HTML">follow the hyperlink</a> created by <var ignore>element</var> with the [=Event/user navigation involvement=] for |event|.
</div>

<div algorithm="a activation behavior">
  Modify the [=EventTarget/activation behavior=] of <{a}> elements by replacing its <a spec="HTML">follow the hyperlink</a> step with the following:

  1. Otherwise, <a spec="HTML">follow the hyperlink</a> created by <var ignore>element</var> with the [=Event/user navigation involvement=] for <var ignore>event</var>.
</div>

Expand the section on "<a href="https://html.spec.whatwg.org/multipage/semantics.html#providing-users-with-a-means-to-follow-hyperlinks-created-using-the-link-element">Providing users with a means to follow hyperlinks created using the `link` element</a>" by adding the following sentence:

<blockquote><ins>Such invocations of <a spec="HTML">follow the hyperlink</a> algorithm must set the <i>[=navigate/userInvolvement=]</i> argument to "<code>[=user navigation involvement/browser UI=]</code>".</ins></blockquote>

<hr>

Modify the <a spec="HTML">plan to navigate</a> algorithm to take a <var ignore>userInvolvement</var> argument. Then, update the call to it from <a spec="HTML">navigate</a> to set <i>[=navigate/userInvolvement=]</i> to this <var ignore>userInvolvement</var> value.

Modify the <a spec="HTML" lt="submitted">submit</a> algorithm to take an optional <var ignore>userInvolvement</var> argument (default "<code>[=user navigation involvement/none=]</code>").  Have the <a spec="HTML" lt="submitted">submit</a> algorithm pass along its value to all invocations of <a spec="HTML">plan to navigate</a>.

Modify the definition of the [=EventTarget/activation behavior=] for <{input}> elements to take an <var ignore>event</var> argument. Then, pass along this argument to the invocation of the <a spec="HTML">input activation behavior</a>.

Modify the Submit Button state's <a spec="HTML">input activation behavior</a> by having it take an <var ignore>event<var> argument and pass along the [=Event/user navigation involvement=] for <var ignore>event</var> as the final argument when it calls <a spec="HTML" lt="submitted">submit</a>.

Modify the Image Button state's <a spec="HTML">input activation behavior</a> by having it take an <var ignore>event<var> argument and pass along the [=Event/user navigation involvement=] for <var ignore>event</var> as the final argument when it calls <a spec="HTML" lt="submitted">submit</a>.

Modify the <{button}> element's [=EventTarget/activation behavior=] by having it take an <var ignore>event</var> argument and, in the Submit Button case, to pass along the [=Event/user navigation involvement=] for <var ignore>event</var> as the final argument when it calls <a spec="HTML" lt="submitted">submit</a>.

Modify the no-<a spec="HTML">submit button</a> case for <a href="https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#implicit-submission">implicit form submission</a> to pass along "<code>[=user navigation involvement/activation=]</code>" as the final argument when it calls <a spec="HTML" lt="submitted">submit</a>.

<p class="note">The case of implicit submission when a submit button is present is automatically taken care of because it fires a (trusted) click event at the submit button.</p>

<h3 id="navigate-algorithm-patches">Navigation algorithm updates</h3>

With the above infrastructure in place, we can actually fire and handle the {{Navigation/navigate}} event in the following locations:

<div algorithm="shared history push/replace steps">
  Modify the <a>shared history push/replace state steps</a> by inserting the following steps right before the step that runs the [=URL and history update steps=].

  1. Let |navigation| be <var ignore>history</var>'s [=relevant global object=]'s [=Window/navigation API=].
  1. Let |continue| be the result of [=firing a non-traversal navigate event=] at |navigation| with <i>[=fire a non-traversal navigate event/navigationType=]</i> set to <var ignore>historyHandling</var>, <i>[=fire a non-traversal navigate event/isSameDocument=]</i> set to true, <i>[=fire a non-traversal navigate event/destinationURL=]</i> set to <var ignore>newURL</var>, and <i>[=fire a non-traversal navigate event/classicHistoryAPISerializedData=]</i> set to <var ignore>serializedData</var>.
  1. If |continue| is false, then return.
</div>

<div algorithm="navigate to a fragment">
  Modify the [=navigate to a fragment=] algorithm by prepending the following steps. Recall that per [[#user-initiated-patches]] we have introduced a |userInvolvement| argument.

  1. Let |navigation| be <var ignore>navigable</var>'s [=navigable/active window=]'s [=Window/navigation API=].
  1. Let |continue| be the result of [=firing a non-traversal navigate event=] at |navigation| given with <i>[=fire a non-traversal navigate event/navigationType=]</i> set to <var ignore>historyHandling</var>, <i>[=fire a non-traversal navigate event/isSameDocument=]</i> set to true, <i>[=fire a non-traversal navigate event/userInvolvement=]</i> set to |userInvolvement|, and <i>[=fire a non-traversal navigate event/destinationURL=]</i> set to <var ignore>url</var>.
  1. If |continue| is false, return.
</div>

<div algorithm="navigate" id="navigate-modifications">
  Modify the <a spec="HTML">navigate</a> algorithm to take an optional <dfn for="navigate">|navigationAPIState|</dfn> argument (default null). Then, insert the following steps right before the step which goes [=in parallel=]. (Recall that per [[#user-initiated-patches]] we have introduced |userInvolvement| argument, and per [[#form-patches]] we have introduced an |entryList| argument.)

  1. Let |navigation| be <var ignore>browsingContext</var>'s [=browsing context/active window=]'s [=Window/navigation API=].
  1. If all of the following are false:
    * <var ignore>historyHandling</var> is "<a for="history handling behavior">`entry update`</a>"
    * <var ignore>userInvolvement</var> is "<code>[=user navigation involvement/browser UI=]</code>"
    * <var ignore>browsingContext</var>'s [=active document=]'s [=Document/origin=] is not [=same origin-domain=] with the [=source browsing context=]'s [=active document=]'s [=Document/origin=]
    * <var ignore>browsingContext</var> is <a spec="HTML">still on its initial `about:blank` `Document`</a>
    * <var ignore>resource</var> is a [=request=], and <var ignore>resource</var>'s [=request/URL=]'s [=url/scheme=] is not a [=fetch scheme=]

    then:

      1. Let |navigationType| be the result of [=converting a history handling behavior to a navigation type=] given <var ignore>historyHandling</var>.
      1. Let |continue| be the result of [=firing a non-traversal navigate event=] at |navigation| with <i>[=fire a non-traversal navigate event/navigationType=]</i> set to |navigationType|, <i>[=fire a non-traversal navigate event/isSameDocument=]</i> set to false, <i>[=fire a non-traversal navigate event/userInvolvement=]</i> set to |userInvolvement|, <i>[=fire a non-traversal navigate event/formDataEntryList=]</i> set to |entryList|, <i>[=fire a non-traversal navigate event/destinationURL=]</i> set to <var ignore>url</var>, and <i>[=fire a non-traversal navigate event/state=]</i> set to |navigationAPIState|.
      1. If |continue| is false, return.

    <p class="note">"<a for="history handling behavior">`entry update`</a>" is excluded since {{Navigation/navigate}} would have fired earlier as part of <a spec="HTML">traversing the history by a delta</a>.

    <p class="note">"<code>[=user navigation involvement/browser UI=]</code>" or [=same origin-domain|cross origin-domain=] navigations that cause [=navigate to a fragment|fragment navigations=] <em>do</em> fire the {{Navigation/navigate}} event; those are handled as part of the [=navigate to a fragment=] algorithm called earlier in <a spec="HTML">navigate</a>, which is not guarded by this condition.
</div>

Expand the section of the navigation/traversal response handling which deals with 204s, 205s, and `Content-Disposition: attachment` responses with the following note:

<div class="note">
  These kinds of failed navigations or traversals will not be signaled to the navigation API (e.g., through the promises of any [=Navigation/ongoing navigation=], or the {{NavigationTransition/finished|navigation.transition.finished}} promise, or the {{Navigation/navigateerror}} event). Doing so would leak information about the timing of responses from other origins, in the cross-origin case, and providing different results in the cross-origin versus same-origin cases was deemed too confusing.

  However, implementations could use this opportunity to clear any promise handlers for the {{NavigationTransition/finished|navigation.transition.finished}} promise, as they are guaranteed at this point to never run. And, they might wish to [=report a warning to the console=] if any part of the navigation API initiated these navigations, to make it clear to the web developer the reason why their promises will never settle and events will never fire.
</div>

<div algorithm>
  To <dfn>convert a history handling behavior to a navigation type</dfn> given a <a spec="HTML">history handling behavior</a> |historyHandling|:

  1. [=Assert=]: |historyHandling| is not "<a spec="HTML" for="history handling behavior">`entry update`</a>".
  1. Return the result of switching on |historyHandling|:

    <dl class="switch">
    : "<a spec="HTML" for="history handling behavior">`reload`</a>"
    :: "{{NavigationType/reload}}"
    : "<a spec="HTML" for="history handling behavior">`replace`</a>"
    :: "{{NavigationType/replace}}"
    : "<a spec="HTML" for="history handling behavior">`default`</a>"
    :: "{{NavigationType/push}}"
</div>

<h3 id="navigate-event-traversal-patches">History traversal updates</h3>

<div algorithm="traverse the history by a delta">
  The <a spec="HTML">traverse the history by a delta</a> algorithm will be totally re-written as part of <a href="https://github.com/whatwg/html/pull/6315">the session history rewrite</a>. Here we reproduce the final version of the algorithm, after both that rewrite and with appropriate navigation API updates. Recall that per [[#user-initiated-patches]] we have introduced a |userInvolvement| argument, so the arguments are now |delta|, |source browsing context|, and |userInvolvement|.

  1. Let |traversable| be |source browsing context|'s [=browsing context/containing navigable=]'s [=navigable/traversable navigable=].
  1. Let |initiatorOrigin| be |source browsing context|'s [=active document=]'s [=Document/origin=].
  1. [=parallel queue/enqueue steps|Enqueue the following steps=] to |traversable|'s [=traversable navigable/session history traversal queue=]:
    1. Let |allSteps| be the result of [=traversable navigable/getting all history steps=] for |traversable|.
    1. Let |currentStepIndex| be the index of the [=traversable navigable/current session history step=] within |allSteps|.
    1. Let |targetStepIndex| be |currentStepIndex| plus |delta|.
    1. If |allSteps|[|targetStepIndex|] does not [=set/exist=], then return.
    1. [=Apply the history step=] |allSteps|[|targetStepIndex|] to |traversable| with true, <var ignore>step</var>, |initiatorOrigin|, and |userInvolvement|.
</div>

<div algorithm="apply the history step">
  Modify the <a spec="HTML">apply the history step</a> algorithm as follows. Inside the loop over each <var ignore>navigable</var> of <var ignore>toTraverse</var>, inside the task that is posted, after the check if |targetEntry|'s document is |previousDocument| that might abort the algorithm, add the following steps:

  1. [=Fire a traversal navigate event=] at |previousDocument|'s [=relevant global object=]'s [=Window/navigation API=] with <i>[=fire a traversal navigate event/destinationEntry=]</i> set to |targetEntry| and <i>[=fire a traversal navigate event/userInvolvement=]</i> set to <var ignore>userInvolvement</var>.
</div>

<h3 id="navigate-event-download-patches">Download a hyperlink updates</h3>

The current specification for <a spec="HTML" lt="download the hyperlink">downloading a hyperlink</a> has several known issues, most notably <a href="https://github.com/whatwg/html/issues/5548">whatwg/html#5548</a> which indicates that the specification should probably be merged into the general <a spec="HTML" lt="navigate">navigation</a> algorithm.

For the purposes of the navigation API, we need to fire the appropriate {{Navigation/navigate}} event, with {{NavigateEvent/downloadRequest}} set to the correct value. We could rigorously detail the ways to modify the current spec to accomplish this. But, given that the current spec will be rewritten anyway, this is probably not very useful. So until such a time as we can properly investigate and rewrite the <a spec="HTML" lt="download the hyperlink">downloading a hyperlink</a> algorithm, we describe here the expected behavior in a less-formal fashion. We believe this is still enough to get interoperability.

<div algorithm="download the hyperlink">
<ul>
  <li><p>Ensure that the algorithm gets an appropriate [=user navigation involvement=] value, |userInvolvement|, passed to it. This is similar to the modifications for the <a spec="HTML">follow the hyperlink</a> algorithm described in [[#user-initiated-patches]]. One key difference is that, for the case where the user indicates a preference for downloading, |userInvolvement| must be "<code>[=user navigation involvement/browser UI=]</code>", even if it is triggered as part of [=EventTarget/activation behavior=].

  <li><p>Separate out the sandboxing checks in <a spec="HTML">allowed to download</a> from the user-safeguarding checks. If the sandboxing checks fail, then the user agent must not fire a {{Navigation/navigate}} event. Whereas, the user-safeguarding checks generally happen later, probably [=in parallel=].

  <li>
    <p>Before we reach the point at which it's time to actually go in parallel and fetch content from the server, and after the <a spec="HTML">cannot navigate</a> check, the synchronously-possible part of the <a spec="HTML">allowed to download</a> check, the URL parsing step, and the hyperlink suffix appending step, run the equivalent of the following:

    1. If |userInvolvement| is not "<code>[=user navigation involvement/browser UI=]</code>", then:
      1. Let |navigation| be |subject|'s [=relevant global object=]'s [=Window/navigation API=].
      1. Let |filename| be the value of |subject|'s <{a/download}> attribute.
      1. Let |continue| be the result of [=firing a download-requested navigate event=] at |navigation| with <i>[=fire a download-requested navigate event/destinationURL=]</i> set to |URL|, <i>[=fire a download-requested navigate event/userInvolvement=]</i> set to |userInvolvement|, and <i>[=fire a download-requested navigate event/filename=]</i> set to |filename|.
      1. If |continue| is false, then return.

    <p>Here the variables |subject| and |URL| refer to the same things they currently do in the <a spec="HTML">download the hyperlink</a> algorithm, i.e. the <{a}> or <{area}> element in question, and the parsed [=URL=].

    <p>If we end up triggering the <a spec="HTML">navigate</a> algorithm from the <a spec="HTML">download the hyperlink</a> algorithm, then these steps won't be directly incorporated into the <a spec="HTML">download the hyperlink</a> algorithm. Instead, the modifications in [[#navigate-algorithm-patches]] will get a bit more complicated, so as to use [=fire a download-requested navigate event=] with the above arguments, instead of [=fire a non-traversal navigate event=], for downloads.
</ul>
</div>

<h2 id="session-history-patches">Patches to session history</h2>

This section details monkeypatches to [[!HTML]] to track appropriate data for associating a {{Navigation}} with a [=session history entry=].

<h3 id="session-history-new-she-fields">New [=session history entry=] items</h3>

Each [=session history entry=] gains the following new [=struct/items=]:

* <dfn for="session history entry">origin</dfn>, an [=origin=]

* <dfn for="session history entry">navigation API key</dfn>, a string, initially set to the result of [=generating a random UUID=]

* <dfn for="session history entry">navigation API ID</dfn>, a string, initially set to the result of [=generating a random UUID=]

* <dfn for="session history entry">navigation API state</dfn>, which is [=serialized state=] or null, initially null

<h3 id="session-history-patches-key">Carrying over the navigation API key</h3>

<div algorithm="update the session history with the new page key patch">
  Update the <a spec="HTML">update the session history with the new page</a> algorithm's "<a for="history handling behavior">`replace`</a>" case by adding the following step after the construction of |newEntry|:

  1. If |newEntry|'s [=session history entry/origin=] is the [=same origin|same=] as |sessionHistory|'s [=session history/current entry=]'s [=session history entry/origin=], then set |newEntry|'s [=session history entry/navigation API key=] to |sessionHistory|'s [=session history/current entry=]'s [=session history entry/navigation API key=].
</div>

<h3 id="session-history-patches-state">Carrying over the navigation API state</h3>

<div algorithm="navigate to a fragment state patch">
  Update the [=navigate to a fragment=] algorithm by updating the step which creates a new [=session history entry=] to carry over the [=session history entry/navigation API state=] from the [=navigable/active session history entry=] as well.
</div>

<h3 id="session-history-patches-origin">Tracking the [=session history entry/origin=] member</h3>

Update the <a spec="HTML">update the session history with the new page</a> algorithm's "<a for="history handling behavior">`replace`</a>" and "<a for="history handling behavior">`default`</a>" cases to set <var ignore>newEntry</var>'s [=session history entry/origin=] to <var ignore>newDocument</var>'s [=Document/origin=] as part of its creation.

Update the <a spec="HTML">navigate to a fragment</a> algorithm to set the new [=session history entry=]'s [=session history entry/origin=] to the [=session history/current entry=]'s [=session history entry/document=]'s [=Document/origin=].

Update the <a spec="HTML">URL and history update steps</a> algorithm to set the new [=session history entry=]'s [=session history entry/origin=] to <var ignore>document</var>'s [=Document/origin=].

Potentially update the <a spec="HTML">traverse the history</a> algorithm to consult the new [=session history entry/origin=] field, instead of checking the [=session history entry/document=]'s [=Document/origin=], since the [=session history entry/document=] can disappear?? Needs further investigation.

<h3 id="session-history-patches-policy-container">Tracking the [=session history entry/policy container=] member more often</h3>

The [=session history entry/policy container=] field of the [=session history entry=] is null, except when we <a spec="HTML">require storing the policy container in history</a>. The specification for {{NavigationHistoryEntry/url|NavigationHistoryEntry.url}} requires the relevant [=/referrer policy=] to be accessible for all entries, not just some.

So, update the HTML Standard to always store the policy container on the [=session history entry=], and then only use it in the <a spec="HTML">determine navigation params policy container</a> algorithm in the cases currently covered by the <a spec="HTML">require storing the policy container in history</a> algorithm.

<h3 id="session-history-patches-update">Updating the {{Navigation}} object</h3>

<div algorithm="update document for history step application patch">
  Update the [=update document for history step application=] algorithm by adding the following step nested inside the <var ignore>documentsEntryChanged</var> check, after restoring the history object state but before firing {{Window/popstate}}:

  1. [=Navigation/Update the entries=] of <var ignore>document</var>'s [=relevant global object=]'s [=Window/navigation API=] given "{{NavigationType/traverse}}".

     <p class="note">We can always pass "{{NavigationType/traverse}}" here because this call will result in {{Navigation/currententrychange}} firing only for traversals; new document creation will not fire {{Navigation/currententrychange}}, and same-document non-traversal navigations will have already updated {{Navigation/currentEntry|navigation.currentEntry}}.

     <p class="note">This means any {{Navigation/currententrychange}} event and {{NavigationHistoryEntry/dispose}} events will fire before the {{Window/popstate}} and {{Window/hashchange}} events.
</div>

<hr>

<div algorithm="reactivate patch">
  Update the [=reactivate=] algorithm by adding the following step before the final one which checks the current document readiness:

  1. [=Navigation/Update the entries=] of <var ignore>document</var>'s [=relevant global object=]'s [=Window/navigation API=] given null and true.

     <p class="note">Passing true means that any {{NavigationHistoryEntry/dispose}} events will fire after the {{Window/pageshow}} event, but this step being before the one below means that during the {{Window/pageshow}} event {{Navigation/entries()|navigation.entries()}} and {{Navigation/currentEntry|navigation.currentEntry}} will have correctly-updated values. This split is motivated by a desire to have {{Window/pageshow}} be the first event a page receives upon reactivation.
</div>

<hr>

<div algorithm="URL and history update steps update patch">
  Update the [=URL and history update steps=] by appending the following step right after setting the [=navigable/active session history entry=]:

  1. [=Navigation/Update the entries=] of <var ignore>document</var>'s [=relevant global object=]'s [=Window/navigation API=] given <var ignore>historyHandling</var>.
</div>

<hr>

<div algorithm="navigate to a fragment update the entries patch">
  Update [=navigate to a fragment=] by appending the following step right after setting the [=navigable/active session history entry=]:

  1. [=Navigation/Update the entries=] of <var ignore>navigable</var>'s [=navigable/active window=]'s [=Window/navigation API=] given <var ignore>historyHandling</var>.
</div>

<hr>

We do not [=Navigation/update the entries=] when initially <a spec="HTML">creating a new browsing context</a>, as we intentionally don't want to include the initial `about:blank` {{Document}} in any navigation history entry list.

<h2 id="other-patches">Other patches</h2>

<h3 id="focus-patches">Focus tracking</h3>

To support the {{NavigationTransitionWhileOptions/focusReset}} option, the following patches need to be made:

Update the <a spec="HTML">focusing steps</a> to, right before they call the <a spec="HTML">focus update steps</a>, set the {{Document}}'s [=relevant global object=]'s [=Window/navigation API=]'s [=Navigation/focus changed during ongoing navigation=] to true.

Update the <a spec="HTML">focus fixup rule</a> to additionally set the {{Document}}'s [=relevant global object=]'s [=Window/navigation API=]'s [=Navigation/focus changed during ongoing navigation=] to false.

<p class="note">In combination, these ensure that the [=Navigation/focus changed during ongoing navigation=] reflects any developer- or user-initiated focus changes, unless they were undone by the focus fixup rule. For example, if the user moved focus to an element which was removed from the DOM while the promise passed to {{NavigateEvent/transitionWhile()}} was settling, then that would not count as a focus change.

<h3 id="scroll-restoration-patches">Scroll restoration</h3>

To support the {{NavigationTransitionWhileOptions/scrollRestoration}} option, as well as to fix <a href="https://github.com/whatwg/html/issues/7517">whatwg/html#7517</a>, the following patches need to be made:

Add a boolean, <dfn for="Document">has been scrolled by the user</dfn>, initially false, to {{Document}} objects. State that if the user scrolls the document, the user agent must set that document's [=Document/has been scrolled by the user=] to true. Modify the <a spec="HTML">unload a document</a> algorithm to set this back to false.

<div algorithm>
  Define the process of <dfn>restoring scroll position data</dfn> given a [=session history entry=] |entry| as follows:

  1. Let |document| be |entry|'s [=session history entry/document=].
  1. If |document|'s [=Document/has been scrolled by the user=] is true, then the user agent should return.
  1. The user agent should attempt to use |entry|'s [=session history entry/scroll position data=] to restore the scroll positions of |document|'s <a spec="HTML">restorable scrollable regions</a>. The user agent may continue to attempt to do so periodically, until |document|'s [=Document/has been scrolled by the user=] becomes true.

     <p class="note">This is formulated as an <em>attempt</em>, which is potentially repeated until success or until the user scrolls, due to the fact that relevant content indicated by the [=session history entry/scroll position data=] might take some time to load from the network.

     <p class="note">Scroll restoration might be affected by scroll anchoring. [[CSS-SCROLL-ANCHORING-1]]
</div>

<div algorithm="restore persisted state">
  With this in place, modify the <a spec="HTML">restore persisted state</a> algorithm's first step to read as follows:

  1. If |entry|'s [=session history entry/scroll restoration mode=] is "{{ScrollRestoration/auto}}", and |entry|'s [=session history entry/document=]'s [=relevant global object=]'s [=Window/navigation API=]'s [=Navigation/suppress normal scroll restoration during ongoing navigation=] is false, then [=restore scroll position data=] given |entry|.

  In addition to the existing note, add the following one:

  <p class="note">If the [=Navigation/suppress normal scroll restoration during ongoing navigation=] boolean is true, then [=restoring scroll position data=] might still happen at a later point, as part of [=potentially perform scroll restoration|potentially performing scroll restoration=] for the relevant {{Navigation}} object, or via a {{NavigateEvent/restoreScroll()|navigateEvent.restoreScroll()}} method call.
</div>

<h3 id="cancel-navigation">Canceling navigation and traversals</h3>

The existing HTML specification discusses canceling a navigation and traverals in a few places. However, the process is not very well-defined, and per <a href="https://github.com/whatwg/html/issues/6927">whatwg/html#6927</a>, is not very interoperable. We plan to make it more rigorous, after the <a href="https://github.com/whatwg/html/issues/5767">session history rewrite</a> lands.

Specifically, the spec uses a few phrases:

* "Cancel any existing but not-yet-mature attempts to navigate a [=browsing context=]", in the <a spec="HTML">navigate</a> algorithm and the <a spec="HTML">traverse the history by a delta</a> algorithm. This cancels any ongoing navigations, including history traversal navigations which have made their way back into the main event loop to perform an "<a for="history handling behavior">`entry update`</a>" navigation.

* "Cancel that navigation", in the <a spec="HTML">stop document loading</a> algorithm. This is likely supposed to work the same as the above?

* "Remove any tasks queued by the history traversal task source that are associated with any Document objects in the top-level browsing context's document family." This cancels queued-up traversals that have not yet made their way back to the main event loop. This is currently called from any same-document navigations, i.e. the <a spec="HTML">URL and history update steps</a> and <a spec="HTML">navigating to a fragment</a>, as well as as part of <a spec="HTML">traverse the history</a> for cross-document traversals.

<a href="https://github.com/whatwg/html/issues/6927">whatwg/html#6927</a> reveals that implementations don't really follow this breakdown. In particular, modulo one case in Firefox, traversals are only canceled as part of [=browsing context/discarding=] a browsing context.

That leaves us with two main operations: canceling not-yet-mature navigations, and dealing with browsing context discarding.

<hr>

The navigation API introduces a new complication here, which is that a navigation might have <a spec="HTML">matured</a> but still be "ongoing", in the sense of [[#ongoing-state]]. That is, consider a case such as:

<xmp highlight="js">
navigation.addEventListener("navigate", e => {
  e.transitionWhile(new Promise(r => setTimeout(r, 1_000)));
  e.signal.addEventListener("abort", () => { ... });
});

const p = navigation.navigate("#1");

setTimeout(() => window.stop(), 500);
</xmp>

Without the {{Navigation/navigate}} event handler, this kind of synchronous fragment navigation would be straightforward: it matures synchronously, and the {{Window/stop()}} call does nothing. But because we have used the {{Navigation/navigate}} handler to indicate that the navigation is still ongoing, we want the {{Window/stop()}} call to [=finalize with an aborted navigation error|finalize that navigation with an aborted navigation error=], in particular causing `p` to reject and the {{AbortSignal/abort}} event to fire on `e.signal`.

<hr>

The integration is then as follows:

* Wherever the spec ends up canceling not-yet-mature navigations for a [=browsing context=] |bc|, we also [=inform the navigation API about canceling navigation=] in |bc|. (Regardless of whether or not there are any not-yet-mature navigations still in flight.)

* When the spec [=browsing context/discards=] a [=browsing context=] |bc|, we also [=inform the navigation API about browsing context discarding=] given |bc|. (Regardless of whether or not there are any not-yet-mature navigations still in flight, or any traversals queued up.)

<h2 id="security-privacy">Security and privacy considerations</h2>

<div nonnormative>

<h3 id="sp-cross-site-tracking">Cross-site tracking</h3>

This specification does not enable any new cross-site tracking capabilities. This is largely because the {{Navigation/entries()|navigation.entries()}} method only returns information about the same-origin, same-frame history entries.

In more detail:

* The storage of [=session history entry/navigation API state=] in session history entries is a convenience with no tracking abilities, since the state is only accessible same-origin. That is, it provides the same power as APIs such as <a href="https://github.com/privacycg/storage-partitioning">partitioned</a> {{WindowSessionStorage/sessionStorage}}.
* The browser-generated UUIDs stored as [=session history entry/navigation API ID=] and [=session history entry/navigation API key=] live only for the lifetime of a browsing session; they are not stable user-specific identifiers, and in particular are not the same across different frames.

<h3 id="sp-navigation-monitoring-interception">Navigation monitoring and interception</h3>

Through the {{Navigation/navigate}} event, this API allows web developers to monitor navigations, and in some cases replace cross-document navigations with same-document ones, or prevent the navigation from going through.

Care has been taken to avoid this being dangerous, or giving insight into user behavior that would not otherwise be available to the site. In particular:

* It is not possible to prevent a back/forward navigation, as this could lead to trapping the user on the page. (We would like to make this possible in the future by adding additional security mitigations; see <a href="https://github.com/WICG/navigation-api/issues/32">#32</a>.)

* Navigations initiated from cross-origin-domain frames do not fire {{Navigation/navigate}} events. An example would be such a frame calling `window.open(url, name)` with `name` targeting the current frame.

* Navigations initiated using browser UI, apart from back/forward navigations or fragment-only navigations, do not fire {{Navigation/navigate}} events. An example would be the user directly editing the URL bar.

We also have a few more restrictions worth noting, which don't directly address any attack, but reduce the surface area and complexity of the navigation interception feature, which can have indirect security benefits:

* Navigations initiated toward non-[=fetch scheme=] URLs, such as `javascript:` URLs, do not fire {{Navigation/navigate}} events.

* Navigations initiated on the initial `about:blank` document do not fire {{Navigation/navigate}} events.

* Navigations initiated by {{Document/open()|document.open()}} do not fire {{Navigation/navigate}} events.

* Cross-document traversals cannot be intercepted and converted into same-document traversals.

<h3 id="sp-url-updates">URL updates</h3>

This API, like {{History/pushState()|history.pushState()}} and {{History/replaceState()|history.replaceState()}}, gives the ability to change what is shown in the browser's URL bar. This is part of the navigation interception capability mentioned in the previous section.

This is not dangerous, because the navigation API is subject to the same restrictions as the classic history API: namely, the page's URL can only be changed if the page <a spec="HTML">can have its URL rewritten</a> to the new URL. So in particular no authority-granting components, such as the site or origin, are impacted.

<h3 id="sp-ua-ui">Other user agent UI</h3>

This specification does not add any requirements on how user agents implement their user interfaces. (Even the URL bar updates mentioned in the previous section are not technically part of the specification; the specification only governs the return value of other APIs, like {{Location/href|location.href}}.) This preserves the ability for user agents to protect users through UI changes.

For example, today some user agents take advantage of this flexibility to skip certain history entries when pressing the back button. This can be used to avoid back-trapping by abusive sites, by skipping entries with which the user did not interact and thus allowing the user to escape abusive sites faster.

The navigation API preserves all of these freedoms.

</div>
