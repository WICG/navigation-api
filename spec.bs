<pre class="metadata">
Title: App History API
Shortname: app-history
Repository: WICG/app-history
Inline Github Issues: true
Group: WICG
Status: CG-DRAFT
Level: 1
URL: https://wicg.github.io/app-history/
Boilerplate: omit conformance, omit feedback-header
Editor: Domenic Denicola, Google https://www.google.com/, d@domenic.me, https://domenic.me/
Abstract: The app history API provides a web application-focused way of managing same-origin same-frame history entries and navigations.
!Participate: <a href="https://github.com/WICG/app-history">GitHub WICG/app-history</a> (<a href="https://github.com/WICG/app-history/issues/new">new issue</a>, <a href="https://github.com/WICG/app-history/issues?state=open">open issues</a>)
!Commits: <a href="https://github.com/WICG/app-history/commits/master/spec.bs">GitHub spec.bs commits</a>
Complain About: accidental-2119 yes, missing-example-ids yes
Indent: 2
Default Biblio Status: current
Markup Shorthands: markdown yes
Assume Explicit For: yes
</pre>

<pre class="link-defaults">
spec: html; type: element; text: a
</pre>
<pre class="anchors">
spec: html; urlPrefix: https://html.spec.whatwg.org/multipage/
  type: dfn
    text: serialized state; url: history.html#serialized-state
    text: session history; url: history.html#session-history
    text: session history entry; url: history.html#session-history-entry
    for: URL and history update steps
      text: serializedData; url: history.html#uhus-serializeddata
      text: isPush; url: history.html#uhus-ispush
    for: session history
      text: current entry; url: history.html#current-entry
    for: session history entry
      text: document; url: history.html#she-document
      text: URL; url: history.html#she-url
    for: history handling behavior
      text: default; url: browsing-the-web.html#hh-default
      text: reload; url: browsing-the-web.html#hh-reload
      text: replace; url: browsing-the-web.html#hh-replace
      text: entry update; url: browsing-the-web.html#hh-entry-update
    for: navigate
      text: historyHandling; url: browsing-the-web.html#navigation-hh
      text: navigationType; url: browsing-the-web.html#navigation-navigationtype
      text: exceptionsEnabled; url: browsing-the-web.html#exceptions-enabled
  type: method
    for: Document; text: open(unused1, unused2); url: multipage/dynamic-markup-insertion.html#dom-document-open
spec: html; urlPrefix: https://whatpr.org/html/6315/
  type: dfn
    text: traversable navigable; for: navigable; url: history.html#nav-traversable
    text: current session history entry; for: navigable; url: history.html#nav-current-history-entry
    text: active session history entry; for: navigable; url: history.html#nav-active-history-entry
    text: get the session history entries; for: navigable; url: history.html#getting-session-history-entries
    text: session history traversal queue; for: traversable navigable; url: history.html#tn-session-history-traversal-queue
    text: current session history step; for: traversable navigable; url: history.html#tn-current-session-history-step
    text: get all history steps; for: traversable navigable; url: history.html#getting-all-history-steps
    text: step; for: session history entry; url: history.html#she-step
    text: apply the history step; url: history.html#apply-the-history-step
    text: checkForUserCancelation; for: apply the history step; url: history.html#apply-the-history-step
    text: initiatorToCheck; for: apply the history step; url: history.html#apply-the-history-step
    text: containing navigable; for: browsing context; url: browsers.html#bc-navigable
    text: session; for: browsing context group; url: browsers.html#bcg-session
    text: active document; for: navigable; url: history.html#nav-document
    text: navigable; url: history.html#navigable
spec: uuid; type: dfn; urlPrefix: https://wicg.github.io/uuid/
  text: generate a random UUID; url: #dfn-generate-a-random-uuid
</pre>

<style>
.selected-text-file-an-issue {
  position: fixed;
  bottom: 0;
  right: 0;
  background: rgba(255, 255, 255, 0.8);
  font-size: smaller;
  padding: 4px 10px;
  z-index: 4;
}

dfn var {
  font-style: italic;
}

table {
  margin: 1em 0;
}

/* WHATWG-style <hr>s, instead of WICG-style. Specific selector is necessary to override WICG styles. */
:not(.head) > :not(.head) + hr {
  display: block;
  background: none;
  border: none;
  padding: 0;
  margin: 3em 0;
  height: auto;
}
:not(.head) > :not(.head) + hr::before {
  content: none;
}

/* domintro from https://resources.whatwg.org/standard.css */
.domintro {
  position: relative;
  color: green;
  background: #DDFFDD;
  margin: 2.5em 0 2em 0;
  padding: 1.5em 1em 0.5em 2em;
}

.domintro dt, .domintro dt * {
  color: black;
  font-size: inherit;
}
.domintro dd {
  margin: 0.5em 0 1em 2em; padding: 0;
}
.domintro dd p {
  margin: 0.5em 0;
}
.domintro::before {
  content: 'For web developers (non-normative)';
  background: green;
  color: white;
  padding: 0.15em 0.25em;
  font-style: normal;
  position: absolute;
  top: -0.8em;
  left: -0.8em;
}
</style>

<script src="https://resources.whatwg.org/file-issue.js" async></script>

<h2 id="global">The {{AppHistory}} class</h2>

<xmp class="idl">
partial interface Window {
  readonly attribute AppHistory appHistory;
};
</xmp>

Each {{Window}} object has an associated <dfn for="Window">app history</dfn>, which is a new {{AppHistory}} instance created alongside the {{Window}}.

The <dfn attribute for="Window">appHistory</dfn> getter steps are to return [=this=]'s [=Window/app history=].

<xmp class="idl">
[Exposed=Window]
interface AppHistory : EventTarget {
  attribute AppHistoryEntry? current;
  sequence<AppHistoryEntry> entries();

  readonly attribute boolean canGoBack;
  readonly attribute boolean canGoForward;

  Promise<undefined> navigate(USVString url, optional AppHistoryNavigateOptions options = {});
  Promise<undefined> reload(optional AppHistoryReloadOptions options = {});

  attribute EventHandler onnavigate;
  attribute EventHandler onnavigatesuccess;
  attribute EventHandler onnavigateerror;
};

dictionary AppHistoryNavigationOptions {
  any navigateInfo;
};

dictionary AppHistoryNavigateOptions : AppHistoryNavigationOptions {
  any state;
  boolean replace = false;
};

dictionary AppHistoryReloadOptions : AppHistoryNavigationOptions {
  any state;
};
</xmp>

Each {{AppHistory}} object has an associated <dfn for="AppHistory">entry list</dfn>, a [=list=] of {{AppHistoryEntry}} objects, initially empty.

Each {{AppHistory}} object has an associated <dfn for="AppHistory">current index</dfn>, an integer, initially &minus;1.

Each {{AppHistory}} object has an associated <dfn for="AppHistory">ongoing navigate event</dfn>, an {{AppHistoryNavigateEvent}} or null, initially null.

Each {{AppHistory}} object has an associated <dfn for="AppHistory">post-navigate event navigation signal</dfn>, an {{AbortSignal}} or null, initially null.

Each {{AppHistory}} object has an associated <dfn for="AppHistory">navigate method call promise</dfn>, which is either a {{Promise}} or null, initially null.

Each {{AppHistory}} object has an associated <dfn for="AppHistory">navigate method call serialized state</dfn>, which is either a [=serialized state=] or null, initially null.

<h3 id="entries-api">Introspecting the app history entry list</h3>

<dl class="domintro non-normative">
  <dt><code>{{Window/appHistory}} . {{AppHistory/current}}</code>
  <dd>
    <p>The current {{AppHistoryEntry}}.
  </dd>

  <dt><code>{{Window/appHistory}} . {{AppHistory/entries()}}</code>
  <dd>
    <p>Returns an array of {{AppHistoryEntry}} instances representing the current app history list, i.e. all session history entries for this {{Window}} that are [=same origin=] and contiguous to the current session history entry.
  </dd>

  <dt><code>{{Window/appHistory}} . {{AppHistory/canGoBack}}</code>
  <dd>
    <p>Returns true if the current {{AppHistoryEntry}} is not the first one in the app history entries list.
  </dd>

  <dt><code>{{Window/appHistory}} . {{AppHistory/canGoForward}}</code>
  <dd>
    <p>Returns true if the current {{AppHistoryEntry}} is not the last one in the app history entries list.
  </dd>
</dl>

<div algorithm>
  The <dfn attribute for="AppHistory">current</dfn> getter steps are:

  1. If [=this=]'s [=relevant global object=]'s [=associated Document=] is not [=Document/fully active=], then return null.

  1. If [=this=]'s [=AppHistory/current index=] is &minus;1, then return null.

     <p class="note">This occurs if accessing the API while on the initial `about:blank` {{Document}}, where the [=AppHistory/update for navigation=] algorithm will not yet have been run to completion.

  1. Return [=this=]'s [=AppHistory/entry list=][[=this=]'s [=AppHistory/current index=]].
</div>

<div algorithm>
  The <dfn method for="AppHistory">entries()</dfn> method steps are:

  1. If [=this=]'s [=relevant global object=]'s [=associated Document=] is not [=Document/fully active=], then return the empty list.

  1. Return [=this=]'s [=AppHistory/entries list=].
</div>

<div algorithm>
  The <dfn attribute for="AppHistory">canGoBack</dfn> getter steps are:

  1. If [=this=]'s [=relevant global object=]'s [=associated Document=] is not [=Document/fully active=], then return false.

  1. If [=this=]'s [=AppHistory/current index=] is &minus;1, then return false.

  1. If [=this=]'s [=AppHistory/current index=] is 0, then return false.

  1. Return true.
</div>

<div algorithm>
  The <dfn attribute for="AppHistory">canGoForward</dfn> getter steps are:

  1. If [=this=]'s [=relevant global object=]'s [=associated Document=] is not [=Document/fully active=], then return false.

  1. If [=this=]'s [=AppHistory/current index=] is &minus;1, then return false.

  1. If [=this=]'s [=AppHistory/current index=] is equal to [=this=]'s [=AppHistory/entry list=]'s [=list/size=] &minus; 1, then return false.

  1. Return true.
</div>

<div algorithm>
  To <dfn for="AppHistory">update for navigation</dfn> an {{AppHistory}} instance |appHistory|:

  1. Set |appHistory|'s [=AppHistory/post-navigate event navigation signal=] to null.

  1. Let |browsingContext| be |appHistory|'s [=relevant global object=]'s [=Window/browsing context=].

  1. [=Assert=]: |browsingContext| is not null.

  1. Let |sessionHistory| be |browsingContext|'s [=session history=].

  1. If |browsingContext| is <a spec="HTML">still on its initial `about:blank` `Document`</a>, then:

    1. Assert: |appHistory|'s [=AppHistory/entry list=] [=list/is empty=].

    1. Return.

    <p class="note">This can occur if running the <a spec="HTML">URL and history update steps</a>, e.g. via {{Document/open(unused1, unused2)|document.open()}}, on the initial `about:blank` {{Document}}. The app history API chooses not to expose the initial `about:blank` {{Document}}, so we bail early.

  1. Let |appHistorySHEs| be a new empty list.

  1. Let |currentSHE| be |sessionHistory|'s [=session history/current entry=].

  1. Let |backwardIndex| be the index of |currentSHE| within |sessionHistory|, minus 1.

  1. While |backwardIndex| > 0:

    1. Let |she| be |sessionHistory|[|backwardIndex|].

    1. If |she|'s [=session history entry/origin=] is [=same origin=] with |currentSHE|'s [=session history entry/origin=], then [=list/prepend=] |she| to |appHistorySHEs|.

    1. Otherwise, [=iteration/break=].

    1. Set |backwardIndex| to |backwardIndex| &minus; 1.

  1. [=list/Append=] |currentSHE| to |appHistorySHEs|.

  1. Let |forwardIndex| be the index of |currentSHE| within |sessionHistory|, plus 1.

  1. While |forwardIndex| &lt; |sessionHistory|'s [=list/size=]:

    1. Let |she| be |sessionHistory|[|forwardIndex|].

    1. If |she|'s [=session history entry/origin=] is [=same origin=] with |currentSHE|'s [=session history entry/origin=], then [=list/append=] |she| to |appHistorySHEs|.

    1. Otherwise, [=iteration/break=].

    1. Set |forwardIndex| to |forwardIndex| + 1.

  1. Let |newCurrentIndex| be the index of |currentSHE| within |appHistorySHEs|.

  1. Let |newEntryList| be an empty list.

  1. [=list/For each=] |oldAHE| of |appHistory|'s [=AppHistory/entry list=]:

    1. Set |oldAHE|'s [=AppHistoryEntry/index=] to &minus;1.

  1. Let |index| be 0.

  1. [=list/For each=] |she| of |appHistorySHEs|:

    1. If |appHistory|'s [=AppHistory/entry list=] [=list/contains=] an {{AppHistoryEntry}} |existingAHE| whose [=AppHistoryEntry/session history entry=] is |she|, then [=list/append=] |existingAHE| to |newEntryList|.

    1. Otherwise:

      1. Let |newAHE| be a [=new=] {{AppHistoryEntry}} created in the [=relevant realm=] of |appHistory|.

      1. Set |newAHE|'s [=AppHistoryEntry/session history entry=] to |she|.

      1. [=list/Append=] |newAHE| to |newEntryList|.

    1. Set |newEntryList|[|index|]'s [=AppHistoryEntry/index=] to |index|.

    1. Set |index| to |index| + 1.

  1. Set |appHistory|'s [=AppHistory/entry list=] to |newEntryList|.

  1. Set |appHistory|'s [=AppHistory/current index=] to |newCurrentIndex|.
</div>

<h3 id="global-navigate">Navigating</h3>

<dl class="domintro non-normative">
  <dt><code>await {{Window/appHistory}} . {{AppHistory/navigate(url, options)|navigate}}(<var ignore>url</var>)</code>
  <dt><code>await {{Window/appHistory}} . {{AppHistory/navigate(url, options)|navigate}}(<var ignore>url</var>, <var ignore>options</var>)</code>
  <dd>
    <p>Navigates the current page to the given <var ignore>url</var>. <var ignore>options</var> can contain the following values:

    * {{AppHistoryNavigateOptions/replace}} can be set to true to replace the current session history entry, instead of pushing a new one.
    * {{AppHistoryNavigationOptions/navigateInfo}} can be set to any value; it will populate the {{AppHistoryNavigateEvent/info}} property of the corresponding {{AppHistory/navigate}} event.
    * {{AppHistoryNavigateOptions/state}} can be set to any [=serializable object|serializable=] value; it will populate the state retrieved by {{AppHistoryEntry/getState()|appHistory.current.getState()}} once the navigation completes, for same-document navigations. (It will be ignored for navigations that end up cross-document.)

    <p>By default this will perform a full navigation (i.e., a cross-document navigation, unless the given URL differs only in a fragment from the current one). The {{AppHistory/navigate}} event's {{AppHistoryNavigateEvent/respondWith()}} method can be used to convert it into a same-document navigation.

    <p>The returned promise will behave as follows:

    * For same-document navigations created by using the {{AppHistory/navigate}} event's {{AppHistoryNavigateEvent/respondWith()}} method, it will fulfill or reject according to the promise passed to {{AppHistoryNavigateEvent/respondWith()}}.
    * For other same-document navigations (e.g., non-intercepted <a spec="HTML" lt="navigate to a fragment">fragment navigations</a>), it will fulfill immediately.
    * For cross-document navigations, it will never settle.
  </dd>

  <dt><code>await {{Window/appHistory}} . {{AppHistory/reload(options)|reload}}(<var ignore>options</var>)</code>
  <dd>
    <p>Reloads the current page. <var ignore>options</var> needs to contain at least one of {{AppHistoryNavigationOptions/navigateInfo}} or {{AppHistoryReloadOptions/state}}, which behave as described above.

    <p>The default behavior of performing a from-network-or-cache reload of the current page can be overriden by using the {{AppHistory/navigate}} event's {{AppHistoryNavigateEvent/respondWith()}} method. Doing so will mean this call only updates state or passes along the appropriate {{AppHistoryNavigationOptions/navigateInfo}}, plus performing whatever actions the {{AppHistory/navigate}} event handler sees fit to carry out.

    <p>The returned promise will behave as follows:

    * If the reload is intercepted by using the {{AppHistory/navigate}} event's {{AppHistoryNavigateEvent/respondWith()}} method, it will fulfill or reject according to the promise passed to {{AppHistoryNavigateEvent/respondWith()}}.
    * Otherwise, it will never settle.
  </dd>
</dl>

<!-- The following algorithms have several steps that would benefit from https://github.com/heycam/webidl/issues/983. -->

<div algorithm>
  The <dfn method for="AppHistory">navigate(|url|, |options|)</dfn> method steps are:

  1. <a spec="HTML" lt="parse a URL">Parse</a> |url| relative to [=this=]'s [=relevant settings object=]. If that returns failure, then return [=a promise rejected with=] a "{{SyntaxError}}" {{DOMException}}. Otherwise, let |urlRecord| be the <a spec="HTML">resulting URL record</a>.

  1. If [=this=]'s [=relevant global object=]'s [=associated Document=] is not [=Document/fully active=], then return [=a promise rejected with=] an "{{InvalidStateError}}" {{DOMException}}.

  1. If [=this=]'s [=relevant global object=]'s [=associated Document=]'s <a spec="HTML">unload counter</a> is greater than 0, then return [=a promise rejected with=] an "{{InvalidStateError}}" {{DOMException}}.

  1. Let |serializedState| be null.

  1. If |options|["{{AppHistoryNavigateOptions/state}}"] [=map/exists=], then set |serializedState| to [$StructuredSerializeForStorage$](|options|["{{AppHistoryNavigateOptions/state}}"]). If this throws an exception, return [=a promise rejected with=] that exception.

  1. Let |navigateInfo| be |options|["{{AppHistoryNavigationOptions/navigateInfo}}"] if it exists; otherwise, undefined.

  1. Let |historyHandling| be "<a for="history handling behavior">`replace`</a>" if |options|["{{AppHistoryNavigateOptions/replace}}"] is true; otherwise, "<a for="history handling behavior">`default`</a>".

  1. Return the result of [=performing an app history navigation=] given [=this=], |urlRecord|, |serializedState|, |navigateInfo|, and |historyHandling|.
</div>

<div algorithm>
  The <dfn method for="AppHistory">reload(|options|)</dfn> method steps are:

  1. If [=this=]'s [=relevant global object=]'s [=associated Document=] is not [=Document/fully active=], then return [=a promise rejected with=] an "{{InvalidStateError}}" {{DOMException}}.

  1. If [=this=]'s [=relevant global object=]'s [=associated Document=]'s <a spec="HTML">unload counter</a> is greater than 0, then return [=a promise rejected with=] an "{{InvalidStateError}}" {{DOMException}}.

  1. Let |urlRecord| be [=this=]'s [=relevant global object=]'s [=active document=]'s [=Document/URL=].

  1. Let |serializedState| be null.

  1. If |options|["{{AppHistoryReloadOptions/state}}"] [=map/exists=], then set |serializedState| to [$StructuredSerializeForStorage$](|options|["{{AppHistoryReloadOptions/state}}"]). If this throws an exception, return [=a promise rejected with=] that exception.

  1. Otherwise, if [=this=]'s [=AppHistory/current index=] is not &minus;1, then set |serializedState| to [=this=]'s [=AppHistory/entry list=][[=this=]'s [=AppHistory/current index=]]'s [=session history entry/app history state=].

  1. Let |navigateInfo| be |options|["{{AppHistoryNavigationOptions/navigateInfo}}"] if it exists; otherwise, undefined.

  1. Return the result of [=performing an app history navigation=] given [=this=], |urlRecord|, |serializedState|, |navigateInfo|, and "<a for="history handling behavior">`reload`</a>".
</div>

<div algorithm>
  To <dfn>perform an app history navigation</dfn> given an {{AppHistory}} object |appHistory|, a [=URL=] |url|, a [=serialized state=]-or-null |serializedState|, a JavaScript value |navigateInfo|, and a <a spec="HTML">history handling behavior</a> |historyHandling|:

  1. Let |browsingContext| be |appHistory|'s [=relevant global object=]'s [=Window/browsing context=].

  1. [=Assert=]: |browsingContext| is not null.

  1. Assert: |historyHandling| is either "<a for="history handling behavior">`replace`</a>", "<a for="history handling behavior">`reload`</a>", or "<a for="history handling behavior">`default`</a>".

  1. Let |promise| be [=a new promise=] created in |appHistory|'s [=relevant Realm=].

  1. Let |previousPromise| be |appHistory|'s [=AppHistory/navigate method call promise=].

  1. Set |appHistory|'s [=AppHistory/navigate method call promise=] to |promise|.

  1. Set |appHistory|'s [=AppHistory/navigate method call serialized state=] to |serializedState|.

  1. <a spec="HTML">Navigate</a> |browsingContext| to |url| with <i>[=navigate/historyHandling=]</i> set to |historyHandling|, <i>[=navigate/appHistoryInfo=]</i> set to |navigateInfo|, <i>[=navigate/appHistoryState=]</i> set to |serializedState|, and the <a spec="HTML">source browsing context</a> set to |browsingContext|.

  1. If |appHistory|'s [=AppHistory/navigate method call serialized state=] is non-null, then set |browsingContext|'s [=session history=]'s [=session history/current entry=]'s [=session history entry/app history state=] to |appHistory|'s [=AppHistory/navigate method call serialized state=].

  1. Set |appHistory|'s [=AppHistory/navigate method call serialized state=] to null.

  1. Set |appHistory|'s [=AppHistory/navigate method call promise=] to |previousPromise|.

  1. Return |promise|.
</div>

<p class="note">Unlike {{Location/assign()|location.assign()}} and friends, which are exposed across [=same origin-domain|origin-domain=] boundaries, {{AppHistory/navigate()|appHistory.navigate()}} and {{AppHistory/reload()|appHistory.reload()}} can only be accessed by code with direct synchronous access to the {{Window/appHistory}} property. Thus, we avoid the complications around tracking <a spec="HTML">source browsing contexts</a>, and we don't need to deal with the <a spec="HTML">allowed to navigate</a> check and its accompanying <i>[=navigate/exceptionsEnabled=]</i> flag. We just treat all navigations as being initiated by the {{AppHistory}} object itself.

<h3 id="global-events">Event handlers</h3>

The following are the [=event handlers=] (and their corresponding [=event handler event types=]) that must be supported, as [=event handler IDL attributes=], by objects implementing the {{AppHistory}} interface:

<table>
  <thead>
    <th>[=Event handler=]
    <th>[=Event handler event type=]
  <tbody>
    <tr>
      <td><dfn attribute for="AppHistory">onnavigate</dfn>
      <td><dfn event for="AppHistory">navigate</dfn>
    <tr>
      <td><dfn attribute for="AppHistory">onnavigatesuccess</dfn>
      <td><dfn event for="AppHistory">navigatesuccess</dfn>
    <tr>
      <td><dfn attribute for="AppHistory">onnavigateerror</dfn>
      <td><dfn event for="AppHistory">navigateerror</dfn>
</table>

<h2 id="navigate-event">The {{AppHistory/navigate}} event</h2>

<h3 id="navigate-event-class">The {{AppHistoryNavigateEvent}} class</h3>

<xmp class="idl">
[Exposed=Window]
interface AppHistoryNavigateEvent : Event {
  constructor(DOMString type, optional AppHistoryNavigateEventInit eventInit = {});

  readonly attribute AppHistoryNavigationType navigationType;
  readonly attribute AppHistoryDestination destination;
  readonly attribute boolean canRespond;
  readonly attribute boolean userInitiated;
  readonly attribute boolean hashChange;
  readonly attribute AbortSignal signal;
  readonly attribute FormData? formData;
  readonly attribute any info;

  undefined respondWith(Promise<undefined> newNavigationAction);
};

dictionary AppHistoryNavigateEventInit : EventInit {
  AppHistoryNavigationType navigationType = "push";
  required AppHistoryDestination destination;
  boolean canRespond = false;
  boolean userInitiated = false;
  boolean hashChange = false;
  required AbortSignal signal;
  FormData? formData = null;
  any info = null;
};

enum AppHistoryNavigationType {
  "reload",
  "push",
  "replace",
  "traverse"
};
</xmp>

<dl class="domintro non-normative">
  <dt><code><var ignore>event</var> . {{AppHistoryNavigateEvent/navigationType}}</code>
  <dd>
    <p>One of "{{AppHistoryNavigationType/reload}}", "{{AppHistoryNavigationType/push}}", "{{AppHistoryNavigationType/replace}}", or "{{AppHistoryNavigationType/traverse}}", indicating what type of navigation this is.
  </dd>
  <dt><code><var ignore>event</var> . {{AppHistoryNavigateEvent/destination}}</code>
  <dd>
    <p>An {{AppHistoryDestination}} representing the destination of the navigation.
  </dd>

  <dt><code><var ignore>event</var> . {{AppHistoryNavigateEvent/canRespond}}</code>
  <dd>
    <p>True if {{AppHistoryNavigateEvent/respondWith()}} can be called to convert this navigation into a single-page navigation; false otherwise.

    <p>Generally speaking, this will be true whenever the destination URL is [=rewritable=] relative to the page's current URL, except for cross-document back/forward navigations, where it will always be false.
  </dd>

  <dt><code><var ignore>event</var> . {{AppHistoryNavigateEvent/userInitiated}}</code>
  <dd>
    <p>True if this navigation was due to a user clicking on an <{a}> element, submitting a <{form}> element, or using the browser UI to navigate; false otherwise.
  </dd>

  <dt><code><var ignore>event</var> . {{AppHistoryNavigateEvent/hashChange}}</code>
  <dd>
    <p>True if this navigation is a <a spec="HTML" lt="navigate to a fragment">fragment navigation</a>; false otherwise.
  </dd>

  <dt><code><var ignore>event</var> . {{AppHistoryNavigateEvent/signal}}</code>
  <dd>
    <p>An {{AbortSignal}} which will become aborted if the navigation gets canceled, e.g. by the user pressing their browser's "Stop" button, or another higher-priority navigation interrupting this one.

    <p>The expected pattern is for developers to pass this along to any async operations, such as {{WindowOrWorkerGlobalScope/fetch()}}, which they perform as part of handling this navigation.
  </dd>

  <dt><code><var ignore>event</var> . {{AppHistoryNavigateEvent/formData}}</code>
  <dd>
    <p>The {{FormData}} representing the submitted form entries for this navigation, if this navigation is a POST <a spec="HTML" lt="submit">form submission</a>; null otherwise.
  </dd>

  <dt><code><var ignore>event</var> . {{AppHistoryNavigateEvent/info}}</code>
  <dd>
    <p>An arbitrary JavaScript value passed via other app history APIs that initiated this navigation, or null if the navigation was initiated by the user or via a non-app history API.
  </dd>

  <dt><code><var ignore>event</var> . {{AppHistoryNavigateEvent/respondWith()|respondWith}}(|newNavigationAction|)</code>
  <dd>
    <p>Synchronously converts this navigation into a same-document navigation to the destination URL.

    <p>The given |newNavigationAction| promise is used to signal the duration, and success or failure, of the navigation. After it settles, the browser signals to the user (e.g. via a loading spinner UI, or assistive technology) that the navigation is finished. Additionally, it fires {{AppHistory/navigatesuccess}} or {{AppHistory/navigateerror}} events as appropriate, which other parts of the web application can respond to.

    <p>This method will throw a "{{SecurityError}}" {{DOMException}} if {{AppHistoryNavigateEvent/canRespond}} is false, or if {{Event/isTrusted}} is false. It will throw an "{{InvalidStateError}}" {{DOMException}} if not called synchronously, during event dispatch.
  </dd>
</dl>

The <dfn attribute for="AppHistoryNavigateEvent">navigationType</dfn>, <dfn attribute for="AppHistoryNavigateEvent">destination</dfn>, <dfn attribute for="AppHistoryNavigateEvent">canRespond</dfn>, <dfn attribute for="AppHistoryNavigateEvent">userInitiated</dfn>, <dfn attribute for="AppHistoryNavigateEvent">hashChange</dfn>, <dfn attribute for="AppHistoryNavigateEvent">signal</dfn>, <dfn attribute for="AppHistoryNavigateEvent">formData</dfn>, and <dfn attribute for="AppHistoryNavigateEvent">info</dfn> getter steps are to return the value that the corresponding attribute was initialized to.

An {{AppHistoryNavigateEvent}} has the following associated values which are only conditionally used:

* <dfn for="AppHistoryNavigateEvent">classic history API serialized data</dfn>, a [=serialized state=]-or-null, used when its {{AppHistoryNavigateEvent/navigationType}} is "{{AppHistoryNavigationType/reload}}", "{{AppHistoryNavigationType/push}}" or "{{AppHistoryNavigationType/replace}}"
* <dfn for="AppHistoryNavigateEvent">destination entry</dfn>, a [=session history entry=], used when its {{AppHistoryNavigateEvent/navigationType}} is "{{AppHistoryNavigationType/traverse}}"

One of these is set appropriately when the event is [[#navigate-event-firing|fired]].

An {{AppHistoryNavigateEvent}} also has an associated <dfn for="AppHistoryNavigateEvent">navigation action promises list</dfn>, which is a [=list=] of {{Promise}} objects, initially empty.

<div algorithm>
  The <dfn method for="AppHistoryNavigateEvent">respondWith(|newNavigationAction|)</dfn> method steps are:

  1. If [=this=]'s [=relevant global object=]'s [=active Document=] is not [=Document/fully active=], then throw an "{{InvalidStateError}}" {{DOMException}}.
  1. If [=this=]'s {{Event/isTrusted}} attribute was initialized to false, then throw a "{{SecurityError}}" {{DOMException}}.
  1. If [=this=]'s {{AppHistoryNavigateEvent/canRespond}} attribute was initialized to false, then throw a "{{SecurityError}}" {{DOMException}}.
  1. If [=this=]'s [=Event/dispatch flag=] is unset, then throw an "{{InvalidStateError}}" {{DOMException}}.
  1. If [=this=]'s [=Event/canceled flag=] is set, then throw an "{{InvalidStateError}}" {{DOMException}}.
  1. [=list/Append=] |newNavigationAction| to [=this=]'s [=AppHistoryNavigateEvent/navigation action promises list=].
</div>

<h3 id="navigate-event-destination">The {{AppHistoryDestination}} class</h3>

<xmp class="idl">
[Exposed=Window]
interface AppHistoryDestination {
  readonly attribute USVString url;
  readonly attribute boolean sameDocument;
  any getState();
};
</xmp>

<dl class="domintro non-normative">
  <dt><code><var ignore>event</var> . {{AppHistoryNavigateEvent/destination}} . {{AppHistoryDestination/url}}</code>
  <dd>
    <p>The URL being navigated to.
  </dd>

  <dt><code><var ignore>event</var> . {{AppHistoryNavigateEvent/destination}} . {{AppHistoryDestination/sameDocument}}</code>
  <dd>
    <p>Indicates whether or not this navigation is to the same {{Document}} as the current {{Window/document}} value, or not. This will be true, for example, in cases of fragment navigations or {{History/pushState()|history.pushState()}} navigations.

    <p>Note that this property indicates the original nature of the navigation. If a cross-document navigation is converted into a same-document navigation using {{AppHistoryNavigateEvent/respondWith()|event.respondWith()}}, that will not change the value of this property.
  </dd>

  <dt><code><var ignore>event</var> . {{AppHistoryNavigateEvent/destination}} . {{AppHistoryDestination/getState()}}</code>
  <dd>
    <p>For "{{AppHistoryNavigationType/traverse}}" navigations, returns the deserialization of the state stored in the destination session history entry.

    <p>For "{{AppHistoryNavigationType/push}}" and "{{AppHistoryNavigationType/replace}}" navigations, returns the deserialization of the state passed to {{AppHistory/navigate()|appHistory.navigate()}}, if the navigation was initiated in that way, or null if it wasn't.

    <p>For "{{AppHistoryNavigationType/reload}}" navigations, returns the deserialization of the state passed to {{AppHistory/reload()|appHistory.reload()}}, if the reload was initiated in that way, or null if it wasn't.
  </dd>
</dl>

An {{AppHistoryDestination}} has an associated <dfn for="AppHistoryDestination">URL</dfn>, which is a [=URL=].

An {{AppHistoryDestination}} has an associated <dfn for="AppHistoryDestination">state</dfn>, which is a [=serialized state=]-or-null.

An {{AppHistoryDestination}} has an associated <dfn for="AppHistoryDestination">is same document</dfn>, which is a boolean.

The <dfn attribute for="AppHistoryDestination">url</dfn> getter steps are to return [=this=]'s [=AppHistoryDestination/URL=], [=URL serializer|serialized=].

The <dfn attribute for="AppHistoryDestination">sameDocument</dfn> getter steps are to return [=this=]'s [=AppHistoryDestination/is same document=].

<div algorithm>
  The <dfn method for="AppHistoryDestination">getState()</dfn> method steps are:

  1. If [=this=]'s [=AppHistoryDestination/state=] is null, then return null.
  1. Return [$StructuredDeserialize$]([=this=]'s [=AppHistoryDestination/state=]).
</div>

<h3 id="navigate-event-firing">Firing the event</h3>

<div algorithm="fire a traversal navigate event">
  To <dfn>fire a traversal `navigate` event</dfn> at an {{AppHistory}} |appHistory| given a [=session history entry=] <dfn for="fire a traversal navigate event">|destinationEntry|</dfn>, an optional [=user navigation involvement=] <dfn for="fire a traversal navigate event">|userInvolvement|</dfn> (default "<code>[=user navigation involvement/none=]</code>"), and an optional JavaScript value |info| (default undefined):

  1. Let |destinationURL| be |destinationEntry|'s [=session history entry/URL=].
  1. Let |destinationState| be |destinationEntry|'s [=session history entry/app history state=].
  1. Let |isSameDocument| be true if |destinationEntry|'s [=session history entry/document=] is equal to |appHistory|'s [=relevant global object=]'s [=associated Document=]; otherwise false.
  1. Let |event| be the result of [=creating an event=] given {{AppHistoryNavigateEvent}}, in |appHistory|'s [=relevant Realm=].
  1. Set |event|'s [=AppHistoryNavigateEvent/destination entry=] to |destinationEntry|.
  1. Return the result of performing the [=inner navigate event firing algorithm=] given |appHistory|, |event|, "{{AppHistoryNavigationType/traverse}}", |isSameDocument|, |destinationURL|, |destinationState|, |userInvolvement|, |info|, and null.
</div>

<div algorithm="fire a push or replace navigate event">
  To <dfn>fire a push or replace `navigate` event</dfn> at an {{AppHistory}} |appHistory| given an {{AppHistoryNavigationType}} <dfn for="fire a push or replace navigate event">|navigationType|</dfn>, a [=URL=] <dfn for="fire a push or replace navigate event">|destinationURL|</dfn>, a boolean <dfn for="fire a push or replace navigate event">|isSameDocument|</dfn>, an optional [=user navigation involvement=] <dfn for="fire a push or replace navigate event">|userInvolvement|</dfn> (default "<code>[=user navigation involvement/none=]</code>"), and an optional value <dfn for="fire a push or replace navigate event">|info|</dfn> (default undefined), an optional [=serialized state=]-or-null <dfn for="fire a push or replace navigate event">|state|</dfn> (default null), an optional [=list=] of {{FormData}} [=FormData/entries=] or null <dfn for="fire a push or replace navigate event">|formDataEntryList|</dfn> (default null), and an optional [=serialized state=]-or-null <dfn for="fire a push or replace navigate event">|classicHistoryAPISerializedData|</dfn> (default null):

  1. Let |event| be the result of [=creating an event=] given {{AppHistoryNavigateEvent}}, in |appHistory|'s [=relevant Realm=].
  1. Set |event|'s [=AppHistoryNavigateEvent/classic history API serialized data=] to |classicHistoryAPISerializedData|.
  1. Return the result of performing the [=inner navigate event firing algorithm=] given |appHistory|, |event|, |navigationType|, |isSameDocument|, |destinationURL|, |state|, |userInvolvement|, |info|, and |formDataEntryList|.
</div>

<div algorithm>
  The <dfn>inner `navigate` event firing algorithm</dfn> is the following steps, given an {{AppHistory}} |appHistory|, an {{AppHistoryNavigateEvent}} |event|, an {{AppHistoryNavigationType}} |navigationType|, a boolean |isSameDocument|, a [=URL=] |destinationURL|, a [=serialized state=]-or-null |destinationState|, a [=user navigation involvement=] |userInvolvement|, a JavaScript value |info|, and a [=list=] of {{FormData}} [=FormData/entries=] or null |formDataEntryList|:

  1. If |appHistory|'s [=relevant global object=]'s [=Window/browsing context=] is <a spec="HTML">still on its initial `about:blank` `Document`</a>, then return true.
  1. Initialize |event|'s {{Event/type}} to "{{AppHistory/navigate}}".
  1. Initialize |event|'s {{AppHistoryNavigateEvent/navigationType}} to |navigationType|.
  1. Initialize |event|'s {{AppHistoryNavigateEvent/info}} to |info|.
  1. Initialize |event|'s {{AppHistoryNavigateEvent/signal}} to a [=new=] {{AbortSignal}} created in |appHistory|'s [=relevant Realm=].
  1. Let |destination| be a [=new=] {{AppHistoryDestination}} created in |appHistory|'s [=relevant Realm=].
  1. Set |destination|'s [=AppHistoryDestination/URL=] to |destinationURL|.
  1. Set |destination|'s [=AppHistoryDestination/state=] to |destinationState|.
  1. Set |destination|'s [=AppHistoryDestination/is same document=] to |isSameDocument|.
  1. Initialize |event|'s {{AppHistoryNavigateEvent/destination}} to |destination|.
  1. Let |currentURL| be |appHistory|'s [=relevant global object=]'s [=associated document=]'s [=Document/URL=].
  1. If all of the following are true:
    * |isSameDocument| is true;
    * |destinationURL| [=url/equals=] |currentURL| with <i>[=url/equals/exclude fragments=]</i> set to true; and
    * |destinationURL|'s [=url/fragment=] is not [=string/is|identical to=] |currentURL|'s [=url/fragment=]

    then initialize |event|'s {{AppHistoryNavigateEvent/hashChange}} to true. Otherwise, initialize it to false.
  1. If |destinationURL| is [=rewritable=] relative to |currentURL|, and either |isSameDocument| is true or |navigationType| is not "{{AppHistoryNavigationType/traverse}}", then initialize |event|'s {{AppHistoryNavigateEvent/canRespond}} to true. Otherwise, initialize it to false.
  1. If either |userInvolvement| is not "<code>[=user navigation involvement/browser UI=]</code>" or  |navigationType| is not "{{AppHistoryNavigationType/traverse}}", then initialize |event|'s {{Event/cancelable}} to true.
  1. If both |event|'s {{AppHistoryNavigateEvent/canRespond}} and |event|'s {{Event/cancelable}} are false, then return true. (No event is actually fired.)
  1. If |userInvolvement| is "<code>[=user navigation involvement/none=]</code>", then initialize |event|'s {{AppHistoryNavigateEvent/userInitiated}} to false. Otherwise, initialize it to true.
  1. If |formDataEntryList| is not null, then initialize |event|'s {{AppHistoryNavigateEvent/formData}} to a [=new=] {{FormData}} created in |appHistory|'s [=relevant Realm=], associated to |formDataEntryList|. Otherwise, initialize it to null.
  1. [=Assert=]: |appHistory|'s [=AppHistory/ongoing navigate event=] is null.
  1. Set |appHistory|'s [=AppHistory/ongoing navigate event=] to |event|.
  1. Let |dispatchResult| be the result of [=dispatching=] |event| at |appHistory|.
  1. Let |shouldContinue| be |dispatchResult|.
  1. Set |appHistory|'s [=AppHistory/ongoing navigate event=] to null.
  1. If |appHistory|'s [=relevant global object=]'s [=active Document=] is not [=Document/fully active=], then:
    1. [=Synchronously finalize with an aborted navigation error=] given |appHistory| and |event|'s {{AppHistoryNavigateEvent/signal}}.
    1. Return false.

    <p class="note">This can occur if an event listener disconnected the <{iframe}> corresponding to [=this=]'s [=relevant global object=].</p>
  1. If |dispatchResult| is true:
    1. Set |appHistory|'s [=AppHistory/post-navigate event navigation signal=] to |event|'s {{AppHistoryNavigateEvent/signal}}.
    1. If |event|'s [=AppHistoryNavigateEvent/navigation action promises list=] is not empty and |navigationType| is not "{{AppHistoryNavigationType/traverse}}":
        1. Let |isPush| be true if |navigationType| is "{{AppHistoryNavigationType/push}}"; otherwise, false.
        1. Run the <a spec="HTML">URL and history update steps</a> given |event|'s [=relevant global object=]'s [=associated document=] and |event|'s {{AppHistoryNavigateEvent/destination}}'s [=AppHistoryDestination/URL=], with <i>[=URL and history update steps/serializedData=]</i> set to |event|'s [=AppHistoryNavigateEvent/classic history API serialized data=] and <i>[=URL and history update steps/isPush=]</i> set to |isPush|.
        1. Set |shouldContinue| to false.
    1. If |event|'s [=AppHistoryNavigateEvent/navigation action promises list=] is not empty or |isSameDocument| is true, then:
      1. Let |navigateMethodCallPromise| be |appHistory|'s [=AppHistory/navigate method call promise=].
      1. [=Wait for all=] of |event|'s [=AppHistoryNavigateEvent/navigation action promises list=], with the following success steps:
          1. [=Fire an event=] named {{AppHistory/navigatesuccess}} at |appHistory|.
          1. If |navigateMethodCallPromise| is non-null, then [=resolve=] |navigateMethodCallPromise| with undefined.
        and the following failure steps given reason |rejectionReason|:
          1. [=Fire an event=] named {{AppHistory/navigateerror}} at |appHistory| using {{ErrorEvent}}, with {{ErrorEvent/error}} initialized to |rejectionReason|, and {{ErrorEvent/message}}, {{ErrorEvent/filename}}, {{ErrorEvent/lineno}}, and {{ErrorEvent/colno}} initialized to appropriate values that can be extracted from |rejectionReason| in the same underspecified way the user agent typically does for the <a spec="HTML">report an exception</a> algorithm.
          1. If |navigateMethodCallPromise| is non-null, then [=reject=] |navigateMethodCallPromise| with |rejectionReason|.

      <p class="note">If |event|'s [=AppHistoryNavigateEvent/navigation action promises list=] is non-empty, then {{AppHistoryNavigateEvent/respondWith()}} was called and so we're performing a same-document navigation, for which we want to fire {{AppHistory/navigatesuccess}} or {{AppHistory/navigateerror}} events, and resolve or reject the promise returned by the corresponding {{AppHistory/navigate()|appHistory.navigate()}} call if one exists. Otherwise, if the navigation is same-document and was not canceled, we still perform these actions after a microtask, treating them as an instantly-successful navigation.
    1. Otherwise:
      1. Set |appHistory|'s [=AppHistory/navigate method call serialized state=] to null.

      <p class="note">This ensures that any call to {{AppHistory/navigate()|appHistory.navigate()}} which triggered this algorithm does not overwrite the [=session history entry/app history state=] of the [=session history/current entry=] for cross-document navigations.
  1. Otherwise, [=synchronously finalize with an aborted navigation error=] given |appHistory| and |event|'s {{AppHistoryNavigateEvent/signal}}.
  1. Return |shouldContinue|.
</div>

<div algorithm>
  To <dfn>synchronously finalize with an aborted navigation error</dfn> given an {{AppHistory}} |appHistory| and an {{AbortSignal}} |signal|:

  1. Set |appHistory|'s [=AppHistory/navigate method call serialized state=] to null.

     <p class="note">This ensures that any call to {{AppHistory/navigate()|appHistory.navigate()}} which triggered this algorithm does not overwrite the [=session history entry/app history state=] of the [=session history/current entry=] for aborted navigations.
  1. [=AbortSignal/Signal abort=] on |signal|.

     <p class="note">This might do nothing, if |signal| was previously aborted by <a>cancel any ongoing `navigate` event</a>.</p>
  1. [=Queue a microtask=] on |appHistory|'s [=relevant agent=]'s [=agent/event loop=] to perform the following steps:
    1. Let |error| be a [=new=] "{{AbortError}}" {{DOMException}}, created in |appHistory|'s [=relevant Realm=].
    1. [=Fire an event=] named {{AppHistory/navigateerror}} at |appHistory| using {{ErrorEvent}}, with {{ErrorEvent/error}} initialized to |error|, {{ErrorEvent/message}} initialized to the value of |error|'s {{DOMException/message}} property, {{ErrorEvent/filename}} initialized to the empty string, and {{ErrorEvent/lineno}} and {{ErrorEvent/colno}} initialized to 0.
    1. If |appHistory|'s [=AppHistory/navigate method call promise=] is non-null, then [=reject=] |appHistory|'s [=AppHistory/navigate method call promise=] with |error|.
</div>

<div algorithm>
  To <dfn>cancel any ongoing `navigate` event</dfn> for an {{AppHistory}} |appHistory|:

  1. If |appHistory|'s [=AppHistory/ongoing navigate event=] is non-null, then:
    1. Set |appHistory|'s [=AppHistory/ongoing navigate event=]'s [=Event/canceled flag=] to true.
       <p class="note">This will eventually lead to the <a>inner `navigate` event firing algorithm</a> calling [=synchronously finalize with an aborted navigation error=] once the event firing process completes. However, we want to [=AbortSignal/signal abort=] on the relevant {{AppHistoryNavigateEvent/signal|event.signal}} right away, thus the below step.
    1. Set |appHistory|'s [=AppHistory/ongoing navigate event=] to null.
    1. [=AbortSignal/Signal abort=] on |appHistory|'s [=AppHistory/ongoing navigate event=]'s {{AppHistoryNavigateEvent/signal}}.
  1. Otherwise, if |appHistory|'s [=AppHistory/post-navigate event navigation signal=] is non-null, then:
    1. [=AbortSignal/Signal abort=] on |appHistory|'s [=AppHistory/post-navigate event navigation signal=].
    1. Set |appHistory|'s [=AppHistory/post-navigate event navigation signal=] to null.
</div>

<!-- Remember to modify pushState()/replaceState() to use this, when we eventually move to the HTML Standard. -->
A [=URL=] is <dfn>rewritable</dfn> relative to another [=URL=] if they differ in only the [=url/path=], [=url/query=], or [=url/fragment=] components.

<div class="example" id="example-rewritable-url">
  `https://example.com/foo?bar#baz` is rewritable relative to `https://example.com/qux`.

  However, the concept is not the same as the two URLs' [=url/origins=] being [=same origin|the same=]: `https://user:password@example.com/qux` is not rewritable relative to `https://example.com/qux`.

  Similarly, `about:blank` or `blob:` URLs are not rewritable relative to `https:` URLs, despite there being cases where a `https`:-[=Document/URL=] {{Document}} is [=same origin=] with an `about:blank` or `blob:`-derived {{Document}}.
</div>

<h2 id="apphistoryentry-class">App history entries</h2>

<xmp class="idl">
[Exposed=Window]
interface AppHistoryEntry : EventTarget {
  readonly attribute DOMString key;
  readonly attribute DOMString id;
  readonly attribute USVString url;
  readonly attribute long long index;
  readonly attribute boolean sameDocument;

  any getState();

  // TODO event handlers
};
</xmp>

<dl class="domintro non-normative">
  <dt><code>entry . {{AppHistoryEntry/key}}</code>
  <dd>
    <p>A [=user agent=]-generated random UUID string representing this app history entry's place in the app history list. This value will be reused by other {{AppHistoryEntry}} instances that replace this one due to replace-style navigations. This value will survive session restores.

    <!-- TODO proper cross-link -->
    <p>This is useful for navigating back to this location in the app history entry list, using `appHistory.goTo(key)`.
  </dd>

  <dt><code>entry . {{AppHistoryEntry/id}}</code>
  <dd>
    <p>A [=user agent=]-generated random UUID string representing this specific app history entry. This value will <em>not</em> be reused by other {{AppHistoryEntry}} instances. This value will survive session restores.

    <p>This is useful for associating data with this app history entry using other storage APIs.
  </dd>

  <dt><code>entry . {{AppHistoryEntry/url}}</code>
  <dd>
    <p>The URL of this app history entry.
  </dd>

  <dt><code>entry . {{AppHistoryEntry/index}}</code>
  <dd>
    <p>The index of this app history entry within {{AppHistory/entries()|appHistory.entries()}}, or &minus;1 if the entry is not in the app history list.
  </dd>

  <dt><code>entry . {{AppHistoryEntry/sameDocument}}</code>
  <dd>
    <p>Indicates whether or not this app history entry is for the same {{Document}} as the current {{Window/document}} value, or not. This will be true, for example, when the entry represents a fragment navigation or single-page app navigations.
  </dd>

  <dt><code>entry . {{AppHistoryEntry/getState()}}</code>
  <dd>
    <p>Returns the deserialization of the state stored in this entry, which was added to the entry using {{AppHistory/navigate()|appHistory.navigate()}}. This state survives session restores.

    <p>Note that in general, unless the state value is a primitive, <code>entry.getState() !== entry.getState()</code>, since a fresh copy is returned each time.

    <p>This state is unrelated to the classic history API's {{History/state|history.state}}.
  </dd>
</dl>

Each {{AppHistoryEntry}} has an associated <dfn for="AppHistoryEntry">session history entry</dfn>, which is a [=session history entry=].

Each {{AppHistoryEntry}} has an associated <dfn for="AppHistoryEntry">index</dfn>, which is an integer.

<div algorithm>
  The <dfn attribute for="AppHistoryEntry">key</dfn> getter steps are:

  1. If [=this=]'s [=relevant global object=]'s [=associated Document=] is not [=Document/fully active=], then return the empty string.
  1. Return [=this=]'s [=AppHistoryEntry/session history entry=]'s [=session history entry/app history key=].
</div>

<div algorithm>
  The <dfn attribute for="AppHistoryEntry">id</dfn> getter steps are:

  1. If [=this=]'s [=relevant global object=]'s [=associated Document=] is not [=Document/fully active=], then return the empty string.
  1. Return [=this=]'s [=AppHistoryEntry/session history entry=]'s [=session history entry/app history id=].
</div>

<div algorithm>
  The <dfn attribute for="AppHistoryEntry">url</dfn> getter steps are:

  1. If [=this=]'s [=relevant global object=]'s [=associated Document=] is not [=Document/fully active=], then return the empty string.
  1. Return [=this=]'s [=AppHistoryEntry/session history entry=]'s [=session history entry/URL=], [=URL serializer|serialized=].
</div>

<div algorithm>
  The <dfn attribute for="AppHistoryEntry">index</dfn> getter steps are:

  1. If [=this=]'s [=relevant global object=]'s [=associated Document=] is not [=Document/fully active=], then return &minus;1.
  1. Return [=this=]'s [=AppHistoryEntry/session history entry=]'s [=AppHistoryEntry/index=].
</div>

<div algorithm>
  The <dfn attribute for="AppHistoryEntry">sameDocument</dfn> getter steps are:

  1. If [=this=]'s [=relevant global object=]'s [=associated Document=] is not [=Document/fully active=], then return false.
  1. Return true if [=this=]'s [=AppHistoryEntry/session history entry=]'s [=session history entry/document=] equals [=this=]'s [=relevant global object=]'s [=associated Document=], and false otherwise.
</div>

<div algorithm>
  The <dfn method for="AppHistoryEntry">getState()</dfn> method steps are:

  1. If [=this=]'s [=relevant global object=]'s [=associated Document=] is not [=Document/fully active=], then return undefined.
  1. If [=this=]'s [=AppHistoryEntry/session history entry=]'s [=session history entry/app history state=] is null, then return undefined.
  1. Return [$StructuredDeserialize$]([=this=]'s [=AppHistoryEntry/session history entry=]'s [=session history entry/app history state=]).

  <p class="note">Unlike {{History/state|history.state}}, this will deserialize upon each access.

  <p class="note">This can in theory throw an exception, if attempting to deserialize a large {{ArrayBuffer}} when not enough memory is available.
</div>

<h2 id="navigate-patches">Patches to fire the {{AppHistory/navigate}} event</h2>

The following section details monkeypatches to [[!HTML]] that cause the {{AppHistory/navigate}} event to be fired appropriately, and for canceling the event to cancel the navigation. The first few sections detail slight tweaks to existing algorithms to pass through useful information into the navigation and history traversal algorithms. Then, [[#navigate-algorithm-patches]] contains the actual firing of the event.

<h3 id="form-patches">Form submission patches</h3>

To properly thread the form entry list from its creation through to {{AppHistoryNavigateEvent}}'s {{AppHistoryNavigateEvent/formData}} property, we need the following modifications:

<div algorithm="form navigate">
  Modify the <a spec="HTML">navigate</a> algorithm to take a [=list=] of [=FormData/entries=] or null <dfn for="navigate">|entryList|</dfn> (default null), replacing its |navigationType| parameter. Then insert a step somewhere early in the algorithm to convert this back into the |navigationType| variable used by the [=in parallel=] section that is ultimately passed to [[CSP]]:

  1. Let |navigationType| be "`form-submission`" if |entryList| is non-null; otherwise, "`other`".
</div>

<div algorithm="plan to navigate">
  Modify the <a spec="HTML">plan to navigate</a> algorithm to take an additional optional argument |entryList| (default null). Then, modify the step which calls <a spec="HTML">navigate</a> to pass it along:

  1. <a spec="HTML">Navigate</a> <var ignore>target browsing context</var> to <var ignore>destination</var>, with <i>[=navigate/historyHandling=]</i> set to <var ignore>historyHandling</var> <del>and <i>[=navigate/navigationType=]</i> set to "`form-submission`"</del><ins><i>[=navigate/entryList=]</i> set to |entryList|</ins>.
</div>

<div algorithm="submit as entity body">
  Modify the <a spec="HTML">submit as entity body</a> algorithm to pass <var ignore>entry list</var> along to <a spec="HTML">plan to navigate</a> as a second argument.
</div>

<h3 id="user-initiated-patches">Browser UI/user-initiated patches</h3>

To more rigorously specify when a navigation is initiated from browser UI or by the user interacting with <{a}>, <{area}>, and <{form}> elements, both for the purposes of the {{AppHistoryNavigateEvent}}'s {{AppHistoryNavigateEvent/userInitiated}} property and for prohibiting interception of certain types of browser-UI-initiated navigations, we need the following modifications:

Introduce (right before the definition of the <a spec="HTML">navigate</a> algorithm) the concept of a <dfn>user navigation involvement</dfn>, which is one of the following:

: "<dfn for="user navigation involvement"><code>browser UI</code></dfn>"
:: The navigation was initiated by the user via browser UI mechanisms
: "<dfn for="user navigation involvement"><code>activation</code></dfn>"
:: The navigation was initiated by the user via the [=EventTarget/activation behavior=] of an element
: "<dfn for="user navigation involvement"><code>none</code></dfn>"
:: The navigation was not initiated by the user

Define the <dfn for="Event">user navigation involvement</dfn> for an {{Event}} |event| as "<code>[=user navigation involvement/activation=]</code>" if |event|'s {{Event/isTrusted}} attribute is initialized to true, and "<code>[=user navigation involvement/none=]</code>" otherwise.

Modify the <a spec="HTML">navigate</a> algorithm to take an optional named argument <dfn for="navigate"><var ignore>userInvolvement</var></dfn> (default "<code>[=user navigation involvement/none=]</code>"). Then, update the paragraph talking about browser-UI initiated navigation as follows:

<blockquote>
  A user agent may provide various ways for the user to explicitly cause a browsing context to <a spec="HTML">navigate</a>, in addition to those defined in this specification.<ins> Such cases must set the <i>[=navigate/userInvolvement=]</i> argument to "<code>[=user navigation involvement/browser UI=]</code>".</ins>
</blockquote>

<p class="note">This infrastructure partially solves <a href="https://github.com/whatwg/html/issues/5381">whatwg/html#5381</a>, and it'd be ideal to update the \`<a http-header><code>Sec-Fetch-Site</code></a>\` spec at the same time.</p>

Modify the <a spec="HTML">navigate to a fragment</a> algorithm to take a new <var ignore>userInvolvement</var> argument. Then, update the call to it from <a spec="HTML">navigate</a> to set <i>[=navigate/userInvolvement=]</i> to this <var ignore>userInvolvement</var> value.

Modify the <a spec="HTML">traverse the history by a delta</a> argument to take an optional named argument <dfn for="traverse the history by a delta"><var ignore>userInvolvement</var></dfn> (default "<code>[=user navigation involvement/none=]</code>"). Then, update the paragraph talking about user-initiated navigation as follows:

<blockquote>
  When the user navigates through a [=browsing context=], e.g. using a browser's back and forward buttons, the user agent must <a spec="HTML">traverse the history by a delta</a> with a delta equivalent to the action specified by the user<del> and</del><ins>,</ins> the browsing context being operated on<ins>, and <i>[=traverse the history by a delta/userInvolvement=]</i> set to "<code>[=user navigation involvement/browser UI=]</code>"</ins>.
</blockquote>

<hr>

Modify the <a spec="HTML">follow the hyperlink</a> algorithm to take a new <var ignore>userInvolvement</var> argument. Then, update the call to it from <a spec="HTML">navigate</a> to set <i>[=navigate/userInvolvement=]</i> to this <var ignore>userInvolvement</var> value.

<div algorithm="area activation behavior">
  Modify the [=EventTarget/activation behavior=] of <{area}> elements by introducing the |event| argument and replacing the <a spec="HTML">follow the hyperlink</a> step with the following:

  1. Otherwise, <a spec="HTML">follow the hyperlink</a> created by <var ignore>element</var> with the [=Event/user navigation involvement=] for |event|.
</div>

<div algorithm="a activation behavior">
  Modify the [=EventTarget/activation behavior=] of <{a}> elements by replacing its <a spec="HTML">follow the hyperlink</a> step with the following:

  1. Otherwise, <a spec="HTML">follow the hyperlink</a> created by <var ignore>element</var> with the [=Event/user navigation involvement=] for <var ignore>event</var>.
</div>

Expand the section on "<a href="https://html.spec.whatwg.org/multipage/semantics.html#providing-users-with-a-means-to-follow-hyperlinks-created-using-the-link-element">Providing users with a means to follow hyperlinks created using the `link` element</a>" by adding the following sentence:

<blockquote><ins>Such invocations of <a spec="HTML">follow the hyperlink</a> algorithm must set the <i>[=navigate/userInvolvement=]</i> argument to "<code>[=user navigation involvement/browser UI=]</code>".</ins></blockquote>

<hr>

Modify the <a spec="HTML">plan to navigate</a> algorithm to take a <var ignore>userInvolvement</var> argument. Then, update the call to it from <a spec="HTML">navigate</a> to set <i>[=navigate/userInvolvement=]</i> to this <var ignore>userInvolvement</var> value.

Modify the <a spec="HTML" lt="submitted">submit</a> algorithm to take an optional <var ignore>userInvolvement</var> argument (default "<code>[=user navigation involvement/none=]</code>").  Have the <a spec="HTML" lt="submitted">submit</a> algorithm pass along its value to all invocations of <a spec="HTML">plan to navigate</a>.

Modify the definition of the [=EventTarget/activation behavior=] for <{input}> elements to take an <var ignore>event</var> argument. Then, pass along this argument to the invocation of the <a spec="HTML">input activation behavior</a>.

Modify the Submit Button state's <a spec="HTML">input activation behavior</a> by having it take an <var ignore>event<var> argument and pass along the [=Event/user navigation involvement=] for <var ignore>event</var> as the final argument when it calls <a spec="HTML" lt="submitted">submit</a>.

Modify the Image Button state's <a spec="HTML">input activation behavior</a> by having it take an <var ignore>event<var> argument and pass along the [=Event/user navigation involvement=] for <var ignore>event</var> as the final argument when it calls <a spec="HTML" lt="submitted">submit</a>.

Modify the <{button}> element's [=EventTarget/activation behavior=] by having it take an <var ignore>event</var> argument and, in the Submit Button case, to pass along the [=Event/user navigation involvement=] for <var ignore>event</var> as the final argument when it calls <a spec="HTML" lt="submitted">submit</a>.

Modify the no-<a spec="HTML">submit button</a> case for <a href="https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#implicit-submission">implicit form submission</a> to pass along "<code>[=user navigation involvement/activation=]</code>" as the final argument when it calls <a spec="HTML" lt="submitted">submit</a>.

<p class="note">The case of implicit submission when a submit button is present is automatically taken care of because it fires a (trusted) click event at the submit button.</p>

<h3 id="navigate-algorithm-patches">Navigation algorithm updates</h3>

With the above infrastructure in place, we can actually fire and handle the {{AppHistory/navigate}} event in the following locations:

<div algorithm="shared history push/replace steps">
  Modify the <a spec="HTML">shared history push/replace state steps</a> by inserting the following steps right before the step that runs the <a spec="HTML">URL and history update steps</a>.

  1. Let |appHistory| be <var ignore>history</var>'s [=relevant global object=]'s [=Window/app history=].
  1. [=Cancel any ongoing navigate event=] for |appHistory|.
  1. Let |navigationType| be "{{AppHistoryNavigationType/push}}" if <var ignore>isPush</var> is true, and "{{AppHistoryNavigationType/replace}}" otherwise.
  1. Let |continue| be the result of [=firing a push or replace navigate event=] at |appHistory| with <i>[=fire a push or replace navigate event/navigationType=]</i> set to |navigationType|, <i>[=fire a push or replace navigate event/isSameDocument=]</i> set to true, <i>[=fire a push or replace navigate event/destinationURL=]</i> set to <var ignore>newURL</var>, and <i>[=fire a push or replace navigate event/classicHistoryAPISerializedData=]</i> set to <var ignore>serializedData</var>.
  1. If |continue| is false, return.
</div>

<div algorithm="navigate to a fragment">
  Modify the <a spec="HTML">navigate to a fragment</a> algorithm by prepending the following steps. Recall that per [[#user-initiated-patches]] we have introduced a |userInvolvement| argument.

  1. Let |appHistory| be the [=session history/current entry=]'s <a spec="HTML" for="session history entry">document</a>'s [=relevant global object=]'s [=Window/app history=].
  1. Let |navigationType| be the result of [=converting a history handling behavior to a navigation type=] given <var ignore>historyHandling</var>.
  1. Let |continue| be the result of [=firing a push or replace navigate event=] at |appHistory| given with <i>[=fire a push or replace navigate event/navigationType=]</i> set to |navigationType|, <i>[=fire a push or replace navigate event/isSameDocument=]</i> set to true, <i>[=fire a push or replace navigate event/userInvolvement=]</i> set to |userInvolvement|, and <i>[=fire a push or replace navigate event/destinationURL=]</i> set to <var ignore>url</var>.
  1. If |continue| is false, return.
</div>

<div algorithm="navigate" id="navigate-modifications">
  Modify the <a spec="HTML">navigate</a> algorithm to take an optional <dfn for="navigate">|appHistoryInfo|</dfn> argument (default undefined), and an an optional <dfn for="navigate">|appHistoryState|</dfn> argument (default null). Then, insert the following steps right before the step which goes [=in parallel=]. (Recall that per [[#user-initiated-patches]] we have introduced |userInvolvement| argument, and per [[#form-patches]] we have introduced an |entryList| argument.)

  1. Let |appHistory| be <var ignore>browsingContext</var>'s [=browsing context/active window=]'s [=Window/app history=].
  1. [=Cancel any ongoing navigate event=] for |appHistory|.
  1. If none of the following are true:
    * <var ignore>historyHandling</var> is "<a for="history handling behavior">`entry update`</a>"
    * <var ignore>userInvolvement</var> is "<code>[=user navigation involvement/browser UI=]</code>"
    * <var ignore>browsingContext</var>'s [=active document=]'s [=Document/origin=] is not [=same origin-domain=] with the [=source browsing context=]'s [=active document=]'s [=Document/origin=]
    * <var ignore>browsingContext</var>'s only entry in its <a spec="HTML">session history</a> is the `about:blank` {{Document}} that was added when <var ignore>browsingContext</var> was <a spec="HTML" lt="create a new browsing context">created</a>

    then:

      1. Let |navigationType| be the result of [=converting a history handling behavior to a navigation type=] given <var ignore>historyHandling</var>.
      1. Let |continue| be the result of [=firing a push or replace navigate event=] at |appHistory| with <i>[=fire a push or replace navigate event/navigationType=]</i> set to |navigationType|, <i>[=fire a push or replace navigate event/isSameDocument=]</i> set to false, <i>[=fire a push or replace navigate event/userInvolvement=]</i> set to |userInvolvement|, <i>[=fire a push or replace navigate event/formDataEntryList=]</i> set to |entryList|, <i>[=fire a push or replace navigate event/destinationURL=]</i> set to <var ignore>url</var>, <i>[=fire a push or replace navigate event/info=]</i> set to |appHistoryInfo|, and <i>[=fire a push or replace navigate event/state=]</i> set to |appHistoryState|.
      1. If |continue| is false, return.

    <p class="note">"<a for="history handling behavior">`entry update`</a>" is excluded since {{AppHistory/navigate}} would have fired earlier as part of <a spec="HTML">traversing the history by a delta</a>.

    <p class="note">"<code>[=user navigation involvement/browser UI=]</code>" or [=same origin-domain|cross origin-domain=] navigations that cause <a spec="HTML" lt="navigate to a fragment">fragment navigations</a> <em>do</em> fire the {{AppHistory/navigate}} event; those are handled as part of the <a spec="HTML">navigate to a fragment</a> algorithm called earlier in <a spec="HTML">navigate</a>, which is not guarded by this condition.
</div>

<div algorithm>
  To <dfn>convert a history handling behavior to a navigation type</dfn> given a <a spec="HTML">history handling behavior</a> |historyHandling|:

  1. [=Assert=]: |historyHandling| is not "<a spec="HTML" for="history handling behavior">`entry update`</a>".
  1. Return the result of switching on |historyHandling|:

    <dl class="switch">
    : "<a spec="HTML" for="history handling behavior">`reload`</a>"
    :: "{{AppHistoryNavigationType/reload}}"
    : "<a spec="HTML" for="history handling behavior">`replace`</a>"
    :: "{{AppHistoryNavigationType/replace}}"
    : "<a spec="HTML" for="history handling behavior">`default`</a>"
    :: "{{AppHistoryNavigationType/push}}"
</div>

<h3 id="navigate-event-traversal-patches">History traversal updates</h3>

<div algorithm="traverse the history by a delta">
  The <a spec="HTML">traverse the history by a delta</a> algorithm will be totally re-written as part of <a href="https://github.com/whatwg/html/pull/6315">the session history rewrite</a>. Here we reproduce the final version of the algorithm, after both that rewrite and with appropriate app history updates. Recall that per [[#user-initiated-patches]] we have introduced a |userInvolvement| argument, so the arguments are now |delta|, |source browsing context|, and |userInvolvement|.

  1. Let |traversable| be |source browsing context|'s [=browsing context/containing navigable=]'s [=navigable/traversable navigable=].
  1. Let |initiatorOrigin| be |source browsing context|'s [=active document=]'s [=Document/origin=].
  1. [=parallel queue/enqueue steps|Enqueue the following steps=] to |traversable|'s [=traversable navigable/session history traversal queue=]:
    1. Let |allSteps| be the result of [=traversable navigable/getting all history steps=] for |traversable|.
    1. Let |currentStepIndex| be the index of the [=traversable navigable/current session history step=] within |allSteps|.
    1. Let |targetStepIndex| be |currentStepIndex| plus |delta|.
    1. If |allSteps|[|targetStepIndex|] does not [=set/exist=], then return.
    1. [=Apply the history step=] |allSteps|[|targetStepIndex|] to |traversable| with true, <var ignore>step</var>, |initiatorOrigin|, and |userInvolvement|.
</div>

<div algorithm="apply the history step">
  Modify the <a spec="HTML">apply the history step</a> algorithm as follows. Change <var ignore>checkForUserCancellation</var> to |fireBeforeunloadAndNavigate|. Add the |userInvolvement| parameter. Then, insert the following step after step 12 (which assembles |toTraverse| and other lists) but before step 13 (which checks if unloading is user-cancelled):

  1. If |fireBeforeunloadAndNavigate| is true and the result of <a>firing traversal `navigate` events</a> given |toTraverse|, <var ignore>step</var>, <var ignore>initiatorToCheck</var>, and |userInvolvement| is false, then return.
</div>

<div algorithm>
  To <dfn>fire traversal `navigate` events</dfn> for a [=list=] of [=navigables=] |toTraverse|, an integer |step|, an [=origin=] |initiatorOrigin|, and a [=user navigation involvement=] |userInvolvement|:

  1. Let |overallResult| be true.
  1. Let |totalTasks| be the [=list/size=] of |toTraverse|.
  1. Let |completedTasks| be 0.
  1. [=list/For each=] |navigable| of |toTraverse|, [=queue a global task=] on the [=history traversal task source=] given |navigable|'s [=navigable/active document=]'s [=relevant global object=] to run these steps:
      1. Let |destinationEntry| be the item in the result of [=navigable/getting the session history entries=] for |navigable| that has the greatest [=session history entry/step=] less than or equal to |step|.
      1. If |destinationEntry|'s [=session history entry/document=] is not equal to |navigable|'s [=navigable/active document=], and |initiatorOrigin| is not [=same origin-domain=] with |navigable|'s [=navigable/active document=]'s [=Document/origin=], then abort these steps.
      1. Let |appHistory| be |navigable|'s [=navigable/active document=]'s [=relevant global object=]'s [=Window/app history=].
      1. Let |result| be the result of [=firing a traversal navigate event=] at |appHistory| with <i>[=fire a traversal navigate event/destinationEntry=]</i> set to |destinationEntry| and <i>[=fire a traversal navigate event/userInvolvement=]</i> set to |userInvolvement|.
      1. If |result| is false, then set |overallResult| to false.
      1. Increment |completedTasks|.
  1. Wait for |completedTasks| to be |totalTasks|.
  1. Return |overallResult|.
</div>

<h2 id="session-history-patches">Patches to session history</h2>

This section details monkeypatches to [[!HTML]] to track appropriate data for associating an {{AppHistory}} with a [=session history entry=].

<h3 id="session-history-new-she-fields">New [=session history entry=] items</h3>

Each [=session history entry=] gains the following new [=struct/items=]:

* <dfn for="session history entry">origin</dfn>, an [=origin=]

* <dfn for="session history entry">app history key</dfn>, a string, initially set to the result of [=generating a random UUID=]

* <dfn for="session history entry">app history id</dfn>, a string, initially set to the result of [=generating a random UUID=]

* <dfn for="session history entry">app history state</dfn>, which is [=serialized state=] or null, initially null

<h3 id="session-history-patches-key">Carrying over the app history key</h3>

<div algorithm="update the session history with the new page key patch">
  Update the <a spec="HTML">update the session history with the new page</a> algorithm's "<a for="history handling behavior">`replace`</a>" case by adding the following step after the construction of |newEntry|:

  1. If |newEntry|'s [=session history entry/origin=] is the [=same origin|same=] as |sessionHistory|'s [=session history/current entry=]'s [=session history entry/origin=], then set |newEntry|'s [=session history entry/app history key=] to |sessionHistory|'s [=session history/current entry=]'s [=session history entry/app history key=].
</div>

<h3 id="session-history-patches-state">Carrying over the app history state</h3>

<div algorithm="navigate to a fragment state patch">
  Update the <a spec="HTML">navigate to a fragment</a> algorithm by updating the step which creates and appends a new session history entry to carry over the [=session history entry/app history state=] from the [=session history/current entry=] as well.
</div>

<h3 id="session-history-patches-origin">Tracking the [=session history entry/origin=] member</h3>

Update the <a spec="HTML">update the session history with the new page</a> algorithm's "<a for="history handling behavior">`replace`</a>" and "<a for="history handling behavior">`default`</a>" cases to set <var ignore>newEntry</var>'s [=session history entry/origin=] to <var ignore>newDocument</var>'s [=Document/origin=] as part of its creation.

Update the <a spec="HTML">navigate to a fragment</a> algorithm to set the new [=session history entry=]'s [=session history entry/origin=] to the [=session history/current entry=]'s [=session history entry/document=]'s [=Document/origin=].

Update the <a spec="HTML">URL and history update steps</a> algorithm to set the new [=session history entry=]'s [=session history entry/origin=] to <var ignore>document</var>'s [=Document/origin=].

Potentially update the <a spec="HTML">traverse the history</a> algorithm to consult the new [=session history entry/origin=] field, instead of checking the [=session history entry/document=]'s [=Document/origin=], since the [=session history entry/document=] can disappear?? Needs further investigation.

<h3 id="session-history-patches-update">Updating the {{AppHistory}} object</h3>

<div algorithm="traverse the history update patch">
  Update the <a spec="HTML">traverse the history</a> algorithm by adding the following step before the final step which fires various events:

  1. [=AppHistory/Update for navigation=] <var ignore>newDocument</var>'s [=relevant global object=]'s [=Window/app history=].
</div>

<div algorithm="URL and history update steps update patch">
  Update the <a spec="HTML">URL and history update steps</a> by appending the following final step:

  1. [=AppHistory/Update for navigation=] of <var ignore>document</var>'s [=relevant global object=]'s [=Window/app history=].
</div>

<p class="note">We do not [=AppHistory/update for navigation=] when initially <a spec="HTML">creating a new browsing context</a>, as we intentionally don't want to include the initial `about:blank` {{Document}} in any app history entry list.

<h2 id="other-patches">Other patches</h2>

<h3 id="cancel-navigation">Canceling navigation</h3>

The existing HTML specification discusses canceling a navigation in a few places. However, the process is not very well-defined. We may be able to make it more rigorous, after the <a href="https://github.com/whatwg/html/issues/5767">session history rewrite</a> lands.

<div algorithm="navigation canceling patch">
  The main addition of app history is that any time navigation of a given [=browsing context=] |bc| is canceled, the user agent must <a>cancel any ongoing `navigate` event</a> for |bc|'s [=browsing context/active window=]'s [=Window/app history=].
</div>

<p class="note">This includes navigation cancelation induced by the <a spec="HTML">stop document loading</a> algorithm, which is invoked by user interface elements such as a stop button and by {{Window/stop()|window.stop()}}.</p>
